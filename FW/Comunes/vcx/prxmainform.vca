SCCTEXT Version 4.0.0.2
PLATFORM C(8,0),UNIQUEID C(10,0),TIMESTAMP N(10,0),CLASS M(4,0),CLASSLOC M(4,0),BASECLASS M(4,0),OBJNAME M(4,0),PARENT M(4,0),PROPERTIES M(4,0),PROTECTED M(4,0),METHODS M(4,0),OBJCODE M(4,0),OLE M(4,0),OLE2 M(4,0),RESERVED1 M(4,0),RESERVED2 M(4,0),RESERVED3 M(4,0),RESERVED4 M(4,0),RESERVED5 M(4,0),RESERVED6 M(4,0),RESERVED7 M(4,0),RESERVED8 M(4,0),USER M(4,0)
1252

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] Class     
[START RESERVED1]
VERSION =   3.00[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1S50Y2SDO
[CLASS] prxform
[CLASSLOC] prxbase.vcx
[BASECLASS] form
[OBJNAME] mainform
[START PROPERTIES]
Height = 500
Width = 600
DoCreate = .T.
Caption = "Main Form"
nlevel = 0
nstatus = 0
ocolcombos = .F.
ocolib = .F.
xreturnvalue = .F.
ofirstfocus = .F.
maincaption = 
ldatahaschanges = .F.
ckeyname = 
nbar = 0
oldcaption = 
llaunchselectorafterinit = .F.
nnewrecordlevel = 0
lkeeponinserting = .T.
ndeletelevel = 0
laddtowindowsmenu = .F.
ocolkeyfinder = .NULL.
obuttons = .F.
lisactive = .F.
lsaveasscx = .F.
cdataconfigurationkey = 
lonexit = .F.
coldcaption = 
xmloerror = 
corderby = 
nentidadid = 0
nprocesstype = 0
lusetransaction = .T.
ocolcontrols = .NULL.
ocolgrids = .NULL.
ocolbuttons = .NULL.
ocolfiltros = .NULL.
cclassname = 
cclasslibrary = 
oentity = .NULL.
cxmloerror = 
lalreadyrelease = .F.
_memberdata =     8128<VFPData>
	<memberdata name="lalreadyrelease" type="property" display="lAlReadyRelease"/>
	<memberdata name="lisok" type="property" display="lIsOk"/>
	<memberdata name="loldperformautosetup" type="property" display="lOldPerformAutoSetup"/>
	<memberdata name="npaddingtop" type="property" display="nPaddingTop"/>
	<memberdata name="npaddingbottom" type="property" display="nPaddingBottom"/>
	<memberdata name="npaddingleft" type="property" display="nPaddingLeft"/>
	<memberdata name="npaddingright" type="property" display="nPaddingRight"/>
	<memberdata name="hookaftergetone" type="method" display="HookAfterGetOne"/>
	<memberdata name="classbeforegetone" type="method" display="ClassBeforeGetOne"/>
	<memberdata name="hookbeforegetone" type="method" display="HookBeforeGetOne"/>
	<memberdata name="cdataconfigurationkey" type="property" display="cDataConfigurationKey" favorites="True"/>
	<memberdata name="classaftergetone" type="method" display="ClassAfterGetOne"/>
	<memberdata name="closecursors" type="method" display="CloseCursors"/>
	<memberdata name="contextualmenu" type="method" display="ContextualMenu"/>
	<memberdata name="creportall" type="property" display="cReportAll"/>
	<memberdata name="creportone" type="property" display="cReportOne"/>
	<memberdata name="getfirst" type="method" display="GetFirst"/>
	<memberdata name="getlast" type="method" display="GetLast"/>
	<memberdata name="getnext" type="method" display="GetNext"/>
	<memberdata name="getone" type="method" display="GetOne"/>
	<memberdata name="getprior" type="method" display="GetPrior"/>
	<memberdata name="handlebizvalidationerror" type="method" display="HandleBizValidationError"/>
	<memberdata name="classbeforebindcontrols" type="method" display="ClassBeforeBindControls"/>
	<memberdata name="hookbeforebindcontrols" type="method" display="HookBeforeBindControls"/>
	<memberdata name="hookafterbindcontrols" type="method" display="HookAfterBindControls"/>
	<memberdata name="classafterbindcontrols" type="method" display="ClassAfterBindControls"/>
	<memberdata name="classbeforedelete" type="method" display="ClassBeforeDelete"/>
	<memberdata name="nstatus" type="property" display="nStatus"/>
	<memberdata name="nstatus_assign" type="method" display="nStatus_Assign"/>
	<memberdata name="obuttons" type="property" display="oButtons"/>
	<memberdata name="obuttons_access" type="method" display="oButtons_Access"/>
	<memberdata name="ocolib" type="property" display="oColIB"/>
	<memberdata name="ocolkeyfinder" type="property" display="oColKeyFinder"/>
	<memberdata name="ofirstfocus" type="property" display="oFirstFocus"/>
	<memberdata name="setformcaption" type="method" display="SetFormCaption"/>
	<memberdata name="synchronizebuttons" type="method" display="SynchronizeButtons"/>
	<memberdata name="hookbeforesetformcaption" type="method" display="HookBeforeSetFormCaption"/>
	<memberdata name="classbeforesetformcaption" type="method" display="ClassBeforeSetFormCaption"/>
	<memberdata name="readonlycontrols" type="method" display="ReadOnlyControls"/>
	<memberdata name="classbeforereadonlycontrols" type="method" display="ClassBeforeReadOnlyControls"/>
	<memberdata name="hookbeforereadonlycontrols" type="method" display="HookBeforeReadOnlyControls"/>
	<memberdata name="classbeforesynchronizebuttons" type="method" display="ClassBeforeSynchronizeButtons"/>
	<memberdata name="classaftersynchronizebuttons" type="method" display="ClassAfterSynchronizeButtons"/>
	<memberdata name="hookaftersynchronizebuttons" type="method" display="HookAfterSynchronizeButtons"/>
	<memberdata name="hookbeforesynchronizebuttons" type="method" display="HookBeforeSynchronizeButtons"/>
	<memberdata name="ckeyname" type="property" display="cKeyName"/><memberdata name="laddtowindowsmenu" type="property" display="lAddToWindowsMenu"/><memberdata name="ldatahaschanges" type="property" display="lDataHasChanges"/><memberdata name="lexit" type="property" display="lExit"/><memberdata name="lisactive" type="property" display="lIsActive"/><memberdata name="lkeeponinserting" type="property" display="lKeepOnInserting"/><memberdata name="llaunchselectorafterinit" type="property" display="lLaunchSelectorAfterInit"/><memberdata name="lockscreen_assign" type="method" display="LockScreen_Assign"/><memberdata name="lonexit" type="property" display="lOnExit"/><memberdata name="lookovercoltables" type="method" display="LookOverColTables"/><memberdata name="maincaption" type="property" display="MainCaption"/><memberdata name="markvalidationerrors" type="method" display="MarkValidationErrors"/><memberdata name="nbar" type="property" display="nBar"/><memberdata name="ndeletelevel" type="property" display="nDeleteLevel"/><memberdata name="nlevel" type="property" display="nLevel"/><memberdata name="nnewrecordlevel" type="property" display="nNewRecordLevel"/><memberdata name="ocolcombos" type="property" display="oColCombos"/><memberdata name="showerror" type="method" display="ShowError"/><memberdata name="cDataConfigurationKey" type="property" display="cDataConfigurationKey"/><memberdata name="xreturnvalue" type="property" display="xReturnValue"/><memberdata name="xreturnvalue_assign" type="method" display="xReturnValue_Assign"/><memberdata name="fillkeyfinders" type="method" display="FillKeyFinders"/><memberdata name="classbeforegetfirst" type="method" display="ClassBeforeGetFirst"/><memberdata name="classaftergetfirst" type="method" display="ClassAfterGetFirst"/><memberdata name="hookbeforegetfirst" type="method" display="HookBeforeGetFirst"/><memberdata name="hookaftergetfirst" type="method" display="HookAfterGetFirst"/><memberdata name="classbeforegetlast" type="method" display="ClassBeforeGetLast"/><memberdata name="classaftergetlast" type="method" display="ClassAfterGetLast"/><memberdata name="hookbeforegetlast" type="method" display="HookBeforeGetLast"/><memberdata name="hookaftergetlast" type="method" display="HookAfterGetLast"/><memberdata name="classbeforegetnext" type="method" display="ClassBeforeGetNext"/><memberdata name="classaftergetnext" type="method" display="ClassAfterGetNext"/><memberdata name="hookbeforegetnext" type="method" display="HookBeforeGetNext"/><memberdata name="hookaftergetnext" type="method" display="HookAfterGetNext"/><memberdata name="classbeforegetprior" type="method" display="ClassBeforeGetPrior"/><memberdata name="classaftergetprior" type="method" display="ClassAfterGetPrior"/><memberdata name="hookbeforegetprior" type="method" display="HookBeforeGetPrior"/><memberdata name="hookaftergetprior" type="method" display="HookAfterGetPrior"/><memberdata name="cancreate" type="method" display="CanCreate"/><memberdata name="canread" type="method" display="CanRead"/><memberdata name="canupdate" type="method" display="CanUpdate"/><memberdata name="candelete" type="method" display="CanDelete"/><memberdata name="canlist" type="method" display="CanList"/><memberdata name="canexport" type="method" display="CanExport"/><memberdata name="oglobalsettings" type="property" display="oGlobalSettings"/><memberdata name="oglobalsettings_access" type="property" display="oGlobalSettings_Access"/><memberdata name="coldcaption" type="property" display="cOldCaption"/><memberdata name="oentity_access" type="method" display="oEntity_Access"/><memberdata name="recursivesetup" type="method" display="RecursiveSetup"/><memberdata name="xmloerror" type="property" display="XMLoError"/><memberdata name="cxmloerror" type="property" display="cXMLoError"/><memberdata name="corderby" type="property" display="cOrderBy"/><memberdata name="subscribetocolib" type="method" display="SubscribeToColIB"/><memberdata name="hookaftersetupentity" type="method" display="HookAfterSetupEntity"/><memberdata name="onsubscribe" type="method" display="OnSubscribe"/><memberdata name="nentidadid" type="property" display="nEntidadId"/><memberdata name="fill" type="method" display="Fill"/><memberdata name="nprocesstype" display="nProcessType"/><memberdata name="lusetransaction" display="lUseTransaction"/><memberdata name="enablecontrols" display="EnableControls"/></VFPData>
lperformautosetup = .T.
Name = "mainform"
[END PROPERTIES]
[START PROTECTED]
fillkeyfinders
classaftergetone
classbeforegetone
classbeforebindcontrols
classafterbindcontrols
classbeforesetformcaption
readonlycontrols
classbeforereadonlycontrols
classbeforesynchronizebuttons
classaftersynchronizebuttons
classbeforegetfirst
classaftergetfirst
classbeforegetlast
classaftergetlast
classbeforegetnext
classaftergetnext
classbeforegetprior
classaftergetprior
closecursors
[END PROTECTED]
[START METHODS]
PROCEDURE Activate
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
	With This As MainForm Of FW\Comunes\VCX\prxmainform.VCX
		If .lIsOk
			*!*	loError = This.oError
			*!*	loError.TraceLogin = ''
			*!*	loError.Remark = ''

			If DoDefault()
				* Set DataSession To (This.DataSessionId)
				.lIsActive = .T.
				.SynchronizeButtons( .T. )
				.oGlobalSettings.oApp.oActiveForm = This

			Endif && DoDefault()

			.Refresh()

		Endif && .lIsOk

	Endwith
Catch To oErr
	loError = This.oError
	This.cXMLoError = loError.Process( oErr )

Finally
	This.lIsActive = .T.

	loError = This.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
	loError = Null
Endtry

ENDPROC
PROCEDURE Deactivate
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
	With This As mainform Of FW\Comunes\vcx\prxmainform.vcx
		If DoDefault()
			.lIsActive = .F.
			If !Thisform.lExit
				.SynchronizeButtons( .F. )
			EndIf
			.oGlobalSettings.oApp.oActiveForm = Null
		Endif
	Endwith
Catch To oErr
	loError = This.oError
	Thisform.cXMLoError = loError.Process( oErr )
Finally
	This.lIsActive = .F.
	loError = This.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
	loError = Null

Endtry


ENDPROC
PROCEDURE Destroy
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try

	With This As mainform Of FW\Comunes\vcx\prxmainform.vcx
		If Vartype( .oColIB ) == "O"
			.oColIB.Remove( -1 )
		Endif
		.oColIB = Null

		If Vartype( .oColCombos ) == "O"
			.oColCombos.Remove( -1 )
		Endif
		.oColCombos = Null

		If Vartype( .oColKeyFinder ) == "O"
			.oColKeyFinder.Remove( -1 )
		Endif

		.oColKeyFinder = Null

		* DA 2009-10-22(11:02:48)
		If Vartype( .oColButtons ) == "O"
			.oColButtons.Remove( -1 )
		Endif

		.oColButtons = Null

		.oButtons = Null

		* DA 2009-10-21(11:29:23)
		*!*			If Vartype( .oEntity ) == "O"
		*!*				.oEntity.Destroy()
		*!*			EndIf
		.oEntity = Null

		*!*			If Vartype( .oError ) == "O"
		*!*				.oError.Destroy()
		*!*			EndIf
		.oError = Null

		.oFirstFocus = Null
		.oImageList = Null
		.oColGrids = Null
		.oColFiltros = Null

		If ! .lIschildform
			*!* Assert Empty( Txnlevel() ) Message printf( 'Quedaron %i transacciones abiertas', Txnlevel() )
			Do While ! Empty( Txnlevel() )
				Rollback

			Enddo

		Endif && ! .lIschildform

		If .lAddToWindowsMenu
			.oGlobalSettings.oApp.oColForms.RemoveForm( This )

		Endif && .lAddToWindowsMenu

		.ReleaseObjects()
		.CloseCursors()

	Endwith

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr, .T. )

Finally
	loError = Null

	If ! This.lIschildform
		*LiberarMemoria( .T. )
		Do "Tools\Varios\prg\liberarmemoria.prg" With .T.

	Endif && ! .lIschildform

Endtry

ENDPROC
PROCEDURE Init
* Lparameters txIdEntity As Integer, tlModalWindowType As boolean, toParam As Object
Lparameters toParam As Object

******************
* RR, 20/03/2004 *
* ---------------------------------------------------------------------------------

* El parámetro "txIdEntity" sirve para iniciar el form con los
* datos de la entidad cuyo ID está contenido en "txIdEntity".
* Si txIdEntity se recibe vacío se muestra el form sin datos.
* ---------------------------------------------------------------------------------

* El parámetro "tlModalWindowType" sirve para crear el
* Form como Modal y asi poder llamarlo mediante un comando "DO FORM xForm TO xVar"
* donde la variable "xVar" contendrá el valor del último ID mostrado en el form
* antes de ser cerrado.
* ---------------------------------------------------------------------------------

#INCLUDE "FW\Comunes\Include\Praxis.h"
#INCLUDE "fw\tieradapter\include\ta.h"

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local lnProcessType As Integer
Local lnEntidadId As Integer
Local loEntity As UserTierAdapter Of "FW\TierAdapter\UserTier\UserTierAdapter.prg"
Local loKeyFinder As Object

Try
	With This As MainForm Of \fw\comunes\vcx\prxmainform.vcx
		lnMousePointer = .MousePointer
		.SetAll( 'MousePointer', 11 )

		If Vartype( toParam ) # 'O'
			toParam = Createobject( 'Empty' )

		Endif && Vartype( toParam ) # 'O'

		* DAE 2009-07-10
		.PopulateProperties( toParam )

		If .lIsOk And .Classbeforeinit( toParam )

			If .lIsOk And .Hookbeforeinit( toParam )

				* DAE 2009-11-10(19:58:12)
				If ! IsRunTime()
					Try
						If ! 'buttons.vcx' $ Lower( Set("Classlib") )
							Set Classlib To Buttons.vcx Additive
						Endif && ! 'buttons.vcx' $ Lower( Set("Classlib") )

						This.AddObject( 'debuginfo', 'debuginfo' )
						This.debuginfo.Visible = .T.
						This.debuginfo.Move( 0, 0 )
					Catch To oErr
					Endtry

				Endif && ! IsRunTime()

				* DAE 2009-11-11(15:54:01)
				* Se cambio la responsabilidad al KeyFinder
				*!*	For Each loKeyFinder In This.oColKeyFinder
				*!*		* Agregar los controles al KeyFinder
				*!*		loKeyFinder.AddControls()

				*!*	Endfor

				Raiseevent( This, 'OnSubscribe' )
				Raiseevent( This, 'OnSubscribeToParent' )

				If .lIsOk And .lPerformAutoSetUp
					.AutoSetUp()

				Endif && .lIsOk And .lPerformAutoSetUp

				loError = .oError
				loError.Ctracelogin = ''
				loError.Cremark = ''

				.cOldCaption = .Caption
				**.nLevel = IfEmpty( .nLevel, 1 )  && Lo lee de This.oEntity (RA Sábado 18 de Julio de 2009 (13:20:08) )
				.BindControls = .F.

				*!* If Empty( .nDeleteLevel )
				*!*		.nDeleteLevel = .nLevel
				*!*	Endif && Empty( .nDeleteLevel )

				If Pemstatus( toParam, 'lModalWindowType', 5 ) ;
						And toParam.lModalWindowType
					.WindowType = 1 && Modal

				Endif && Pemstatus( toParam, 'lModalWindowType', 5 ) And toParam.lModalWindowType

				If Pemstatus( toParam, 'nEntidadId', 5 )
					.nEntidadId = toParam.nEntidadId
					lnEntidadId = toParam.nEntidadId

				Else && Pemstatus( toParam, 'nEntidadId', 5 )
					.nEntidadId = 0
					lnEntidadId = 0

				Endif && Pemstatus( toParam, 'nEntidadId', 5 )

				If Vartype( toParam ) # 'O'
					lnProcessType = 0

				Else && IsEmpty( toParam )
					If Pemstatus( toParam, 'nProcessType', 5 )
						lnProcessType = toParam.nProcessType

					Else
						lnProcessType = 0

					Endif && Pemstatus( toParam, 'nAction', 5 )

				Endif && IsEmpty( toParam )

				loEntity = .oEntity

				Do Case
					Case Inlist( lnProcessType, TR_NEW, TR_UPDATE, TR_QUERY, TR_DELETE )
						Do Case
							Case lnProcessType = TR_NEW
								.New()

							Case lnProcessType = TR_UPDATE And ! Empty( lnEntidadId ) ;
									And ! loEntity.lIsChild
								.nProcessType = TR_UPDATE
								.GetOne( lnEntidadId )
								.Edit()

							Case lnProcessType = TR_UPDATE And ! Empty( lnEntidadId ) ;
									And loEntity.lIsChild
								.nProcessType = TR_UPDATE
								.nStatus = IS_EDITING
								.BindControls = .T.
								.HookAfterEdit()

							Case lnProcessType = TR_QUERY And ! Empty( lnEntidadId ) ;
									And ! loEntity.lIsChild
								.nProcessType = TR_QUERY
								.GetOne( lnEntidadId )

							Case lnProcessType = TR_QUERY And ! Empty( lnEntidadId ) ;
									And loEntity.lIsChild
								.nProcessType = TR_QUERY
								.nStatus = IS_READING
								.BindControls = .T.

							Case lnProcessType = TR_DELETE And ! Empty( lnEntidadId ) ;
									And loEntity.lIsChild
								.nProcessType = TR_DELETE
								.nStatus = IS_EDITING
								.BindControls = .T.

							Otherwise
								.nStatus = IS_IDLE

						Endcase

					Otherwise

						Do Case
							Case ! Empty( lnEntidadId )
								.lIsOk = .GetOne( lnEntidadId )
								* Case Thisform.LaunchSelectorAfterInit

							Case .lLaunchSelectorAfterInit
								.Open()

							Otherwise
								.nStatus = IS_IDLE

						Endcase

				Endcase

				If .lIsOk
					.cKeyName = Sys( 2015 ) + '_' + Transform( Int( Seconds() ) )
					If .lAddToWindowsMenu
						.oGlobalSettings.oApp.oColForms.AddForm( This )

					Endif && .lAddToWindowsMenu

				Endif && .lIsOk

				* Cada vez que se actualice el form, modificar el caption
				Bindevent( This, 'ControlSourceChange', This, 'SetFormCaption' )

				* Cada vez que se actualice el form, actualizar las grillas
				Bindevent( This, 'ControlSourceChange', This, 'Fill' )

				.BorderStyle = .nBorderStyle

				If loEntity.lIsChild
					loEntity.LocatePK( 0, .T. )
				Endif

				.Hookafterinit( toParam )

				.Classafterinit( toParam )
			Endif
		Endif

	Endwith
Catch To oErr
	This.lIsOk = .F.
	loError = This.oError
	This.cXMLoError = loError.Process( oErr, .T. )

Finally
	loError = This.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
	loError = Null
	loEntity = Null
	loKeyFinder = Null

	This.SetAll( 'MousePointer', lnMousePointer )

	If ! This.lIsOk
		This.Destroy()

	Endif && ! This.lIsOk

Endtry

Return This.lIsOk

ENDPROC
PROCEDURE KeyPress
Lparameters nKeyCode As Integer, nShiftAltCtrl As Integer

#INCLUDE "FW\Comunes\Include\Praxis.h"
#INCLUDE "FW\Tieradapter\Include\TA.h"

Local llDodefault As Boolean
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"

Try
	*
	* Debugout  "nKeyCode: " + Transform( nKeyCode ), "nShiftAltCtrl: " + Transform( nShiftAltCtrl )
	With This As MainForm Of "FW\Comunes\vcx\prxmainform.vcx"
		.oError.Ctracelogin = ''
		.oError.Cremark = ''
		Do Case
			Case nShiftAltCtrl = 0
				Do Case
					Case nKeyCode = KEY_F4 And .oButtons.New && F4 - New
						.New()
					Case nKeyCode = KEY_F3 And .oButtons.Open && F3 - Open
						.Open()
						* DAE 2009-06-29 (14:22:41)
						* Case nKeyCode = KEY_F6 And .oButtons.Recall	&& F6 - Recall
						*    .FastEdition()
					Case nKeyCode = KEY_F5 And .oButtons.Save && F5 - Save
						.Save()
						* DAE 2009-06-29 (14:23:14)
						* Case nKeyCode = KEY_F7  And .oButtons.Cancel && F7 - Cancel
					Case nKeyCode = KEY_F7  And .oButtons.Close && F7 - Close
						.Cancel()
					Case nKeyCode = KEY_F11 And .oButtons.Report && F11 - Print
						.toPrint()
					Case nKeyCode = KEY_F12 And .oButtons.Report && F12 - Preview
						.toPrint( PR_PREVIEW )
						* DAE 2009-06-29 (14:26:18)
						* Case nKeyCode = KEY_ESCAPE And .oButtons.Cancel	&& Escape - Close
					Case nKeyCode = KEY_ESCAPE And .oButtons.Close	&& Escape - Close
						.Close()
					Otherwise
						llDodefault = .T.
				Endcase
			Case nShiftAltCtrl = KEY_SHIFT_DOWN
				Do Case
					Case nKeyCode = 93 && Tecla menu contextual
						*!* This.ContextualMenu( "MainMenu", Int(Srows()/2), Int(Scols()/2) )
						.ContextualMenu( 'MainMenu', Srows(), Int( Scols()/2 ) )
					Otherwise
						llDodefault = .T.
				Endcase
			Case nShiftAltCtrl = KEY_CTRL_DOWN
				Do Case
						* Case nKeyCode = KEY_FLECHA_ARRIBA
					Case nKeyCode = 141
						.Enlarge()
						* Case nKeyCode = KEY_FLECHA_ABAJO
					Case nKeyCode = 145
						.Shrink()
						*Case nKeyCode = KEY_F10
					Case nKeyCode = 103
						Set
						* Case nKeyCode = "D"
					Case nKeyCode = 4
						Debug
					Otherwise
						llDodefault = .T.
				Endcase
			Otherwise
				llDodefault = .T.
		Endcase
	Endwith
	If llDodefault
		DoDefault( nKeyCode, nShiftAltCtrl )
	Endif
Catch To oErr
	This.lIsOk = .F.
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr, .T. )
Finally
	loError = Null
Endtry

ENDPROC
PROCEDURE Load

If DoDefault()
	With This As mainform Of fw\comunes\vcx\prxmainform.vcx
		Set NullDisplay To ''
		Set Multilocks On
		Set Point To '.'
		Set Separator To '.'
		Set ReportBehavior 90

		*!*	.oColIB = Createobject( 'Collection' )
		*!*	.oColCombos  = Createobject( 'Collection' )
		*!*	.oColKeyFinder = Createobject( 'Collection' )

		.oColIB = Newobject( 'prxcollection', 'prxbaselibrary.prg' )
		.oColCombos  = Newobject( 'prxcollection', 'prxbaselibrary.prg' )
		.oColKeyFinder = Newobject( 'prxcollection', 'prxbaselibrary.prg' )
		.oColButtons = Newobject( "prxCollection", "prxBaseLibrary.prg" )
		
		If Empty( .cDataConfigurationKey )
			.cDataConfigurationKey = .Name

		Endif && Empty( .cDataConfigurationKey )

		.cDataConfigurationKey = Upper( Alltrim( .cDataConfigurationKey ) )

		.FontSize = .FontSize + Thisform.oGlobalSettings.oApp.nUpdateFontSize

		* .BorderStyle = 3
		.BorderStyle = 0
		
*!*			If .f.
*!*				Do UsertierAdapter.prg

*!*			EndIf

	Endwith

Else
	Return .F.

Endif && DoDefault()

ENDPROC
PROCEDURE MouseDown
Lparameters nButton, nShift, nXCoord, nYCoord

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try

    Do Case
        Case nButton = 2 And nShift = 0
            This.ContextualMenu( 'MainMenu', Mrow(), Mcol() )
        Otherwise
            DoDefault( nButton, nShift, nXCoord, nYCoord )
    Endcase
Catch To oErr
    This.lIsOk = .F.
    loError = This.oError
    This.cXMLoError = loError.Process( oErr )
Finally
    loError = Null
Endtry

ENDPROC
PROCEDURE QueryUnload

With This as mainform OF FW\Comunes\vcx\prxmainform.vcx
    If .nStatus = IS_IDLE Or .oGlobalSettings.oApp.lForcedExit Or .Close()
        * Everything ok
        DoDefault()
    Else
        * Aborted
        Nodefault
    Endif
Endwith

ENDPROC
PROCEDURE Unload
Return ( This.xReturnValue )
ENDPROC
PROCEDURE bindcontrols_assign
Lparameters vNewVal As Boolean

#INCLUDE "FW\TierAdapter\Include\TA.h"

Local llOk As Boolean
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local lnResult As Integer

Try
	With This As MainForm Of FW\Comunes\VCX\prxmainform.VCX

		lnResult = .oEntity.nResultStatus

		llOk = .T.
		If m.vNewVal And lnResult = RESULT_OK
			llOk = .ClassBeforeBindControls()
			llOk = llOk And .HookBeforeBindControls()

		Endif && m.vNewVal And lnResult = RESULT_OK

		If llOk
			.BindControls = m.vNewVal

			If m.vNewVal And lnResult = RESULT_OK
				.HookAfterBindControls()
				.ClassAfterBindControls()
				.ControlSourceChange()

			Endif && m.vNewVal And lnResult = RESULT_OK

		Endif && llOk

	Endwith

Catch To oErr
	loError = This.oError
	This.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = This.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
	loError = Null

Endtry

ENDPROC
PROCEDURE cancreate
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local llOk As Boolean
Try
	llOk = This.oGlobalSettings.oUser.CanCreate( This.Name )

Catch To oErr
	loError = This.oError
	This.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = This.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
	loError = Null

Endtry

Return llOk

ENDPROC
PROCEDURE candelete
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local llOk As Boolean
Try
    llOk = This.oGlobalSettings.oUser.CanDelete( This.Name )
Catch To oErr
    loError = This.oError
    This.cXMLoError = loError.Process( oErr )
    Throw loError
Finally
  	loError = This.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
	loError = Null
	
Endtry

Return llOk
ENDPROC
PROCEDURE canexport

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local llOk As Boolean
Try
    llOk = This.oGlobalSettings.oUser.CanExport( This.Name )

Catch To oErr
    loError = This.oError
    This.cXMLoError = loError.Process( oErr )
    Throw loError

Finally
   	loError = This.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
	loError = Null
	
Endtry

Return llOk
ENDPROC
PROCEDURE canlist

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local llOk As Boolean
Try
    llOk = This.oGlobalSettings.oUser.CanList( This.Name )

Catch To oErr
    loError = This.oError
    This.cXMLoError = loError.Process( oErr )
    Throw loError

Finally
   	loError = This.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
	loError = Null
	
Endtry

Return llOk
ENDPROC
PROCEDURE canread

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local llOk As Boolean
Try
    llOk = This.oGlobalSettings.oUser.CanRead( This.Name )

Catch To oErr
    loError = This.oError
    This.cXMLoError = loError.Process( oErr )
    Throw loError

Finally
   	loError = This.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
	loError = Null
	
Endtry

Return llOk
ENDPROC
PROCEDURE canupdate

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local llOk As Boolean
Try
	llOk = This.oGlobalSettings.oUser.CanUpdate( This.Name )

Catch To oErr
	loError = This.oError
	This.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = This.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
	loError = Null

Endtry

Return llOk

ENDPROC
PROCEDURE cdataconfigurationkey_access

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try

	With This As mainform Of FW\Comunes\vcx\prxmainform.vcx
		If Vartype( .cDataConfigurationKey ) # 'C' Or Empty( .cDataConfigurationKey )
			.cDataConfigurationKey = Substr( .Name, 4 )
		Endif

	Endwith

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = This.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
	loError = Null

Endtry

Return This.cDataConfigurationKey

ENDPROC
PROCEDURE classafterclose
Lparameters llClose As Boolean

#INCLUDE "FW\TierAdapter\Include\TA.h"

Local loEntity As utArchivo Of "FW\TierAdapter\UserTier\utArchivo.prg"

Try

	loEntity = Thisform.oEntity
	If llClose
		If This.nProcessType = TR_NEW ;
		And This.nStatus = IS_IDLE ;
		And !loEntity.lIsChild  ;
		And Thisform.WindowType = 0
			This.GetOne( -1 )
		Endif
	Endif


Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loEntity = Null

Endtry



ENDPROC
PROCEDURE classafteropen
Lparameters toRetVal as Object
ENDPROC
PROCEDURE classaftersave
Lparameters  tnResultStatus As Integer

#INCLUDE "FW\TierAdapter\Include\TA.h"

Try
	If tnResultStatus =  RESULT_OK
		If This.WindowType = 1 And !This.lIsChildform
			This.xReturnValue = This.nEntidadId
			Thisform.Release
		EndIf
	EndIf
	

Catch To oErr
	Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
	loError = ThisForm.oError
	ThisForm.cXMLoError = loError.Process( oErr )
	Throw loError

Finally

EndTry


ENDPROC
PROCEDURE classaftersynchronizebuttons
Lparameters tlActivate
ENDPROC
PROCEDURE classbeforeapply
Return .T.
ENDPROC
PROCEDURE classbeforebindcontrols
#If .F.
	TEXT
        *:Help Documentation
        *:Description:
        Verifica que este asignado el ControlSource de los controles
        *:Project:
        Sistemas Praxis
        *:Autor:
        Damian Eiff
        *:Date:
        Martes 5 de Mayo de 2009
        *:ModiSummary:
        *:Syntax:
        *:Example:
        *:Events:
        *:NameSpace:
		com.praxis.fw.comunes
        *:Keywords:
        *:Parameters:
        *:Remarks:
        *:Returns:
        Boolean .T. Or .F.
        *:Exceptions:
        *:SeeAlso:
		MainForm::BindConlros_Assign
		*:EndHelp
	ENDTEXT
#Endif

#INCLUDE "Fw\Comunes\Include\Praxis.h"

Local lcCursorName As String
Local loTable As oTable Of "FW\Comunes\Prg\colTables.prg"
Local loControl As Object

Local loCombo As Object
Local lcWarning As String
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"

Try
	loError = Newobject( "ErrorHandler", "ErrorhandlerPrg\ErrorHandler.prg" )
	lcWarning = ''
	With This As MainForm Of FW\Comunes\vcx\prxmainform.vcx
		* .oError.TraceLogin = 'Asignando propiedad ControlSource'
		* .oError.Remark = ''
		loError.Ctracelogin = 'Asignando propiedad ControlSource'
		If Vartype( .oEntity ) == "O"
			lcCursorName = .oEntity.cMainCursorName

			*!*				For Each loControl In .oColIb
			*!*					.oError.Remark = 'Control ' + loControl.Name
			*!*					If loControl.lHasControlSource
			*!*						If loControl.Visible And Empty( loControl.Dato.ControlSource ) ;
			*!*								And Empty( loControl.cBelongToPage )
			*!*							If Empty( loControl.cCursorName )
			*!*								loControl.cCursorName = lcCursorName
			*!*							Endif
			*!*							If Empty( loControl.cFieldName )
			*!*								loControl.cFieldName = Substr( loControl.Name, 4 )
			*!*							Endif
			*!*							loControl.Dato.ControlSource = loControl.cCursorName + '.' + loControl.cFieldName
			*!*							Try
			*!*								Evaluate( loControl.Dato.ControlSource )
			*!*							Catch To oErr
			*!*								lcWarning = lcWarning + 'No existe ' + loControl.Dato.ControlSource + Cr
			*!*								loControl.Dato.ControlSource = ''
			*!*							Finally
			*!*							Endtry
			*!*						Endif
			*!*					Endif
			*!*				Endfor

			For Each loControl In .oColIb
				* .oError.Remark = 'Control ' + loControl.Name
				loError.Cremark = 'Control ' + loControl.Name
				If loControl.lHasControlSource
					If loControl.Visible And Empty( loControl.ControlSource ) ;
							And Empty( loControl.cBelongToPage )
						If Empty( loControl.cCursorName )
							loControl.cCursorName = lcCursorName
						Endif
						If Empty( loControl.cFieldName )
							loControl.cFieldName = Substr( loControl.Name, 4 )
						Endif
						loControl.ControlSource = loControl.cCursorName + '.' + loControl.cFieldName
						Try
							Evaluate( loControl.ControlSource )
						Catch To oErr
							lcWarning = lcWarning + 'No existe ' + loControl.ControlSource + Cr
							loControl.ControlSource = ''
						Finally
						Endtry
					Endif
				Endif
			Endfor


			For Each loControl In .oColKeyFinder
				loError.Cremark = 'Control ' + loControl.Name
				* If loControl.lHasControlSource
					If loControl.Visible And Empty( loControl.ControlSource ) And Empty( loControl.cBelongToPage )
						If Empty( loControl.cCursorName )
							loControl.cCursorName = lcCursorName
						Endif && Empty( loControl.cCursorName )
						If Empty( loControl.cFieldName )
							loControl.cFieldName = Substr( loControl.Name, 4 )
						Endif && Empty( loControl.cFieldName )
						loControl.ControlSource = loControl.cCursorName + '.' + loControl.cFieldName
						Try
							Evaluate( loControl.ControlSource )
						Catch To oErr
							lcWarning = lcWarning + 'No existe ' + loControl.ControlSource + Cr
							loControl.ControlSource = ''
						Finally
						Endtry
					Endif && loControl.Visible And Empty( loControl.ControlSource ) And Empty( loControl.cBelongToPage )
				* Endif && loControl.lHasControlSource
			Endfor


			* Muestro todos los errores
			If ! Empty( lcWarning )
				Warning( lcWarning )
			Endif && ! Empty( lcWarning )
			For Each loCombo In .oColCombos
				If loCombo.Visible And Empty( loCombo.cBelongToPage )
					loCombo.PopulateCombo()

				Endif && loCombo.Visible And Empty( loCombo.cBelongToPage )
			Endfor
			*!*	.oError.TraceLogin = ''
			*!*	.oError.Remark = ''
		Endif

	Endwith

Catch To oErr
	*!*	loError = This.oError
	*!*	This.cXMLoError = loError.Process( oErr )
	If Vartype( loError ) # 'O'
		loError = Newobject( "ErrorHandler", "ErrorhandlerPrg\ErrorHandler.prg" )
	Endif && Vartype( loError ) # 'O'
	loError.Process( oErr )
	Throw loError

Finally
	loError = Null
	loCombo = Null
	loControl = Null
	loError = Null

Endtry

ENDPROC
PROCEDURE classbeforedelete
#If .F.
    TEXT
        *:Help Documentation
        *:Description:
        Abstract method
        *:Project:
        Sistemas Praxis
        *:Autor:
        Damian Eiff
        *:Date:
        Martes 5 de Mayo de 2009
        *:ModiSummary:
        *:Syntax:
        *:Example:
        *:Events:
        *:NameSpace:
		com.praxis.fw.comunes
        *:Keywords:
        *:Parameters:
        *:Remarks:
        *:Returns:
        Boolean .T. Or .F.
        *:Exceptions:
        *:SeeAlso:
		MainForm::Delete
		*:EndHelp
    ENDTEXT
#Endif

Return .T.


ENDPROC
PROCEDURE classbeforeedit
Return .T.
ENDPROC
PROCEDURE classbeforeexport
Return .T.
ENDPROC
PROCEDURE classbeforegetfirst
Lparameters tcFieldName As String, tcFilterCriteria As String, tnLevel As Integer

Return .T.

ENDPROC
PROCEDURE classbeforegetlast
Lparameters tcFieldName As String, tcFilterCriteria As String, tnLevel As Integer

Return .T.

ENDPROC
PROCEDURE classbeforegetnext
Lparameters tcFieldName As String, tuCurrentValue As Variant, tcFilterCriteria As String, tnLevel As Integer

Return .T.

ENDPROC
PROCEDURE classbeforegetone
Lparameters tnEntidadId As Integer, tlDelayedBinding As Boolean

#If .F.
    Text
        *:Help Documentation
        *:Description:
        Abstract method
        *:Project:
        Sistemas Praxis
        *:Autor:
        Damian Eiff
        *:Date:
        Martes 5 de Mayo de 2009
        *:ModiSummary:
        *:Syntax:
        *:Example:
        *:Events:
        *:NameSpace:
		com.praxis.fw.comunes
        *:Keywords:
        *:Parameters:
        *:Remarks:
        *:Returns:
        Boolean .T. Or .F.
        *:Exceptions:
        *:SeeAlso:
		MainForm::GetOne
		*:EndHelp
    EndText
#Endif

Return .T.

ENDPROC
PROCEDURE classbeforegetprior
Lparameters tcFieldName As String, tuCurrentValue As Variant, ;
    tcFilterCriteria As String, tnLevel As Integer

Return .T.

ENDPROC
PROCEDURE classbeforeinit
* Lparameters txIdEntity As Integer, tlModalWindowType As boolean, toParam As Object
Lparameters toParam As Object

#If .F.
    TEXT
        *:Help Documentation
        *:Description:
        Abstract method
        *:Project:
        Sistemas Praxis
        *:Autor:
        Damian Eiff
        *:Date:
        Martes 5 de Mayo de 2009
        *:ModiSummary:
        *:Syntax:
        *:Example:
        *:Events:
        *:NameSpace:
		com.praxis.fw.comunes
        *:Keywords:
        *:Parameters:
        *:Remarks:
        *:Returns:
        Boolean .T. Or .F.
        *:Exceptions:
        *:SeeAlso:
		MainForm::Init
		*:EndHelp
    ENDTEXT
#Endif

Return DoDefault()



ENDPROC
PROCEDURE classbeforenew
Lparameters tlDelayedBinding

Return .T.
ENDPROC
PROCEDURE classbeforeopen
Lparameters toParam As Object @

#If .F.
    TEXT
        *:Help Documentation
        *:Description:
        Abstract method
        *:Project:
        Sistemas Praxis
        *:Autor:
        Damian Eiff
        *:Date:
        Martes 5 de Mayo de 2009
        *:ModiSummary:
        *:Syntax:
        *:Example:
        *:Events:
        *:NameSpace:
		com.praxis.fw.comunes
        *:Keywords:
        *:Parameters:
        *:Remarks:
        *:Returns:
        Boolean .T. Or .F.
        *:Exceptions:
        *:SeeAlso:
		MainForm::Open
		*:EndHelp
    ENDTEXT
#Endif

Return .T.

ENDPROC
PROCEDURE classbeforepreviewreport
Return .T.
ENDPROC
PROCEDURE classbeforereadonlycontrols
Lparameters tlReadOnlyControls As Boolean @

#If .F.
    TEXT
        *:Help Documentation
        *:Description:
        Abstract method
        *:Project:
        Sistemas Praxis
        *:Autor:
        Damian Eiff
        *:Date:
        Martes 5 de Mayo de 2009
        *:ModiSummary:
        *:Syntax:
        *:Example:
        *:Events:
        *:NameSpace:
		com.praxis.fw.comunes
        *:Keywords:
        *:Parameters:
        *:Remarks:
        *:Returns:
        Boolean .T. Or .F.
        *:Exceptions:
        *:SeeAlso:
		MainForm::ReadOnlyControls
		*:EndHelp
    ENDTEXT
#Endif

Return .T.

ENDPROC
PROCEDURE classbeforereleaseobjects
Return .T.
ENDPROC
PROCEDURE classbeforesave
#If .F.
    TEXT
        *:Help Documentation
        *:Description:
        Abstract method
        *:Project:
        Sistemas Praxis
        *:Autor:
        Damian Eiff
        *:Date:
        Martes 5 de Mayo de 2009
        *:ModiSummary:
        *:Syntax:
        *:Example:
        *:Events:
        *:NameSpace:
		com.praxis.fw.comunes
        *:Keywords:
        *:Parameters:
        *:Remarks:
        *:Returns:
        Boolean .T. Or .F.
        *:Exceptions:
        *:SeeAlso:
		MainForm::Save
		MainForm::ClassBeforeSave
		*:EndHelp
    ENDTEXT
#Endif
#INCLUDE "FW\Comunes\Include\Praxis.h"
#INCLUDE "FW\TierAdapter\Include\TA.h"

* Local loObj As Object
Local llOk As Boolean
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"

Try
	With This As MainForm Of "FW\Comunes\vcx\prxmainform.vcx"
		* DAE 2009-08-19(16:51:16) se remplazo por el evento OnResetError
		*!*	For Each loObj In .oColIB
		*!*		Try
		*!*			.oError.Remark = "Control '" + loObj.Name + "'"
		*!*			loObj.lHasValidationRuleError = .F.
		*!*			loObj.cErrorMessage = ""
		*!*			* @TODO Usar los colores con costantes
		*!*			* @TODO Habilitar el TabStop
		*!*			loObj.Dato.BackColor= Rgb( 255, 255, 255 )
		*!*			loObj.Dato.ForeColor = Rgb( 0, 0, 0 )
		*!*		Catch To oErr
		*!*		Finally
		*!*		Endtry
		*!*	Endfor

		If .nProcessType = TR_DELETE
			llOk = Confirm( S_CONFIRMDELETION )

		Else
			llOk = .T.

		Endif
	Endwith
Catch To oErr
	* This.XMLoError = This.oError.Process( oErr )
	loError = This.oError
	loError.cXMLoError = loError.Process( oErr )
	Throw loError
	
Finally
	* loObj = Null
	loError = Null
	
Endtry

Return llOk

ENDPROC
PROCEDURE classbeforesetformcaption
Lparameters tcCaption as String

#If .F.
    Text
        *:Help Documentation
        *:Description:
		Permite personalizar el Caption del form
		Es llamado por This.SetFormCaption
        *:Project:
        Sistemas Praxis
        *:Autor:
        Damian Eiff
        *:Date:
        Martes 5 de Mayo de 2009
        *:ModiSummary:
        *:Syntax:
        *:Example:
        *:Events:
        *:NameSpace:
		com.praxis.fw.comunes
        *:Keywords:
        *:Parameters:
        *:Remarks:
        *:Returns:
        String
        *:Exceptions:
        *:SeeAlso:
		MainForm::SetFormCaption
		MainForm::HookBeforeSetFormCaption
		*:EndHelp
    EndText
#Endif

If Empty( tcCaption )
	tcCaption = ""
EndIf
Return tcCaption
ENDPROC
PROCEDURE classbeforesynchronizebuttons
Lparameters tlActivate
Return .T.
ENDPROC
PROCEDURE classbeforetoprint
Return .T.
ENDPROC
PROCEDURE close
Lparameters tlForceClose As Boolean

#INCLUDE "FW\TierAdapter\Include\TA.h"
#INCLUDE "FW\Comunes\Include\Strings.h"

Local llClose As Boolean
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local loEntity As Object
Try
    llClose = .F.
    With This As MainForm Of fw\comunes\vcx\prxmainform.vcx
        lnMousePointer = .MousePointer
        If .ClassBeforeClose( tlForceClose )
            If .HookBeforeClose( tlForceClose )
                .SetAll( 'MousePointer', 11 )
                loEntity = .oEntity
                .lIsOk = .T.
                If Inlist( .nStatus, IS_IDLE, IS_READING )
                    .lExit = .T.
                    .Release()

                Else
                    .lDataHasChanges = loEntity.DataHasChanges()
                    *!* llClose = ( ! .lDataHasChanges ) Or Confirm( S_DISCARDCHANGES, .Caption )
                    * DAE 2009-10-09(13:46:33)
                    If .lDataHasChanges And ! tlForceClose
                        llClose = Confirm( S_DISCARDCHANGES, .Caption )

                    Else
                        llClose = .T.

                    Endif

                    If ! llClose And .oGlobalSettings.oApp.lForcedExit
                        * @TODO Consultar si se puede cancelar la salida forzada
                        *       y mostrar una advertencia al usuario
                        llClose = .T.

                    Endif && ! llClose And .oGlobalSettings.oApp.lForcedExit

                    If llClose
                        * DAE 2009-09-11(13:41:44)
                        * Da error si estoy en un formulario padre cuando creo un registro nuevo
                        * Cancelo y vuelvo a crear uno nuevo dae el error en los controles IBCombo.
                        * .lExit = .T.

                        * Elimino las modificaciones
                        If ! .lIsChildForm
                            If This.lUseTransaction
                                * DAE 2009-07-27
                                * Active las transcciones nuevamente
                                loEntity.TransactionRollBack()

                            Endif && This.lUseTransaction

                            * DA 2009-11-06(10:35:33)
                            * Si es un ChildForm no necesito actualizar el estado del formulario.
                            Do Case
                                Case Inlist( .nProcessType, TR_UPDATE, TR_DELETE, TR_QUERY )
                                    .nStatus = IS_READING

                                Otherwise
                                    .nStatus = IS_IDLE
                                    * DAE 2009-08-11(14:59:18)
                                    * Reinicio nEntidadId sino queda
                                    * modificar habilitado
                                    loEntity.nEntidadId = 0

                            Endcase

                        Endif && ! .lIsChildForm

                        .BindControls = .F.
                        If .lIsChildForm Or ( .WindowType == 1 )
                            .lExit = .T.
                            .Release()

                        Else
                            .OnResetError()

                            * DAE 2009-08-11(15:03:24)
                            * Fuerzo actualizar los botones
                            .Activate()

                        Endif && .WindowType = 1

                    Else
                        .lExit = .F.
                        .oGlobalSettings.oApp.lExit = .F.
                        .Refresh()

                    Endif && llClose

                Endif && Inlist( .nStatus, IS_IDLE, IS_READING )

                .HookAfterClose( llClose )
                .ClassAfterClose( llClose )

            Endif && .HookBeforeClose( tlForceClose )

        Endif && .ClassBeforeClose( tlForceClose )

    Endwith
Catch To oErr
    loError = This.oError
    This.cXMLoError = loError.Process( oErr, .T. )

Finally
    loError = This.oError
    loError.Ctracelogin = ''
    loError.Cremark = ''
    loError = Null

    loEntity = Null

    This.SetAll( 'MousePointer', lnMousePointer )

Endtry

Return This.lExit

ENDPROC
PROCEDURE closecursors

Local lniCount As Integer
Local lcTable As String
Local Array laTables[1]
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try

	With This As mainform Of FW\Comunes\vcx\prxmainform.vcx
	lnMousePointer = .MousePointer
		.SetAll( 'MousePointer', 11 )
		If ! .lIschildform
			For lniCount = 1 To Aused( laTables )
				lcTable = laTables[ lniCount, 1 ]
				Use In Select( lcTable )

			Next

		Endif && ! .lIschildform
	Endwith

Catch To oErr
	loError = This.oError
	This.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = This.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
	loError = Null

	This.SetAll( 'MousePointer', lnMousePointer )

Endtry

ENDPROC
PROCEDURE contextualmenu
Lparameters tcMenuName As String, tnMrow As Integer, tnMcol As String


#INCLUDE "FW\Tieradapter\Include\TA.h"

#Define BAR_NEW 4
#Define BAR_OPEN 3
#Define BAR_RECALL 6
#Define BAR_SAVE 5
#Define BAR_DELETE 2
#Define BAR_CANCEL 7
#Define BAR_PRINT 11
#Define BAR_PREVIEW 12
#Define BAR_EXPORT 13

Local lnSelected As Integer
Local lcMessage As String
Local llIdle As Boolean
Local llEditing As Boolean
Local llCantRecall As Boolean
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local loGlobalSettings As Object
Try
    With This As mainform Of FW\Comunes\vcx\prxmainform.vcx
        loGlobalSettings = .oGlobalSettings
        Do Case
            Case Lower( tcMenuName ) = "mainmenu"
                lnSelected = 0
                llIdle = ( .nStatus == IS_IDLE )
                llEditing = ( .nStatus == IS_EDITING )
                * llCantRecall = Empty( .IdEntidad ) Or ! llIdle
                llCantRecall = Empty( .nEntidadId ) Or ! llIdle

                Define Popup emergente SHORTCUT Relative From tnMrow, tnMcol

                Define Bar BAR_NEW Of emergente Prompt "Nuevo" ;
                    KEY F4, "F4" ;
                    PICTRES _Mfi_new ;
                    MESSAGE "Crea un nuevo elemento" ;
                    SKIP For !( loGlobalSettings.oApp.oButtons.New )

                Define Bar BAR_OPEN Of emergente Prompt "Abrir" ;
                    KEY F3, "F3" ;
                    PICTRES _Mfi_open ;
                    MESSAGE "Abre un elemento existente" ;
                    SKIP For !( loGlobalSettings.oApp.oButtons.Open )

                *!* Define Bar BAR_RECALL Of emergente Prompt "Recuperar" ;
                *!* KEY F6, "F6" ;
                *!* PICTURE "FW\Comunes\image\bmp\Redo.bmp" ;
                *!* MESSAGE "Recupera el último elemento seleccionado" ;
                *!* SKIP For !( loGlobalSettings.oApp.oButtons.Recall )

                * DA 2009-10-22(10:51:32)

                Do Case
                    Case Thisform.nProcessType = TR_DELETE
                        Define Bar BAR_SAVE Of emergente Prompt "Confirma" ;
                            KEY F5, "F5" ;
                            PICTURE "FW\Comunes\image\bmp\ok.bmp" ;
                            MESSAGE "Confirma la eliminación del elemento actual" ;
                            SKIP For !( loGlobalSettings.oApp.oButtons.Save )
                    Case Thisform.lIsChildForm
                        Define Bar BAR_SAVE Of emergente Prompt "Aplicar" ;
                            KEY F5, "F5" ;
                            PICTURE "FW\Comunes\image\bmp\ok.bmp" ;
                            MESSAGE "Graba el elemento actual" ;
                            SKIP For !( loGlobalSettings.oApp.oButtons.Save )
                    Otherwise
                        Define Bar BAR_SAVE Of emergente Prompt "Grabar" ;
                            KEY F5, "F5" ;
                            PICTRES _Mfi_save ;
                            MESSAGE "Graba el elemento actual" ;
                            SKIP For !( loGlobalSettings.oApp.oButtons.Save )

                Endcase

                Define Bar BAR_DELETE Of emergente Prompt "Eliminar" ;
                    PICTURE "FW\Comunes\image\bmp\delete.bmp" ;
                    MESSAGE "Elimina el elemento actual" ;
                    SKIP For !( loGlobalSettings.oApp.oButtons.Delete )

                Define Bar BAR_CANCEL Of emergente Prompt "Cerrar" ;
                    KEY F7, "F7" ;
                    PICTURE "FW\Comunes\image\bmp\Close.bmp" ;
                    MESSAGE "Cierra el elemento actua" ;
                    SKIP For ! ( loGlobalSettings.oApp.oButtons.Close )

                *!* Define Bar 51 Of emergente Prompt "\-"
                *!* If llEditing
                *!*		lcMessage = "Imprime el elemento actual"
                *!* Else
                *!*		lcMessage = "Imprime todos los elementos de la tabla"
                *!* Endif

                *!* Define Bar BAR_PRINT Of emergente Prompt "Imprimir" ;
                *!*		KEY F11, "F11" ;
                *!*		PICTRES _mfi_sysprint ;
                *!*		MESSAGE "Imprime el elemento actual" ;
                *!*		SKIP For !( loGlobalSettings.oApp.oButtons.Print )
                *!* If llEditing
                *!*		lcMessage = "Previsualiza el elemento actual"
                *!* Else
                *!*		lcMessage = "Previsualiza todos los elementos de la tabla"
                *!* Endif
                *!* Define Bar BAR_PREVIEW Of emergente Prompt "Vista Previa" ;
                *!*		KEY F12, "F12" ;
                *!* 	PICTRES _Mfi_prevu ;
                *!*		MESSAGE "Previsualiza el elemento actual" ;
                *!*		SKIP For !( loGlobalSettings.oApp.oButtons.Preview )
                *!* If llEditing
                *!*		lcMessage = "Exporta el elemento actual"
                *!* Else
                *!*		lcMessage = "Exporta todos los elementos de la tabla"
                *!* Endif

                *!* Define Bar BAR_EXPORT Of emergente Prompt "Exportar" ;
                *!*		PICTURE "fw\actual\comun\image\bmp\Export.bmp" ;
                *!*		MESSAGE "Exporta el elemento actual" ;
                *!*		SKIP For !( loGlobalSettings.oApp.oButtons.Export )

                On Selection Bar BAR_NEW Of emergente lnSelected = BAR_NEW
                On Selection Bar BAR_OPEN Of emergente lnSelected = BAR_OPEN
                * On Selection Bar BAR_RECALL Of emergente lnSelected = BAR_RECALL
                On Selection Bar BAR_SAVE Of emergente lnSelected = BAR_SAVE
                On Selection Bar BAR_DELETE Of emergente lnSelected = BAR_DELETE
                On Selection Bar BAR_CANCEL Of emergente lnSelected = BAR_CANCEL
                *!* On Selection Bar BAR_PRINT Of emergente lnSelected = BAR_PRINT
                *!* On Selection Bar BAR_PREVIEW Of emergente lnSelected = BAR_PREVIEW
                *!* On Selection Bar BAR_EXPORT Of emergente lnSelected = BAR_EXPORT

                Activate Popup emergente
                Release Popups emergente

                If ! Empty( lnSelected )
                    Do Case
                        Case lnSelected = BAR_NEW
                            .New()

                        Case lnSelected = BAR_OPEN
                            .Open()

                            *!* Case lnSelected = BAR_RECALL
                            *!* .FastEdition()

                        Case lnSelected = BAR_SAVE
                            .Save()

                        Case lnSelected = BAR_DELETE
                            .Delete()

                        Case lnSelected = BAR_CANCEL
                            .Close()

                        Case lnSelected = BAR_PRINT
                            .ToPrint()

                        Case lnSelected = BAR_PREVIEW
                            .ToPrint( PR_PREVIEW )

                        Case lnSelected = BAR_EXPORT
                            .ToPrint( PR_EXPORT )
                        Otherwise
                    Endcase
                Endif
        Endcase
    Endwith
Catch To oErr
    This.lIsOk = .F.
    loError = This.oError
    This.cXMLoError = loError.Process( oErr )
    Throw loError

Finally
    loError = This.oError
    loError.Ctracelogin = ''
    loError.Cremark = ''
    loError = Null

Endtry

ENDPROC
PROCEDURE delete
#INCLUDE "FW\Comunes\Include\Strings.h"

Local llOk As Boolean
Local lcMainCursor As String
Local lxID As Variant
Local lnOldProcessType As Integer
Local loEntity As UserTierAdapter Of "FW\TierAdapter\UserTier\UserTierAdapter.prg"
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"

Try
	With This As MainForm Of "fw\comunes\vcx\prxmainform.vcx"
		
		lnMousePointer = .MousePointer
		
		loEntity = .oEntity

		* Checks if valid,
		* ask for confirmation,
		* and see if extra delete is succesful
		If .CanDelete()
			If .ClassBeforeDelete()
				If .HookBeforeDelete()
					If Confirm( S_CONFIRMDELETION )

						.SetAll( 'MousePointer', 11 )

						.LockScreen = .T.
						.BindControls = .F.
						* lcMainCursor = loEntity.cMainCursorName
						* lxID = Evaluate( lcMainCursor + "." + loEntity.cMainCursorPK )

						lxID = loEntity.GetValue( loEntity.cMainCursorPK )
						*!* This.LookOverColTables( ThisloEntity.oColTables, "InternalDelete" )

						loEntity.DeleteEntity()

						* Select ( lcMainCursor )
						lnOldProcessType = .nProcessType
						.nProcessType = TR_DELETE
						llOk = Empty( loEntity.Put( lxID, .nProcessType, .cDataConfigurationKey ) )

						If llOk
							.nStatus = IS_IDLE
							loEntity.nEntidadId = 0
							.Activate()

						Else
							.nProcessType = lnOldProcessType

						Endif && llOk

						.LockScreen = .F.
						.BindControls = .T.

					Endif && Confirm( S_CONFIRMDELETION )

					If This.lIsOk
						This.HookAfterDelete()

					Endif &&  This.lIsOk

					If This.lIsOk
						This.ClassAfterDelete()

					Endif &&  This.lIsOk

				Endif && .HookBeforeDelete()

			Endif && .ClassBeforeDelete()

		Else
			Error 'No tiene permisos suficientes para realizar la operación'

		Endif && .CanDelete()

	Endwith

Catch To oErr
	llOk = .F.
	This.cXMLoError = This.oError.Process( oErr, .T. )

Finally
	This.lIsOk = .T.
	This.LockScreen = .F.
	loError = This.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
	loError = Null

	This.lIsOk = .T.
	loEntity.lIsOk = .T.
	loEntity.cXMLoError = ''
	loEntity = Null

	This.SetAll( 'MousePointer', lnMousePointer )

Endtry

Return llOk

ENDPROC
PROCEDURE doreport
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
	With This As mainform Of FW\Comunes\vcx\prxmainform.vcx
		lnMousePointer = .MousePointer
		.SetAll( 'MousePointer', 11 )

		* @TODO Ver como disparar los reportes
		.oEntity.DoReport( Thisform.nStatus )

	Endwith

Catch To oErr
	loError = This.oError
	This.cXMLoError = loError.Process( oErr, .T. )

Finally
	loError = This.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
	loError = Null

	This.SetAll( 'MousePointer', lnMousePointer )

Endtry

ENDPROC
PROCEDURE edit
#INCLUDE "fw\tieradapter\include\ta.h"

Local llOk As Boolean
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local loEntity As UserTierAdapter Of "FW\TierAdapter\UserTier\UserTierAdapter.prg"

Try
    With This As mainform Of FW\Comunes\vcx\prxmainform.vcx
        lnMousePointer = .MousePointer

        loEntity = .oEntity

        If .CanUpdate()
            If This.lIsOk And .ClassBeforeEdit()
                If This.lIsOk And .HookBeforeEdit()
                    If .nEntidadId # 0

                        .SetAll( 'MousePointer', 11 )

                        .nProcessType = TR_UPDATE
                        llOk = loEntity.lIsOk
                        .BindControls = .T.
                        .nStatus = IS_EDITING

                    Else
                        * @TODO Consultar si hay que lanzar el selector
                        *       o disparar un error
                        Error 'Selecione o cree una entidad'

                    Endif && .nEntidadId # 0

                    If This.lIsOk
                        .HookAfterEdit()

                    Endif && This.lIsOk

                    If This.lIsOk
                        .ClassAfterEdit()

                    Endif && This.lIsOk

                Endif && This.lIsOk And .HookBeforeEdit()

            Endif && This.lIsOk And .ClassBeforeEdit()

        Else
            Error 'No tiene permisos suficientes para realizar la operación'
        Endif && .CanUpdate()

    Endwith
Catch To oErr
    If This.lIsOk
        loError = This.oError
        This.cXMLoError = loError.Process( oErr, .T. )

    Else
        This.lIsOk = .T.

    Endif && This.lIsOk

Finally
    loError = This.oError
    loError.Ctracelogin = ''
    loError.Cremark = ''
    loError = Null

    This.lIsOk = .T.
    loEntity.lIsOk = .T.
    loEntity.cXMLoError = ''
    loEntity = Null

    This.SetAll( 'MousePointer', lnMousePointer )

Endtry


ENDPROC
PROCEDURE enablecontrols
Lparameters tlEnable As Boolean

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try

	With This As mainform Of FW\Comunes\vcx\prxmainform.vcx
		* loError = Thisform.oError
		loError = Newobject( "ErrorHandler", "ErrorhandlerPrg\ErrorHandler.prg" )
		If tlEnable
			loError.Ctracelogin = 'Habilitando Controles'

		Else && tlEnable
			loError.Ctracelogin = 'Deshabilitando Controles'

		Endif && tlEnable

		loError.Cremark = ''

		This.SetAll( 'lIsActive', tlEnable )
		For Each loControl In .oColIB
			Try
				loError.Cremark = 'Control ' + loControl.Name

			Catch To oErr
			Endtry
			loControl.Enabled = tlEnable

		Endfor

		If tlEnable And Vartype( .oFirstFocus ) = 'O'
			If Pemstatus( .oFirstFocus, 'SetFocus', 5 )
				Try
					.oFirstFocus.SetFocus()
				Catch To oErr
				Endtry

			Endif && Pemstatus( .oFirstFocus, 'SetFocus', 5 )

		Endif && tlEnable And Vartype( .oFirstFocus ) = 'O'

	Endwith

Catch To oErr
	* DAE 2009-11-10(19:11:13)
	*!*	loError = Thisform.oError
	If Vartype( loError ) # 'O'
		loError = Newobject( "ErrorHandler", "ErrorhandlerPrg\ErrorHandler.prg" )
	Endif
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	*!*	loError = Thisform.oError
	*!*	loError.TraceLogin = ''
	*!*	loError.Remark = ''
	loError = Null

Endtry

ENDPROC
PROCEDURE fillkeyfinders
Local loFinder As Object
Try
	With This As mainform Of FW\Comunes\vcx\prxmainform.vcx
		.oError.Ctracelogin = ''
		.oError.Cremark = ''
		For Each loFinder In .oColKeyFinder
			loFinder.FillControls()
			
		EndFor
		
	EndWith
	
Catch To oErr
	This.lIsOk = .F.
	This.XMLoError = This.oError.Process( oErr )
	
Finally
	loFinder = Null
	
Endtry

ENDPROC
PROCEDURE getfirst
Lparameters toParam As Object

Local loEntity As Object
Local lnLevel As Integer
Local loError As Object
Local lcFieldName As Object
Local lnId as Integer

Try
	If Vartype( toParam ) # 'O'
		toParam = Createobject( 'Empty' )

	Endif && Vartype( toParam ) # 'O'

	With This As MainForm Of FW\Comunes\vcx\prxmainform.vcx
		lnMousePointer = .MousePointer
		If .ClassBeforeGetFirst( @toParam )
			If .HookBeforeGetFirst( @toParam )
				.SetAll( 'MousePointer', 11 )

				loEntity = .oEntity

				If Pemstatus( toParam, 'cFieldName', 5 )
					lcFieldName = toParam.cFieldName

				Endif && Pemstatus( toParam, 'cFieldName', 5 )

				If Empty( lcFieldName )
					Error 'Falta definir el campo de búsqueda'

				Endif && Empty( lcFieldName )

				If Pemstatus( toParam, 'nLevel', 5 )
					lnLevel = toParam.nLevel

				Endif && PemStatus( toParam, 'nLevel', 5 )

				If Empty( lnLevel )
					lnLevel = .nLevel

				Endif && Empty( lnLevel )

				If Pemstatus( toParam, 'cFilterCriteria', 5 )
					lcFilterCriteria = toParam.cFilterCriteria

				Endif && PemStatus( toParam, 'nLevel', 5 )

				If Empty( lcFilterCriteria )
					lcFilterCriteria = ''

				Endif && Empty( lcFilterCriteria )

				.BindControls = .F.

				If .lIsOk
					lnId = loEntity.GetFirst( lcFieldName, lcFilterCriteria, lnLevel )
					If !Empty( lnId )
						This.GetOne( lnId, .T. )
					EndIf

				Endif && .lIsOk

				.BindControls = .T.

				.HookAfterGetFirst()
				.ClassAfterGetFirst()

			Endif && .HookBeforeGetFirst( toParam )

		Endif && .ClassBeforeGetFirst( toParam )

	Endwith

Catch To oErr
	This.lIsOk = .F.
	loError = This.oError
	This.cXMLoError = loError.Process( oErr )

Finally
	loEntity = Null

	loError = This.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''
	loError = Null

	toParam = Null

	This.SetAll( 'MousePointer', lnMousePointer )

Endtry

ENDPROC
PROCEDURE getlast
Lparameters toParam As Object

Local loEntity As Object
Local lnLevel As Integer
Local loError As Object
Local lcFieldName As Object
Local lnId as Integer

Try
	If Vartype( toParam ) # 'O'
		toParam = Createobject( 'Empty' )

	Endif && Vartype( toParam ) # 'O'

	With This As MainForm Of FW\Comunes\vcx\prxmainform.vcx
		lnMousePointer = .MousePointer
		If .ClassBeforeGetLast( @toParam )
			If .HookBeforeGetLast( @toParam )
				.SetAll( 'MousePointer', 11 )
				loEntity = .oEntity

				If Pemstatus( toParam, 'cFieldName', 5 )
					lcFieldName = toParam.cFieldName

				Endif && Pemstatus( toParam, 'cFieldName', 5 )

				If Empty( lcFieldName )
					Error 'Falta definir el campo de búsqueda'

				Endif && Empty( lcFieldName )

				If Pemstatus( toParam, 'nLevel', 5 )
					lnLevel = toParam.nLevel

				Endif && PemStatus( toParam, 'nLevel', 5 )

				If Empty( lnLevel )
					lnLevel = .nLevel

				Endif && Empty( lnLevel )

				If Pemstatus( toParam, 'cFilterCriteria', 5 )
					lcFilterCriteria = toParam.cFilterCriteria

				Endif && PemStatus( toParam, 'nLevel', 5 )

				If Empty( lcFilterCriteria )
					lcFilterCriteria = ''

				Endif && Empty( lcFilterCriteria )

				.BindControls = .F.

				If .lIsOk
					lnId = loEntity.GetLast( lcFieldName, lcFilterCriteria, lnLevel )
					If !Empty( lnId )
						This.GetOne( lnId, .T. )
					EndIf

				Endif && .lIsOk

				.BindControls = .T.

				.HookAfterGetLast()
				.ClassAfterGetLast()

			Endif && .HookBeforeGetLast( toParam )

		Endif && .ClassBeforeGetLast( toParam )

	Endwith

Catch To oErr
	This.lIsOk = .F.
	loError = This.oError
	This.cXMLoError = loError.Process( oErr )

Finally
	loEntity = Null

	loError = This.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''
	loError = Null

	toParam = Null

	This.SetAll( 'MousePointer', lnMousePointer )

Endtry

ENDPROC
PROCEDURE getnext
Lparameters toParam As Object

Local loEntity As UserTierAdapter Of "FW\TierAdapter\UserTier\UserTierAdapter.prg"
Local lnLevel As Integer
Local loError As Object
Local lcFieldName As String
Local loParam As Object
Local llExecAfter As Boolean
Local lvCurrentValue As Variant
Local lnId as Integer

Try
	If Vartype( toParam ) # 'O'
		toParam = Createobject( 'Empty' )

	Endif && Vartype( toParam ) # 'O'

	With This As MainForm Of FW\Comunes\vcx\prxmainform.vcx
		lnMousePointer = .MousePointer
		If .ClassBeforeGetNext( @toParam )
			If .HookBeforeGetNext( @toParam )
				.SetAll( 'MousePointer', 11 )
				loEntity = .oEntity

				If Pemstatus( toParam, 'cFieldName', 5 )
					lcFieldName = toParam.cFieldName

				Endif && Pemstatus( toParam, 'cFieldName', 5 )

				If Empty( lcFieldName )
					Error 'Falta definir el campo de búsqueda'

				Endif && Empty( lcFieldName )

				If Pemstatus( toParam, 'nLevel', 5 )
					lnLevel = toParam.nLevel

				Endif && PemStatus( toParam, 'nLevel', 5 )

				If Empty( lnLevel )
					lnLevel = .nLevel

				Endif && Empty( lnLevel )

				If Pemstatus( toParam, 'cFilterCriteria', 5 )
					lcFilterCriteria = toParam.cFilterCriteria

				Endif && PemStatus( toParam, 'nLevel', 5 )
				If Empty( lcFilterCriteria )
					lcFilterCriteria = ''

				Endif && Empty( lcFilterCriteria )

				If Used( loEntity.cEntityCursor )
					lvCurrentValue = loEntity.GetValue( lcFieldName )
					.BindControls = .F.

					If .lIsOk
						lnId = loEntity.Getnext( lcFieldName, lvCurrentValue, lcFilterCriteria, lnLevel )
						If !Empty( lnId )
							This.GetOne( lnId, .T. )
						EndIf
						
					Endif && .lIsOk

					.BindControls = .T.

					llExecAfter = .T.

				Else
					loParam = Createobject( 'Empty' )
					AddProperty( loParam, 'cFieldName', lcFieldName )
					.GetFirst( loParam )
					llExecAfter = .F.

				Endif && Used( loEntity.cEntityCursor )

				If llExecAfter
					.HookAfterGetNext()
					.ClassAfterGetNext()

				Endif && llExecAfter

			Endif && .HookBeforeGetNext( toParam )

		Endif && .ClassBeforeGetNext( toParam )

	Endwith

Catch To oErr
	This.lIsOk = .F.
	loError = This.oError
	This.cXMLoError = loError.Process( oErr )

Finally
	loEntity = Null

	loError = This.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''
	loError = Null
	loParam = Null
	toParam = Null

	This.SetAll( 'MousePointer', lnMousePointer )

Endtry

ENDPROC
PROCEDURE getone
Lparameters tnEntidadId As Integer, tlDelayedBinding As Boolean

Local llOk As Boolean
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"

#INCLUDE "FW\TierAdapter\Include\TA.h"

Try
	With This As MainForm Of "fw\comunes\vcx\prxmainform.vcx"
			lnMousePointer = .MousePointer
		.lLaunchSelectorAfterInit = .F.
		.BindControls = .F.
		If .lIsOk
			If .ClassBeforeGetOne( tnEntidadId, tlDelayedBinding )
				If .HookBeforeGetOne( tnEntidadId, tlDelayedBinding )
					.SetAll( 'MousePointer', 11 )
					.oEntity.GetOne( tnEntidadId, .nLevel )
					If .lIsOk And .oEntity.lIsOk
						* .nEntidadId = tnEntidadId

						If ! tlDelayedBinding
							.BindControls = .T.

						Endif && ! tlDelayedBinding

*!*							.nStatus = IS_READING && Lo ejecuta el metodo que llama a GetOne()
						.HookAfterGetOne()
						.ClassAfterGetOne()

					Endif

				Endif

			Endif

		Endif

	Endwith

Catch To oErr
	loError = This.oError
	This.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	llOk = This.lIsOk
	This.lIsOk = .T.
	This.SetAll( 'MousePointer', lnMousePointer )
	
Endtry

Return llOk

ENDPROC
PROCEDURE getprior
Lparameters toParam As Object

Local loEntity As UserTierAdapter Of "FW\TierAdapter\UserTier\UserTierAdapter.prg"
Local lnLevel As Integer
Local loError As Object
Local lcFieldName As Object
Local loParam As Object
Local llExecAfter As Boolean
Local lvCurrentValue As Variant
Local lnId as Integer

Try
	If Vartype( toParam ) # 'O'
		toParam = Createobject( 'Empty' )

	Endif && Vartype( toParam ) # 'O'

	With This As MainForm Of FW\Comunes\vcx\prxmainform.vcx
		lnMousePointer = .MousePointer
		If .ClassBeforeGetPrior( @toParam )
			If .HookBeforeGetPrior( @toParam )
				.SetAll( 'MousePointer', 11 )
				loEntity = .oEntity

				If Pemstatus( toParam, 'cFieldName', 5 )
					lcFieldName = toParam.cFieldName

				Endif && Pemstatus( toParam, 'cFieldName', 5 )

				If Empty( lcFieldName )
					Error 'Falta definir el campo de búsqueda'

				Endif && Empty( lcFieldName )

				If Pemstatus( toParam, 'nLevel', 5 )
					lnLevel = toParam.nLevel

				Endif && PemStatus( toParam, 'nLevel', 5 )

				If Empty( lnLevel )
					lnLevel = .nLevel

				Endif && Empty( lnLevel )

				If Pemstatus( toParam, 'cFilterCriteria', 5 )
					lcFilterCriteria = toParam.cFilterCriteria

				Endif && PemStatus( toParam, 'nLevel', 5 )
				If Empty( lcFilterCriteria )
					lcFilterCriteria = ''

				Endif && Empty( lcFilterCriteria )

				If Used( loEntity.cEntityCursor )
					lvCurrentValue = loEntity.GetValue( lcFieldName )
					.BindControls = .F.

					If .lIsOk
						lnId = loEntity.GetPrior( lcFieldName, lvCurrentValue, lcFilterCriteria, lnLevel )
						If !Empty( lnId )
							This.GetOne( lnId, .T. )
						EndIf
						
					Endif && .lIsOk

					.BindControls = .T.

					llExecAfter = .T.

				Else
					loParam = Createobject( 'Empty' )
					AddProperty( loParam, 'cFieldName', lcFieldName )
					.GetFirst( loParam )
					llExecAfter = .F.

				Endif && Used( loEntity.cEntityCursor )

				If llExecAfter
					.HookAfterGetPrior()
					.ClassAfterGetPrior()

				Endif && llExecAfter

			Endif && .HookBeforeGetPrior( toParam )

		Endif && .ClassBeforeGetPrior( toParam )

	Endwith

Catch To oErr
	This.lIsOk = .F.
	loError = This.oError
	This.cXMLoError = loError.Process( oErr )

Finally
	loEntity = Null

	loError = This.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''
	loError = Null
	loParam = Null
	toParam = Null

	This.SetAll( 'MousePointer', lnMousePointer )

Endtry

ENDPROC
PROCEDURE handlebizvalidationerror
Lparameters tcBizValidationError As String

#INCLUDE "FW\Comunes\Include\Praxis.h"

Local lcAlias As String
Local lcStr As String
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
    With This As mainform Of FW\Comunes\vcx\prxmainform.vcx

        lcAlias = ''
        * Obtengo el cursor con errores
        If Empty( .oEntity.GetData( ParseXML( tcBizValidationError ) ) )
            lcAlias = Alias()
            Locate
            lcStr = ""
            Scan
                lcStr = lcStr + Alltrim( ErrorDescription ) + CR
            Endscan
            If ! Empty( lcStr )
                Warning( lcStr )
            Endif
        Endif
    Endwith
Catch To oErr
    loError = This.oError
    This.cXMLoError = loError.Process( oErr )
Finally
    Use In Select(lcAlias)
    loError = Null
Endtry


ENDPROC
PROCEDURE handleevents
Lparameters toCtrl As Object, tuParam As Variant

ENDPROC
PROCEDURE hookafterclose
Lparameters tlClose As Boolean

ENDPROC
PROCEDURE hookafternew
Lparameters tlDelayedBinding

Return .T.
ENDPROC
PROCEDURE hookafteropen
Lparameters toRetVal As Object, tlDelayedBinding As Boolean

Return .T.
ENDPROC
PROCEDURE hookaftersave
Lparameters  tnResultStatus As Integer

ENDPROC
PROCEDURE hookaftersynchronizebuttons
Lparameters tlActivate as Boolean

Return .T.
ENDPROC
PROCEDURE hookbeforeapply
Return .T.
ENDPROC
PROCEDURE hookbeforebindcontrols
Return .T.
ENDPROC
PROCEDURE hookbeforechangesize
Lparameters tnPoints As Integer @
Return .T.
ENDPROC
PROCEDURE hookbeforedelete
Return .T.
ENDPROC
PROCEDURE hookbeforeedit
Return .T.
ENDPROC
PROCEDURE hookbeforeexport
Return .T.
ENDPROC
PROCEDURE hookbeforegetfirst
Lparameters tcFieldName As String, tcFilterCriteria As String, tnLevel As Integer

Return .T.

ENDPROC
PROCEDURE hookbeforegetlast
Lparameters tcFieldName As String, tcFilterCriteria As String, tnLevel As Integer

Return .T.

ENDPROC
PROCEDURE hookbeforegetnext
Lparameters tcFieldName As String, tuCurrentValue As Variant, tcFilterCriteria As String, tnLevel As Integer

Return .T.

ENDPROC
PROCEDURE hookbeforegetone
Lparameters tnEntidadId As Integer, tlDelayedBinding As Boolean


Return .T.

ENDPROC
PROCEDURE hookbeforegetprior
Lparameters tcFieldName As String, ;
	tuCurrentValue As Variant, ;
	tcFilterCriteria As String, ;
	tnLevel As Integer

Return .T.

ENDPROC
PROCEDURE hookbeforeinit
Lparameters toParam As Object
Return .T.
ENDPROC
PROCEDURE hookbeforenew
Lparameters tlDelayedBinding as Boolean

Return .T.
ENDPROC
PROCEDURE hookbeforeopen
Lparameters toParam As Object @

#If .F.
    TEXT
        *:Help Documentation
        *:Description:
        Abstract method
        *:Project:
        Sistemas Praxis
        *:Autor:
        Damian Eiff
        *:Date:
        Martes 5 de Mayo de 2009
        *:ModiSummary:
        *:Syntax:
        *:Example:
        *:Events:
        *:NameSpace:
		com.praxis.fw.comunes
        *:Keywords:
        *:Parameters:
        *:Remarks:
        *:Returns:
        Boolean
        *:Exceptions:
        *:SeeAlso:
		MainForm::Open
		*:EndHelp
    ENDTEXT
#Endif

Return .T.

ENDPROC
PROCEDURE hookbeforepreviewreport
Return .T.
ENDPROC
PROCEDURE hookbeforereadonlycontrols
Lparameters tlReadOnlyControls As Boolean @

#If .F.
    TEXT
        *:Help Documentation
        *:Description:
        Abstract method
        *:Project:
        Sistemas Praxis
        *:Autor:
        Damian Eiff
        *:Date:
        Martes 5 de Mayo de 2009
        *:ModiSummary:
        *:Syntax:
        *:Example:
        *:Events:
        *:NameSpace:
		com.praxis.fw.comunes
        *:Keywords:
        *:Parameters:
        *:Remarks:
        *:Returns:
        Boolean .T. Or .F.
        *:Exceptions:
        *:SeeAlso:
		MainForm::ReadOnlyControls
		*:EndHelp
    ENDTEXT
#Endif

Return .T.

ENDPROC
PROCEDURE hookbeforereleaseobjects
Return .T.
ENDPROC
PROCEDURE hookbeforesave
#If .F.
	TEXT
        *:Help Documentation
        *:Description:
        Abstract method
        *:Project:
        Sistemas Praxis
        *:Autor:
        Damian Eiff
        *:Date:
        Martes 5 de Mayo de 2009
        *:ModiSummary:
        *:Syntax:
        *:Example:
        *:Events:
        *:NameSpace:
		com.praxis.fw.comunes
        *:Keywords:
        *:Parameters:
        *:Remarks:
        *:Returns:
        Boolean .T. Or .F.
        *:Exceptions:
        *:SeeAlso:
		MainForm::Save
		MainForm::ClassBeforeSave
		*:EndHelp
	ENDTEXT
#Endif

Return .T.

ENDPROC
PROCEDURE hookbeforesetformcaption
Lparameters tcCaption as String

#If .F.
    Text
        *:Help Documentation
        *:Description:
		Permite personalizar el Caption del form
		Es llamado por This.SetFormCaption
        *:Project:
        Sistemas Praxis
        *:Autor:
        Damian Eiff
        *:Date:
        Martes 5 de Mayo de 2009
        *:ModiSummary:
        *:Syntax:
        *:Example:
        *:Events:
        *:NameSpace:
		com.praxis.fw.comunes
        *:Keywords:
        *:Parameters:
        *:Remarks:
        *:Returns:
        String
        *:Exceptions:
        *:SeeAlso:
		MainForm::SetFormCaption
		MainForm::ClassBeforeSetFormCaption
		*:EndHelp
    EndText
#Endif

Return tcCaption
ENDPROC
PROCEDURE hookbeforeshrink
Return .T.
ENDPROC
PROCEDURE hookbeforesynchronizebuttons
Lparameters tlActivate as Boolean

Return .T.

ENDPROC
PROCEDURE hookbeforetoprint
Return .T.
ENDPROC
PROCEDURE instanciateentity
Lparameters tcEntityName As String, tcTierLevel As String, tcObjectFactoryFileName As String

#If .F.
	TEXT
			*:Help Documentation
			*:Topic:
			*:Description:
			Devuelve una instancia del objeto
			*:Project:
			Sistemas Praxis
			*:Autor:
			Ricardo Aidelman
			*:Date:
			Viernes 15 de Mayo de 2009 (08:47:03)
			*:ModiSummary:
			Se agrego BindEvents a:
				OnWarning
				OnStop
				OnInform
				OnConfirm
			*:Syntax:
			*:Example:
			*:Events:
			*:NameSpace:
			praxis.com
			*:Keywords:
			*:Implements:
			*:Inherits:
			*:Parameters:
			tcEntityName AS String
			tcTierLevel AS String
			tcObjectFactoryFileName AS String
			*:Remarks:
			Factory Method
			*:Returns:
			Object
			*:Exceptions:
			*:SeeAlso:
			*:EndHelp
	ENDTEXT
#Endif

Local loParam As Object
Local loObjectFactory As ObjectFactory Of "FW\Comunes\Prg\ObjectFactory.prg"
Local loEntity As TierAdapter Of "FW\TierAdapter\Comun\TierAdapter.prg"
Try
	With This As prxform Of FW\Comunes\vcx\prxbase.vcx

		If Empty( tcTierLevel )
			tcTierLevel = 'User'
		Endif
		If Empty( tcObjectFactoryFileName )
			tcObjectFactoryFileName = .cObjectFactoryFileName
		Endif

		If Empty( Thisform.cClassName )
			* Warning( "Falta indicar Thisform.cClassName" )
			Thisform.cClassName = "UserTierAdapter"
		EndIf
		

		If Empty( Thisform.cClassLibrary )
			* Warning( "Falta indicar Thisform.cClassLibrary" )
			Thisform.cClassLibrary = "FW\Tieradapter\UserTier\UserTierAdapter.prg"
		EndIf
		
		loEntity = NewObject( Thisform.cClassName,;
			Thisform.cClassLibrary )

		If Pemstatus( loEntity, 'cObjectFactoryFileName', 5 ) ;
				And Empty( loEntity.cObjectFactoryFileName )
			loEntity.cObjectFactoryFileName = tcObjectFactoryFileName
		Endif

		If Pemstatus( loEntity, 'oUser', 5 )
			loEntity.oUser = .oGlobalSettings.oUser
		Endif

		.SetupEntity( loEntity )

	Endwith
Catch To oErr
	If This.lIsOk
		This.lIsOk = .F.
		This.cXMLoError = This.oError.Process( oErr )
	Endif
Finally
	loParam = Null
	loObjectFactory = Null
	If ! This.lIsOk
		Throw This.oError
	Endif
Endtry

Return loEntity

ENDPROC
PROCEDURE lookovercoltables
*!* Description...: Recorre la colección ejecutando un comando para cada elemento
*!* Date..........: Martes 7 de Febrero de 2006 (14:02:42)
*!* Author........: Ricardo Aidelman


Lparameters toCol As Collection,;
	tcMethod As String,;
	xParam As Variant,;
	tlDescending As Boolean

Local loTable As oTable Of "Comun\Prg\ColTables.prg"
Local i As Integer

Try

	This.oError.Ctracelogin = ''
	This.oError.Cremark = ''

	If Vartype( toCol ) = 'O'

		For i = 1 To toCol.Count

			loTable = toCol.Item( i )

			If tlDescending
				If This.lIsOk
					This.LookOverColTables( loTable.oColTables, ;
						tcMethod,;
						xParam,;
						tlDescending )
				Endif
			Endif

			If This.lIsOk
				This.&tcMethod.(loTable, xParam)
			Endif

			If !tlDescending
				If This.lIsOk
					This.LookOverColTables( loTable.oColTables, ;
						tcMethod,;
						xParam,;
						tlDescending )
				Endif
			Endif

		Endfor
	Endif
Catch To oErr
	Throw oErr
Finally
Endtry


Return This.lIsOk


ENDPROC
PROCEDURE markvalidationerrors
Lparameters tcWarningData As String

#INCLUDE "FW\Comunes\Include\Praxis.h"

Local lcAlias As String
Local lcCsrErr As String
Local lcControlSource As String
Local lcStr As String
Local loObj As Object
Local llMarkedCtrls As Boolean
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local lcWarning As String
Local loEntity As utArchivo Of "FW\TierAdapter\UserTier\utArchivo.prg"
Local lcEntityCursor As String
Local lcCursor As String

Try
	With This As mainform Of FW\Comunes\vcx\prxmainform.vcx

		.OnResetError()

		lcAlias = Alias()

		* Obtengo el cursor con errores
		loEntity = .oEntity
		llIsOk = loEntity.lIsOk
		loEntity.lIsOk = .T.
		If Empty( loEntity.GetData( ParseXML( tcWarningData ) ) )
			lcCsrErr = Alltrim( loEntity.GetProperty( 'cValidationCursorName' ) )
			llMarkedCtrls = .F.

			lcEntityCursor = loEntity.cEntityCursor

			*!*	For Each loObj In .oColIB
			*!*	Locate For Lower( Alltrim( cAlias ) + '.' + Alltrim( cFieldName ) ) = Lower( loObj.Dato.ControlSource )
			*!*	If ! Eof()
			*!*		loObj.ErrorMessage = ErrorDescription
			*!*		loObj.Dato.BackColor = Rgb( 255, 200, 200 )
			*!*		loObj.lHasValidationRuleError = .T.
			*!*		llMarkedCtrls = .T.
			*!*	Endif && ! Eof()
			*!*	Endfor

			Select Alias( lcCsrErr )
			Locate
			lcStr = ""
			Scan
				lcErrorDescription = Evaluate( lcCsrErr + '.ErrorDescription' )
				lcErrorDescription = Alltrim( lcErrorDescription )
				lcStr = lcStr + lcErrorDescription + CR
				lcControl = Evaluate( lcCsrErr + '.cFieldName' )
				lcCursor =   Evaluate( lcCsrErr + '.cAlias' )

				lcKey = Alltrim( lcCursor ) + '.' + Alltrim( lcControl )
				lcKey = Lower( lcKey )
				i = .oColIB.GetKey( lcKey )

				If ! Empty( i )
					loObj = .oColIB.Item( i )
					loObj.ErrorMessage = Alltrim( lcErrorDescription )
					loObj.Dato.BackColor = Rgb( 255, 200, 200 )
					loObj.lHasValidationRuleError = .T.
					llMarkedCtrls = .T.

				Endif && ! Empty( lcKey )

			Endscan

			If ! Empty( lcStr )
				If llMarkedCtrls && = .T.

					* lcStr = lcStr + CR && + lcWarning
					TEXT To lcStr NoShow TextMerge Pretext 1 + 2 ADDITIVE
						Se han encontrado algunos errores de validación

						Presione (Ctrl + Botón Derecho) sobre el control resaltado
						para ver el detalle del error
					ENDTEXT

					*!*	lcWarning = "Se han encontrado algunos errores de validación" + CR + CR
					*!*	lcWarning = lcWarning + "Presione (Ctrl + Botón Derecho) sobre el control resaltado" + CR
					*!*	lcWarning = lcWarning + "para ver el detalle del error"
					* lcStr = lcStr + CR + CR + lcWarning

					.OnMarkValidationErrors()
					
				Endif && llMarkedCtrls = .T.

				Warning( lcStr )

			Endif && ! Empty( lcStr )

		Endif && Empty( loEntity.GetData( ParseXML( tcWarningData ) ) )

		loEntity.lIsOk = llIsOk

	Endwith
Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )

Finally
	If Used( lcCsrErr )
		Use In Alias( lcCsrErr )

	Endif && Used( lcCsrErr )

	loError = Null
	If Used( lcAlias )
		Select Alias( lcAlias )

	Endif && Used( lcAlias )

	loEntity = Null

Endtry


ENDPROC
PROCEDURE nentidadid_access

This.nEntidadId = This.oEntity.nEntidadId
Return This.nEntidadId

ENDPROC
PROCEDURE nentidadid_assign
Lparameters tnEntidadId As Integer

This.nEntidadId = tnEntidadId
This.oEntity.nEntidadId = tnEntidadId

ENDPROC
PROCEDURE new
Lparameters tlDelayedBinding As Boolean

#INCLUDE "fw\tieradapter\include\ta.h"

Local llOk As Boolean
Local loCombo As Object
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local loEntity As Object

Try
	With This As mainform Of FW\Comunes\vcx\prxmainform.vcx
		lnMousePointer = .MousePointer

		loEntity = .oEntity

		If .CanCreate()

			If This.lIsOk And .ClassBeforeNew( tlDelayedBinding )
				If This.lIsOk And .HookBeforeNew( tlDelayedBinding )

					.SetAll( 'MousePointer', 11 )
					.OnResetError()
					.nProcessType = TR_NEW
					.lLaunchSelectorAfterInit = .F.
					.BindControls = .F.
					loEntity.New( .nLevel )
					llOk = loEntity.lIsOk
					If llOk
						If ! tlDelayedBinding
							.BindControls = .T.

						Endif && ! tlDelayedBinding
						.nStatus = IS_EDITING

					Endif && llOk

					For Each loCombo In .oColCombos
						If loCombo.Visible And Empty( loCombo.cBelongToPage )
							If Empty( loCombo.Value )
								loCombo.SetDefault()

							Endif && Empty( loCombo.Value )

						Endif && loCombo.Visible And Empty( loCombo.cBelongToPage )

					Endfor

					If This.lIsOk
						.HookAfterNew( tlDelayedBinding )

					Endif && This.lIsOk

					If This.lIsOk
						.ClassAfterNew( tlDelayedBinding )

					Endif && This.lIsOk

				Endif && This.lIsOk And .HookBeforeNew( tlDelayedBinding )

			Endif && This.lIsOk And .ClassBeforeNew( tlDelayedBinding )

		Else && .CanCreate()
			Error 'No tiene permisos suficientes para realizar la operación'

		Endif && .CanCreate()

	Endwith

Catch To oErr
	loError = This.oError
	This.cXMLoError = loError.Process( oErr, .T. )

Finally
	loCombo = Null
	loError = This.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
	loError = Null

	This.lIsOk = .T.
	loEntity.lIsOk = .T.
	loEntity.cXMLoError = ''
	loEntity = Null

	This.SetAll( 'MousePointer', lnMousePointer )

Endtry


ENDPROC
PROCEDURE nstatus_assign
Lparameters vNewVal As Boolean
#INCLUDE "FW\Tieradapter\Include\TA.h"
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local lnOldStatus As Integer

Try
	With This As MainForm Of "FW\Comunes\Vcx\prxMainForm.vcx"
		loError = This.oError
		loError.Ctracelogin = ''
		loError.Cremark = ''

		lnOldStatus = .nStatus
		.nStatus = m.vNewVal

		.EnableControls( .nStatus = IS_EDITING )

		If Inlist( .nStatus, IS_EDITING, IS_READING )
			*!* .SetFormCaption( .MainCaption )
			.SetFormCaption()

			*!*	If ! .lIsChildForm
			*!*		If This.lUseTransaction
			*!*			* DAE 2009-07-27 Active las transcciones nuevamente
			*!*			.oEntity.TransactionBegin()
			*!*		Endif
			*!*	Endif && ! .lIsChildForm
			
			* DAE 2009-10-05(13:03:20)
			* Si es reading no inicio la transaccion
			If .nStatus = IS_EDITING And ! .lIsChildForm And This.lUseTransaction
				.oEntity.TransactionBegin()

			Endif && .nStatus = IS_EDITING And ! .lIsChildForm And This.lUseTransaction

		Else && .nStatus = IS_EDITING
			.SetFormCaption( .cOldCaption )

		Endif && .nStatus = IS_EDITING

		If .lIsOk

			If Inlist( .nStatus, IS_EDITING, IS_READING )
				* DAE 2009-08-13(16:49:11)
				* @TODO Damian Eiff 2009-08-13 (18:49:10)
				* Si tengo un control tree no me refleja los cambios evaluar
				* la posibilidad de utilizar un flag para parametrizar la llamada al Fill
				*
				* If ! Inlist( lnOldStatus, IS_EDITING, IS_READING )
				.Fill()

				* Endif && Inlist( lnOldStatus, IS_EDITING, IS_READING )

				* DA 2009-07-17(08:51:19)
				* El método Fill quita el foco en el primer control
				If Vartype( .oFirstFocus ) = 'O'
					.oFirstFocus.SetFocus()

				Endif && Vartype( .oFirstFocus ) = 'O'

			Else && InList( .nStatus, IS_EDITING, IS_READING )
				.Empty()

			Endif && InList( .nStatus, IS_EDITING, IS_READING )

			.Refresh()
			.Activate()

		Endif && .lIsOk

	Endwith
Catch To oErr
	loError = This.oError
	This.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = This.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
	loError = Null

Endtry

Return



ENDPROC
PROCEDURE obuttons_access
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
	With This As mainform Of FW\Comunes\vcx\prxmainform.vcx
		If Vartype( .oButtons )#'O' And !Thisform.lExit
			.oButtons = .oGlobalSettings.oApp.oButtons
		Endif
	Endwith
Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError
Finally
	loError = Null
Endtry
Return This.oButtons

ENDPROC
PROCEDURE ocolcontrols_access
If Vartype( This.oColControls ) # "O" And !Thisform.lExit
	This.oColControls = Newobject( "prxCollection", "prxBaseLibrary.prg" )

Endif

Return This.oColControls

ENDPROC
PROCEDURE ocolfiltros_access
If Vartype( This.oColFiltros ) # "O" And !This.lAlReadyRelease
	This.oColFiltros = Newobject( "PrxCollection", "PrxBaseLibrary.prg" )

Endif
Return This.oColFiltros

ENDPROC
PROCEDURE ocolgrids_access
If Vartype( This.oColGrids ) # "O" And !Thisform.lExit
	This.oColGrids = Newobject( "prxCollection", "prxBaseLibrary.prg" )

Endif
Return This.oColGrids

ENDPROC
PROCEDURE oentity_access
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
    With This As mainform Of FW\Comunes\vcx\prxmainform.vcx
        If Vartype( .oEntity ) # 'O' And !Thisform.lExit
            .oEntity = .InstanciateEntity( .cDataConfigurationKey )
            * DAE 2009-09-30(14:31:00)
            .oEntity.SetProperty( 'lIsMainEntity', .T. )
            * .oEntity.lIsMainEntity = .T.
        Endif
    Endwith
Catch To oErr
    loError = This.oError
    This.cXMLoError = loError.Process( oErr )
    Throw loError
Finally
    loError = Null
Endtry

Return This.oEntity

ENDPROCPROCEDURE open
Lparameters tlDelayedBinding

#INCLUDE "FW\Comunes\Include\Praxis.h"
#INCLUDE "FW\TierAdapter\Include\TA.h"
* @TODO Chequear acoplamiento #INCLUDE "Erp\Archivos\Include\Archivos.h"

Local loRetVal As Object
Local loParam As Object
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local llRetVal As Boolean
Local loEntity As UserTierAdapter Of "FW\TierAdapter\UserTier\UserTierAdapter.prg"

Try
	With This As MainForm Of "Fw\Comun\Vcx\prxMainForm.vcx"

		lnMousePointer = .MousePointer

		loEntity = .oEntity

		If .CanRead()

			If loEntity.lCreateIfNotExist
				.SetAll( 'MousePointer', 11 )
				loEntity.CreateIfNotExist()

			Endif && loEntity.lCreateIfNotExist

			loParam = Createobject( 'Empty' )
			AddProperty( loParam, 'cDataConfigurationKey', .cDataConfigurationKey )

			If .ClassBeforeOpen( @loParam )
				If .HookBeforeOpen( @loParam )
					.SetAll( 'MousePointer', 11 )

					loRetVal = LaunchForm( loEntity.GetSelectorFormName(), loParam, .T. )

					If Vartype( loRetVal ) = 'O'
						If Lower( loRetVal.Estado ) = 'ok'
							.OnResetError()
						
							* @TODO Ver si hay que ejecutar el GetOne
							.nProcessType = TR_QUERY
							* @TODO Propiedades del ABMGenericForm utilizar PopulateProperties
							*!*	If Pemstatus( loRetVal, "lFilterByCodigo", 5 )
							*!*	.lOrderByCodigo = loRetVal.lFilterByCodigo
							*!*	Endif
							*!*	If Pemstatus( loRetVal, "lFilterByDescripcion", 5 )
							*!*	.lOrderByDescripcion = loRetVal.lFilterByDescripcion
							*!*	EndIf

							If Pemstatus( loRetVal, 'cOrderBy', 5 )
								.cOrderBy = loRetVal.cOrderBy

							Endif && Pemstatus( loRetVal, 'cOrderBy', 5 )

							llRetVal = .GetOne( loRetVal.Valor, tlDelayedBinding )
							If llRetVal
								.nStatus = IS_READING
								.SynchronizeButtons( .T. )

							Endif

						Endif && Lower( loRetVal.Estado ) = 'ok'

					Endif && Vartype( loRetVal ) = 'O'

					.HookAfterOpen( llRetVal )
					.ClassAfterOpen( llRetVal )

				Endif && .HookBeforeOpen( @loParam )

			Endif && .ClassBeforeOpen( @loParam )

		Else
			Error 'No tiene permisos suficientes para realizar la operación'

		Endif && .CanRead()

	Endwith

Catch To oErr
	loError = This.oError
	This.cXMLoError = loError.Process( oErr, .T. )

Finally
	llRetVal = This.lIsOk
	loError = Null
	loParam = Null

	This.lIsOk = .T.
	loEntity.lIsOk = .T.
	loEntity.cXMLoError = ''
	loEntity = Null

	* DAE 2009-08-13(19:38:16)
	* Fuerzo la actualizacion de los botones
	This.Activate()

	This.SetAll( 'MousePointer', lnMousePointer )

Endtry

Return ( llRetVal )

ENDPROC
PROCEDURE readonlycontrols
Lparameters tlReadOnlyControls As Boolean

Local loObj As Object
Local loCombo As Object
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"

Try
	With This As MainForm Of "FW\Comunes\vcx\prxmainform.vcx"
		loError = This.oError
		loError.Ctracelogin = ''
		loError.Cremark = ''

		If .ClassBeforeReadOnlyControls( @tlReadOnlyControls )
			If .HookBeforeReadOnlyControls( @tlReadOnlyControls )

				For Each loObj In .oColIB
					loError.Cremark = "Control '" + loObj.Name + "'"
					loObj.ReadOnly = tlReadOnlyControls

				Endfor
				For Each loCombo In .oColCombos
					loError.Cremark = "Combo '" + loCombo.Name + "'"
					loCombo.ReadOnly = tlReadOnlyControls

				Endfor

			Endif && .HookBeforeReadOnlyControls( @tlReadOnlyControls )

		Endif && .ClassBeforeReadOnlyControls( @tlReadOnlyControls )
	Endwith
Catch To oErr
	loError = This.oError
	This.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = This.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
	loError = Null
	
	loObj = Null
	loCombo = Null
	
Endtry

ENDPROC
PROCEDURE recursivesetup
Lparameters toCtrl As Object @
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"

Local loObj As Object
Try
    For Each loObj In toCtrl.Objects
        If Pemstatus( loObj, 'Objects', 5 )
            Thisform.RecursiveSetup( loObj )
        Endif
        * BackUp de la propiedad lPerformAutoSetUp
        If Pemstatus( loObj, 'loldPerformAutoSetUp', 5 )
            loObj.lOldPerformAutoSetUp = loObj.lPerformAutoSetUp
        Endif
    Endfor
Catch To oErr
    loError = This.oError
    This.cXMLoError = loError.Process( oErr )
Finally
    loObj = Null
    loError = Null
Endtry

ENDPROC
PROCEDURE releaseobjects
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local loObj As Object
Try
	With This As MainForm Of FW\Comunes\vcx\prxmainform.vcx
		If ! .lAlreadyRelease

			.oColObjects = Null
			
			For Each loObj In .Objects
				If Pemstatus( loObj, 'ReleaseObjects', 5 )
					loObj.ReleaseObjects()
					
				EndIf && Pemstatus( loObj, 'ReleaseObjects', 5 )
				
			EndFor
			
		EndIf && ! .lAlreadyRelease
		
	EndWith
	
Catch To oErr
	loError = This.oError
	This.cXMLoError = loError.Process( oErr )
	Throw loError
	
Finally
	* This.lAlreadyRelease = .T.

	This.oError.Ctracelogin = ''
	This.oError.Cremark = ''

	loError = Null
Endtry

ENDPROC
PROCEDURE save
#INCLUDE "FW\Comunes\Include\Praxis.h"
#INCLUDE "FW\TierAdapter\Include\ta.h"

Local loTable As oTable Of "FW\Comunes\Prg\ColTables.prg"
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local loEntity As UserTierAdapter Of "FW\TierAdapter\UserTier\UserTierAdapter.prg"
*
Local lnResultStatus As Integer
*
Local lcEntityCursor As String
Local lcRetVal As String
*
lnResultStatus = RESULT_ERROR

Try
	With This As MainForm Of "FW\Comunes\Vcx\prxMainForm.vcx"
		lnMousePointer = .MousePointer

		loEntity = .oEntity
		loEntity.nResultStatus = RESULT_OK

		.OnResetError()

		.lOnExit = .T.

		Wait 'Grabando...' Window Nowait

		* En caso de acceder al metodo Save a traves de F5, las siguientes 3
		* líneas impiden que el ActiveControl, al no perder el foco, no
		* sincronice el Value con el ControlSource.
		Try
			*		If PemStatus( This, "ActiveControl", 5 ) And PemStatus( This.ActiveControl, "SetFocus", 5 )
			*	RR, 03/09/2004: Intento con el Try SIN Catch porque para los objetos cuya BaseClass es un
			*                   "Control" controles la clausula del IF daba error.
			.ActiveControl.SetFocus()
			*		EndIf
		Catch
			* Dado que el ActiveControl que generó el error puede ser cualquiera y ademas puede estar
			* en cualquier página en caso de existir un PageFrame, creo un TextBox temporal al que le
			* seteo el foco y luego lo destruyo.
			.AddObject( 'txtDummy', 'TextBox' )
			With This.txtDummy
				.Top = -500
				.Left = -500
				.Height = 1
				.Width = 1
				.Enabled = .T.
				.Visible = .T.
				.SetFocus()
				.SetFocus()
			Endwith
			.RemoveObject( 'txtDummy' )
		Endtry
		* Checks if its valid, and if extra save is succesful
		* If .SaveValid() And .SaveHook()
		If .ClassBeforeSave()
			If .HookBeforeSave()
				.SetAll( 'MousePointer', 11 )
				* RR, 31/01/2004: Los controles están bindeados contra los cursores, cuyos
				* punteros a los registros van a ser modificados al obtener el DiffGram.
				.LockScreen = .T.
				.BindControls = .F.

				* DA 2009-07-24(11:32:56)
				* Guarda la posición del puntero a cada tabla
				loEntity.GetRecno( .T. )

				If .lIsOk And loEntity.lIsOk
					lcEntityCursor = loEntity.cEntityCursor
					Select ( lcEntityCursor )
					Locate
					* lcPKValue = Alltrim( loEntity.cMainCursorName ) + '.' + Alltrim( loEntity.cMainCursorPK )
					* @TODO Verificar si funciona bien
					* Termino las transaccion
					*!* If .WindowType # 1
					* DA 2009-07-14: Si no es un formulario padre, se termina la transacción
					If ! .lIsChildForm
						If This.lUseTransaction
							* DAE 2009-07-27 Active las transcciones nuevamente
							loEntity.TransactionEnd()
						Endif

					Endif && ! .lIsChildForm
					* lcRetVal = loEntity.Put( Evaluate( lcPKValue ), .ProcessType, .cDataConfigurationKey )
					lcRetVal = loEntity.Put( loEntity.GetValue( loEntity.cMainCursorPK ), .nProcessType, .cDataConfigurationKey )
					lnResultStatus = loEntity.nResultStatus

					*!* Assert ! .lIsChildForm And Empty( Txnlevel() ) Message 'Save::Quedo/aron ' + Transform( Txnlevel() ) + ' transacciones abiertas'

				Endif && .lIsOk

				.LockScreen = .F.

				Do Case
					Case lnResultStatus = RESULT_OK

						If .lIsChildForm
							* Fue llamado desde otro formulario
							.lKeepOnInserting = .F.
							* .xReturnValue = .IdEntidad
							.xReturnValue = .T.
							.Release()
						Else

							* DAE 2009-10-07(18:16:21)
							* Error con los KF y los combos porque se corrieron los punteros de las tablas
							* Restaura la posición del puntero de la tabla
							Select ( lcEntityCursor )
							Locate

							* Terminó OK, vuelvo a modo NO EDICION.
							.nStatus = IS_READING
							* DAE 2009-07-28(15:35:21)
							* .nEntidadId = loEntity.GetValue( loEntity.cMainCursorPK )
							= .nEntidadId

							* DAE 2009-08-28(16:55:27)
							.BindControls = .T.

						Endif && .lIsChildForm

					Case lnResultStatus = RESULT_BIZ_ERROR
						* If .WindowType # 1
						If ! .lIsChildForm
							If This.lUseTransaction
								* DAE 2009-07-27 Active las transcciones nuevamente
								loEntity.TransactionBegin()
							Endif

						Endif && .lIsChildForm

						.HandleBizValidationError( loEntity.cXMLoError )
						lnResultStatus = loEntity.nResultStatus

					Otherwise

						* RR, 31/01/2004: Si falla el Put(), dejo el modo de edición como estaba
						* y restauro los punteros a los registros que pudieron ser modificados al
						* obtener el DiffGram.
						If lnResultStatus = RESULT_WARNINGS
							.MarkValidationErrors( loEntity.cXMLoError )

						Endif && lnResultStatus = RESULT_WARNINGS

						* DA 2009-07-24(11:33:34)
						* Restaura la posición del puntero a cada tabla
						loEntity.GetRecno( .F. )

						If ! .lIsChildForm
							If This.lUseTransaction
								* DAE 2009-07-27 Active las transcciones nuevamente
								loEntity.TransactionBegin()
							Endif

						Endif && .lIsChildForm

						.BindControls = .T.

				Endcase

				.HookAfterSave( lnResultStatus )
				.ClassAfterSave( lnResultStatus )

			Endif && .HookBeforeSave()

		Endif && .ClassBeforeSave()

	Endwith

Catch To oErr
	loError = This.oError
	This.cXMLoError = loError.Process( oErr, .T. )

Finally
	With This As MainForm Of "FW\Comunes\Vcx\prxMainForm.vcx"
		.LockScreen = .F.
		.lIsOk = .T.
		If Vartype( loEntity ) == "O"
			loEntity.lIsOk = .T.
			loEntity.cXMLoError = ''

		Endif
		.lOnExit = .F.

		loError = .oError
		loError.Ctracelogin = ''
		loError.Cremark = ''

	Endwith

	loError = Null
	loEntity = Null

	This.SetAll( 'MousePointer', lnMousePointer )

Endtry

With This As MainForm Of "FW\Comunes\Vcx\prxMainForm.vcx"
	* @TODO Ver si es correcto llamar al metodo New desde el metodo Save
	* Si estoy dando de ALTA y el resultado fue OK y tengo el flag lKeepOnInserting
	If .nProcessType = TR_NEW
		If lnResultStatus = RESULT_OK
			If .lKeepOnInserting
				.New()

			Endif && .lKeepOnInserting

		Endif && lnResultStatus = RESULT_OK

	Endif && .ProcessType = TR_NEW

Endwith

*!*	Return lnResultStatus = RESULT_OK
Return lcRetVal

ENDPROC
PROCEDURE setformcaption
Lparameters tcCaption As String
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"

Try
    With This As MainForm Of "FW\Comunes\vcx\prxmainform.vcx"
        tcCaption = .ClassBeforeSetFormCaption( @tcCaption )
        tcCaption = .HookBeforeSetFormCaption( @tcCaption )
        If Empty( tcCaption )
            Try
                * tcCaption = Evaluate( .oEntity.cMainCursorName + ".Descripcion" )
                If .oEntity.lHasDescripcion
                    tcCaption = .oEntity.cDisplayValue + ": " + Alltrim(.oEntity.GetValue( 'Descripcion' ))
                Endif
            Catch To oErr
                * Esto es para automatizar el caption con el valor del campo descripcion
                * Si no existe la tabla o el campo, no hace nada
            Finally
            	* DA 2009-09-10(12:09:13)
            	* Cuando abro un reporte y no encuentra el cursor de la entidad,
            	* tcCaption viene con valor nulo, entonces lo vuelvo a convertir en caracter
                If IsNull( tcCaption )
                    tcCaption = ""

                Endif && IsNull( tcCaption )

            Endtry

        Endif && Empty( tcCaption )

        If ! Empty( tcCaption )
            Assert Vartype( tcCaption ) = 'C' Message 'tcCaption no es caracter'

            .Caption = tcCaption
            .MainCaption = tcCaption
            If .lAddToWindowsMenu
                .oGlobalSettings.oApp.oColForms.RefreshMenu( This )

            Endif && .lAddToWindowsMenu

        Endif && ! Empty( tcCaption )

    Endwith

Catch To oErr
    This.lIsOk = .F.
    loError = This.oError
    This.cXMLoError = loError.Process( oErr, .T. )

Finally
    loError = Null

    This.oError.Ctracelogin = ''
    This.oError.Cremark = ''

Endtry

ENDPROC
PROCEDURE showerror
Lparameters toErr as ErrorHandler of "Tools\ErrorHandler\Prg\ErrorHandler.prg"

If IsDebugMode()
	toErr.ShowError()	
Else
	Warning( toErr.ErrorDescrip )	
	
Endif


ENDPROC
PROCEDURE subscribetocolgrid
Lparameters toControl As ABMChildGrid OF FW\Comunes\vcx\prxmainform.vcx

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local i As Integer
Local lcKey As String
Local loColGrid As PrxCollection Of "Fw\TierAdapter\Comun\PrxBaseLibrary.prg"
Try
	With This As mainform Of Fw\Comunes\Vcx\prxmainform.Vcx
		* Subscribir el Control a la Colección
		lcKey = Lower( toControl.cKeyName )
		loColGrid = .oColGrids
		i = loColGrid.GetKey( lcKey )

		If Empty( i )
			loColGrid.Add( toControl, lcKey )

		Endif && Empty( i )

	Endwith

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = This.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
	loError = Null
	loColGrid = Null

Endtry

ENDPROC
PROCEDURE subscribetocolib
Lparameters toControl As ibContainer Of Fw\Comunes\Vcx\InputBoxes.Vcx

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local i As Integer
Local loDD As Collection
Local loEntity As utArchivo Of "FW\Tieradapter\UserTier\utArchivo.prg"
Local loField As oField Of "Tools\Sincronizador\ColDataBases.prg"
Local lcKey As String

Try


	If .F.



		With This As mainform Of Fw\Comunes\Vcx\prxmainform.Vcx
			loEntity = .oEntity

			* Subscribir el Control a la Colección
			lcKey = Lower( toControl.cKeyName )
			i = .oColIB.GetKey( lcKey )

			If Empty( i )
				.oColIB.Add( toControl, lcKey )

			Endif && Empty( i )

			If toControl.lValidateInDataDictionary

				* Vincularlo al Diccionario de Datos
				loDD = NewDataDictionary()

				i = loDD.GetKey( lcKey )

				* toControl.lValidateInDataDictionary

				If Empty( i )
					Error "No es posible vincular el control " + toControl.cKeyName + " con el Diccionario de Datos"

				Else
					loField = loDD.Item( i )
					toControl.oField = loField

				Endif

			Endif

			If Pemstatus( toControl, 'HookOnResetError', 5 )
				Bindevent( This, 'OnResetError', toControl, 'HookOnResetError' )

			Endif && PemStatus( toControl, 'HookOnResetError', 5 )

			If Pemstatus( toControl, 'HookOnMarkValidationErrors', 5 )
				Bindevent( This, 'OnMarkValidationErrors', toControl, 'HookOnMarkValidationErrors' )

			Endif && Pemstatus( toControl, 'HookOnMarkValidationErrors', 5 )

		Endwith

	Endif

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = This.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
	loError = Null

Endtry

ENDPROC
PROCEDURE toprint
Lparameters tnMode As Integer, tcAlias As String

#INCLUDE "FW\Tieradapter\Include\TA.h"

Local lcReport As String
Local lcAlias As String
Local lcOldAlias As String
Local lnCurRecNo As Integer
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local loEntity As Object
Try
	With This As mainform Of FW\comunes\vcx\prxmainform.vcx
		lnMousePointer = .MousePointer
		If .CanList()
			.SetAll( 'MousePointer', 11 )

			loEntity = .oEntity
			If .nStatus = 0
				* Print all records
				lcReport = loEntity.cReportAll
				If Empty( lcReport )
					* No report specified - leave

				Else
					loEntity.GetAll()

				Endif && Empty( lcReport )

			Else
				* Print the current record
				lcReport = loEntity.cReportOne

			Endif && .nStatus = 0

			If Empty( lcReport )
				* No report specified - leave
				Warning( 'Falta definir el Reporte...' )

			Else
				If Empty( tcAlias )
					lcAlias = loEntity.cMainCursorName

				Else
					lcAlias = tcAlias

				Endif && Empty( tcAlias )

				lcOldAlias = Alias()
				If ! Empty( lcOldAlias )
					lnCurRecNo = SaveRecNo()

				Endif && ! Empty( lcOldAlias )
				PrintReport( lcReport, tnMode, 1, lcAlias )
				If ! Empty( lcOldAlias )
					Select( lcOldAlias )
					RestRecNo( lnCurRecNo )

				Endif && ! Empty( lcOldAlias )

			Endif

		Else
			Error 'No tiene permisos suficientes para realizar la operación'

		Endif && .CanList()

	Endwith

Catch To oErr
	loError = This.oError
	This.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = Null
	loEntity = Null
	This.SetAll( 'MousePointer', lnMousePointer )

Endtry

ENDPROC
PROCEDURE xreturnvalue_assign
Lparameters vNewVal As Variant

This.xReturnValue = m.vNewVal

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
nlevel Nivel necesario de tablas para que funcione el formulario.
nstatus Current status for the form (0=Idle, 1=Editing)
ocolcombos Coleccion de controles combo, que contienen objetos de negocios auxiliares
ocolib Colección de controles de la libresría InputBoxes
xreturnvalue The value of the last PrimaryKey displayed. This may be char, int, etc. depending of the type of the PK of the current entity.
uniquename Nombre Unico con el que figura en sys_Forms.dbf
ofirstfocus Referncia al objeto que recibirá el primer foco
maincaption Contiene el caption que se mostrará en SetMainCaption
ldatahaschanges Indica si los datos originales han sufrido cambios
ckeyname Se genera automáticamente y sirve para identificar al formulario en la colección oApp.oColForms
nbar Numero de BAR del menu "Ventana ", es utilizada por oColForms.RemoveMenu()
oldcaption
llaunchselectorafterinit Llama automáticamente al Selector 
nnewrecordlevel Esto se aplica a las entidades que tienen varios niveles, e indica el nivel hasta el que el metodo New() genera un registro vacío.
lkeeponinserting Indica si el comando New() continua generando nuevos registros
ndeletelevel Nivel de eliminación de las tablas. Si es 0, toma el valor de Thisform.nLevel
laddtowindowsmenu Indica si el Formulario se agrega automáticamente al menu "Ventana"
ocolkeyfinder Referencia a la coleccion KeyFinder
obuttons Es un objeto cuyas propiedades representan a cada uno de los botones disponibles
lisactive Indica si el form está activo
lsaveasscx Graba el formulario como un scx despés de ejecutar AutoSetup()
cdataconfigurationkey Clave por la que se accede al archivo de configuración de la capa de usuario (ObjectFactoryCfg.xml)
lonexit
coldcaption
xmloerror
corderby
nentidadid
nprocesstype Tipo de Proceso que está ejecutando
lusetransaction Indica si se manejan transacciones del lado del cliente
ocolcontrols
ocolgrids
ocolbuttons
ocolfiltros
cclassname Nombre de la clase a instanciar en oEntity
cclasslibrary Librería donde se encuentra This.cClassName
*getone 
*lookovercoltables Recorre recursivamente la colección Tables
*nstatus_assign 
*xreturnvalue_assign 
*showerror Muestra una descripción del error
*markvalidationerrors Recorre los controles, marcando aquellos que no cumplan con las reglas de validación
*setformcaption Modifica el caption del form. Es llamado por el metodo Open, a fin de poder reflejar el nuevo registro en el Caption del Formulario
*contextualmenu Ejecuta el menu contextual asociado al evento
*getfirst 
*getprior 
*getnext 
*getlast 
*fillkeyfinders Actualiza los controles internos de los controles KeyFinders
*obuttons_access 
*synchronizebuttons Sincroniza los botones activos en función del estado
*hookbeforesynchronizebuttons Permite modificar el comportamiento original de los botones antes de disparar el evento SynchronizeButtons
*doreport Ejecuta el formulario generador de reportes y consultas asociado a la entidad
*handlebizvalidationerror Maneja el error producido en una o más reglas de negocio
*recursivesetup 
*hookaftersynchronizebuttons 
*classaftergetone 
*hookaftergetone 
*classbeforegetone 
*hookbeforegetone 
*classbeforebindcontrols Verifica que la propiedad ControlSource de cada control esté correctamente asignada
*hookbeforebindcontrols 
*hookafterbindcontrols 
*classafterbindcontrols 
*hookbeforesetformcaption 
*classbeforesetformcaption 
*readonlycontrols Cambia la propiedad ReadOnly de los controles del formulario
*classbeforereadonlycontrols 
*hookbeforereadonlycontrols 
*classbeforesynchronizebuttons 
*classaftersynchronizebuttons 
*classbeforegetfirst 
*classaftergetfirst 
*hookbeforegetfirst 
*hookaftergetfirst 
*classbeforegetlast 
*classaftergetlast 
*hookbeforegetlast 
*hookaftergetlast 
*classbeforegetnext 
*classaftergetnext 
*hookbeforegetnext 
*hookaftergetnext 
*classbeforegetprior 
*classaftergetprior 
*hookbeforegetprior 
*hookaftergetprior 
*cancreate 
*canread 
*canupdate 
*candelete 
*canlist 
*canexport 
*subscribetocolib Encapsula la subscripcion de los controles a la colección oColIB y su vinculación con el Diccionario de Datos
*onsubscribe 
*cdataconfigurationkey_access 
*fill Evento para llenar controles
*empty Evento para vaciar controles
*nentidadid_access 
*nentidadid_assign 
*onreseterror Evento al que se suscriben los controles de la ColIB para que limpien la marca de error
*onmarkvalidationerrors 
*ocolgrids_access 
*ocolcontrols_access 
*subscribetocolgrid 
*subscribetocolbutton 
*ocolfiltros_access 
*enablecontrols Recursively enables or disables the controls within a form.
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
..\..\tieradapter\include\ta.h[END RESERVED8]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] mainform
[START PROPERTIES]
Arial, 0, 9, 5, 15, 12, 32, 3, 0
[END PROPERTIES]
[START RESERVED1]
  ..\..\tieradapter\include\ta.h&ìîU ..\include\praxis.h.ís~\V ..\include\foxpro.h6îÊrûF ..\include\strings.h>ïZOJ* ..\..\..\tools\namespaces\include\system.hFð±ÙF ..\include\strings.hNñZOJ[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1XZ1CEMF8
[CLASS] mainform
[CLASSLOC] prxmainform.vcx
[BASECLASS] form
[OBJNAME] abmgenericform
[START PROPERTIES]
Height = 290
Width = 588
DoCreate = .T.
Caption = "ABM Generic Form"
lorderbycodigo = .F.
lorderbydescripcion = .F.
lfirsttime = .T.
_memberdata =      784<VFPData>
	<memberdata name="npaddingtop" type="property" display="nPaddingTop"/>
	<memberdata name="npaddingbottom" type="property" display="nPaddingBottom"/>
	<memberdata name="npaddingleft" type="property" display="nPaddingLeft"/>
	<memberdata name="npaddingright" type="property" display="nPaddingRight"/>
	<memberdata name="creportall" type="property" display="cReportAll"/>
	<memberdata name="creportone" type="property" display="cReportOne"/>
	<memberdata name="cDataConfigurationKey" type="property" display="cDataConfigurationKey"/><memberdata name="oentity_access" type="method" display="oEntity_Access"/><memberdata name="populateproperties" type="method" display="PopulateProperties"/><memberdata name="lfirsttime" type="property" display="lFirstTime"/></VFPData>

Name = "abmgenericform"
[END PROPERTIES]
[START PROTECTED]
lfirsttime
[END PROTECTED]
[START METHODS]
PROCEDURE KeyPress
Lparameters nKeyCode, nShiftAltCtrl

#INCLUDE "FW\Comunes\Include\Praxis.h"
#INCLUDE "FW\Tieradapter\Include\TA.h"

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"

Try
    With This As ABMGenericForm Of FW\Comunes\vcx\prxmainform.vcx
        .oError.Ctracelogin = ''
        .oError.Cremark = ''
        Do Case
            Case nShiftAltCtrl = 0
                Do Case
                    Case nKeyCode = KEY_ESCAPE And .nStatus = IS_IDLE
                        .Release()

                    Otherwise
                        DoDefault( nKeyCode, nShiftAltCtrl )

                Endcase
            Otherwise
                DoDefault( nKeyCode, nShiftAltCtrl )

        Endcase
    Endwith
Catch To oErr
    This.lIsOk = .F.
    loError = This.oError
    This.cXMLoError = loError.Process( oErr )

Finally
    loError = Null

Endtry


ENDPROC
PROCEDURE classafterautosetup
#INCLUDE "FW\Comunes\Include\Praxis.h"

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local lnWidth As Number

Try
	* DAE 2009-07-06 (13:43:57)
	* Ejecuto el codigo base despues, sino no funciona bien el fitToParent
	* DoDefault()
	With This As ABMGenericform Of FW\Comunes\vcx\prxmainform.vcx
		If .lFirstTime
			.OptionPanel.Anchor = 0

			For Each loCtrl In This.oColObjects
				If Pemstatus( loCtrl, "AnchorStatus", 5 )
					loCtrl.AnchorStatus( .T. )

				Endif && Pemstatus( loCtrl, "AnchorStatus", 5 )

			Endfor

			.lFirstTime = .F.
			If .Navigator.Visible
				.OptionPanel.Left = .Navigator.Left + .Navigator.ContractedWidth + .nGap
				.OptionPanel.Top = .Navigator.Top
				lnWidth = .nLeftPadding + .Navigator.ContractedWidth + .nGap + .OptionPanel.Width + .nRightPadding
				.Width = Max( .Width, lnWidth )
				.Height = .OptionPanel.Top + .OptionPanel.Height + .nBottomPadding

			Else
				lnWidth = .nLeftPadding + .OptionPanel.Width + .nRightPadding
				.Width = Max( .Width, lnWidth )
				.OptionPanel.lFitToParent = .T.
				* .OptionPanel.nFitMode = 1
				.OptionPanel.nFitMode = 5

			Endif && .Navigator.Visible

			For Each loCtrl In This.oColObjects
				If Pemstatus( loCtrl, "AnchorStatus", 5 )
					loCtrl.AnchorStatus( .F. )

				Endif && Pemstatus( loCtrl, "AnchorStatus", 5 )

			Endfor

			.OptionPanel.Anchor = ANCHOR_Left_Absolute ;
				+ ANCHOR_Bottom_Absolute ;
				+ ANCHOR_Right_Absolute

			If .Navigator.Visible
				.Navigator.Anchor = ANCHOR_Left_Absolute ;
					+ ANCHOR_Bottom_Absolute

			Endif && .Navigator.Visible

		Endif && .lFirstTime

	Endwith

	DoDefault()

Catch To oErr
	loError = This.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = Null
	loCtrl = Null

Endtry

ENDPROCPROCEDURE classafterinit
* Lparameters txIdEntity As Integer, tlModalWindowType As boolean, toParam As Object
Lparameters toParam As Object

#INCLUDE "FW\Tieradapter\Include\TA.h"

Local llOk As boolean
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"

Try
    With This As abmgenericform Of FW\Comunes\vcx\prxmainform.vcx
        * llOk = DoDefault( txIdEntity, tlModalWindowType, toParam )
        llOk = DoDefault( toParam )
        If llOk
            If Empty( .nEntidadId ) And .nProcessType # TR_NEW
                .OptionPanel.SetFocus()
                .OptionPanel.cmdOpen.SetFocus()

            EndIf && Empty( .nEntidadId ) And .ProcessType # TR_NEW

            llOk = .lIsOk

        EndIf && llOk

    Endwith
Catch To oErr
    llOk = .F.
    loError = This.oError
    This.cXMLoError = loError.Process( oErr )
    Throw loError

Finally
    loError = Null

EndTry

Return llOk

ENDPROC
PROCEDURE classbeforeautosetup

With This As ABMGenericForm Of FW\Comunes\vcx\prxmainform.vcx
	* Assert ! .lIsChildForm Message 'Ocultar la barra de navegación'
	.Navigator.Visible = ! .lIsChildForm
	If ! .Navigator.Visible
		.Navigator.Contract()
		.Navigator.Move( -500, -500 )
		.Navigator.lAutoSetup = .F.
		.Navigator.Visible = .F.
		.Navigator.Enabled = .F.
		
	EndIf
	
Endwith

Return DoDefault()

ENDPROC
PROCEDURE enablecontrols
Lparameters tlEnable As Boolean
#INCLUDE "fw\tieradapter\include\ta.h"
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try

    If Thisform.nProcessType = TR_DELETE
    	tlEnable = .F.
    	
    EndIf && Thisform.nProcessType = TR_DELETE

    DoDefault( tlEnable )
    With This As ABMGenericForm Of FW\Comunes\vcx\prxmainform.vcx
        * Los botones están siempre activos
        .OptionPanel.SetAll( 'lIsActive', .T. )
        .Navigator.SetAll( 'lIsActive', .T. )

    EndWith

Catch To oErr
    loError = This.oError
    This.cXMLoError = loError.Process( oErr )
    Throw loError

Finally
    loError = Null

Endtry

ENDPROC
PROCEDURE handlenextfocus
Lparameters toControl As Object

Local llIsLastFocus As Boolean
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"

Try
    With This As ABMGenericform Of FW\Comunes\vcx\prxmainform.vcx
        Try
            llIsLastFocus = toControl.lIsLastFocus

        Catch To oErr
            llIsLastFocus = .F.

        Endtry
        Do Case
            Case llIsLastFocus
                Do Case
                    Case .OptionPanel.cmdSave.Enabled
                        .OptionPanel.cmdSave.SetFocus()

                    Otherwise
                        .OptionPanel.SetFocus()

                EndCase

            Otherwise

        EndCase

    Endwith
Catch To oErr
    loError = This.oError
    This.cXMLoError = loError.Process( oErr )
    Throw loError

Finally
    loError = Null

Endtry

ENDPROC
PROCEDURE lorderbycodigo_assign
Lparameters tuNewValue As boolean
This.lOrderByCodigo = tuNewValue

If tuNewValue = .T.
	Thisform.Navigator.OrderBy.Value = 2
	
Endif


ENDPROC
PROCEDURE lorderbydescripcion_assign
lparameters tuNewValue as boolean
This.lOrderByDescripcion = tuNewValue

If tuNewValue = .T.
	Thisform.Navigator.OrderBy.Value = 1
	
EndIf && tuNewValue = .T.

ENDPROC
PROCEDURE nstatus_assign
Lparameters vNewVal As Variant
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''
	DoDefault( vNewVal )
	With Thisform As ABMGenericForm Of FW\Comunes\vcx\prxmainform.vcx
		.Navigator.Visible = .T.
		*!*	If Empty( .IdEntidad )
		*!*	    * .Navigator.Visible = .F.
		*!*	    .Navigator.Visible = .T.
		*!*	Else
		*!*	    .Navigator.Visible = .T.
		*!*	Endif
		
	EndWith
	
Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''
	loError = Null

Endtry



ENDPROC
PROCEDURE synchronizebuttons
Lparameters tlActivate As Boolean

#INCLUDE "FW\Tieradapter\Include\TA.h"

Local llIdle As Boolean
Local llEditing As Boolean
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local lnEntidadId As Integer
Try
	With This As mainform Of FW\Comunes\vcx\prxmainform.vcx

		If !Thisform.lExit


			If .ClassBeforeSynchronizeButtons( tlActivate )

				If .HookBeforeSynchronizeButtons( tlActivate )

					If tlActivate
						* Switches the toolbar buttons according
						* with the form's current status
						llIdle = Inlist( .nStatus, IS_IDLE, IS_READING )
						llEditing = ( .nStatus = IS_EDITING )

					Else
						Store .F. To llIdle, llEditing

					Endif && tlActivate
					If ! .lExit
						lnEntidadId = .oEntity.nEntidadId

					Else
						lnEntidadId = 0

					Endif

					* Enabled buttons when idle
					.oButtons.New = llIdle And .OptionPanel.cmdNew.lVisible
					* DAE 2009-06-30 (16:55:25)
					* .oButtons.Open = llIdle
					.oButtons.Open = llIdle And .OptionPanel.cmdOpen.lVisible  && And ! Empty( .IdEntidad )
					* .oButtons.Edit = llIdle And ! Empty( .IdEntidad )
					.oButtons.Edit = llIdle And ! Empty( lnEntidadId ) And .OptionPanel.cmdEdit.lVisible

					* Enabled buttons when editing
					.oButtons.Close = .lIsActive And .OptionPanel.cmdClose.lVisible
					* DAE 2009-08-13(19:30:49)
					* .oButtons.Delete = llIdle And ( .nProcessType = TR_QUERY ) And .OptionPanel.cmdDelete.lVisible
					.oButtons.Delete = llIdle And ! Empty( lnEntidadId ) And .OptionPanel.cmdDelete.lVisible
					.oButtons.Save = llEditing And .OptionPanel.cmdSave.lVisible

					* Enabled buttons when active
					* Report always available
					* .oButtons.Report = llIdle And ! Empty( .IdEntidad )
					* DA 2009-11-09(12:05:25)
*					.oButtons.Report = llIdle And ! Empty( lnEntidadId ) And .OptionPanel.cmdReport.lVisible
					.oButtons.Report = llIdle And .OptionPanel.cmdReport.lVisible
					*
					.oGlobalSettings.oApp.SynchronizeButtons()
					.HookAfterSynchronizeButtons( tlActivate )
					.ClassAfterSynchronizeButtons( tlActivate )

				Endif && .HookBeforeSynchronizeButtons( tlActivate )

			Endif && .ClassBeforeSynchronizeButtons( tlActivate )
		Endif
	Endwith

Catch To oErr
	This.lIsOk = .F.
	loError = This.oError
	This.cXMLoError = loError.Process( oErr )

Finally
	loError = Null

Endtry

If ! This.lIsOk
	This.Release()

Endif && ! This.lIsOk


ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
4[END RESERVED2]
[START RESERVED3]
lorderbycodigo
lorderbydescripcion
lfirsttime
*handlenextfocus 
*lorderbycodigo_assign 
*lorderbydescripcion_assign 
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED8]
..\..\tieradapter\include\ta.h[END RESERVED8]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Y515F3KD
[CLASS] optionpanel
[CLASSLOC] prxmainform.vcx
[BASECLASS] container
[OBJNAME] OptionPanel
[PARENT] abmgenericform
[START PROPERTIES]
Top = 216
Left = 0
Width = 576
Height = 48
TabIndex = 2
ZOrderSet = 1
_memberdata =      427<VFPData><memberdata name="autofit" type="method" display="Autofit"/><memberdata name="nGap" type="property" display="nGap"/><memberdata name="lautofit" type="property" display="lAutofit"/><memberdata name="lautosetup" type="property" display="lAutoSetup"/><memberdata name="samerowasprevious" type="property" display="SameRowAsPrevious" favorites="True"/><memberdata name="visible" type="Property" favorites="True"/></VFPData>
nfitmode = 4
ngap = 0
Name = "OptionPanel"
Shape.Name = "Shape"
shpLabel.Name = "shpLabel"
lblTitulo.Name = "lblTitulo"
cmdClose.Name = "cmdClose"
cmdDelete.Name = "cmdDelete"
cmdNew.Name = "cmdNew"
cmdSave.Name = "cmdSave"
cmdOpen.Name = "cmdOpen"
cmdReport.Caption = "Informe"
cmdReport.Name = "cmdReport"
cmdEdit.Name = "cmdEdit"
[END PROPERTIES]
[START METHODS]
PROCEDURE fittoparent

DoDefault()

*!*	#INCLUDE "Fw\Comunes\Include\Praxis.h"

*!*	Local lnTop As Integer
*!*	Local lnHeight As Integer
*!*	Local lnWidth As Integer
*!*	Local lnLeft As Integer
*!*	Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
*!*	Local loPageFrame As PageFrame
*!*	Local loCtl As Control
*!*	Local lnOldAnchor As Number
*!*	Try
*!*		With This As ccmarcobase Of fw\comunes\vcx\controles_varios.vcx

*!*			lnOldAnchor = .Anchor
*!*			.Anchor = 0
*!*			.nFitMode = FIT_WIDTH
*!*			
*!*			lnWidth = Thisform.Width - Thisform.nRightPadding - This.Left

*!*			.Width = lnWidth

*!*			If Empty( lnOldAnchor )
*!*				.Anchor = ANCHOR_Bottom_Absolute + ANCHOR_Right_Absolute

*!*			Else
*!*				.Anchor = lnOldAnchor

*!*			Endif

*!*		Endwith

*!*	Catch To oErr
*!*		loError = Thisform.oError
*!*		Thisform.cXMLoError = loError.Process( oErr )
*!*		Throw loError

*!*	Finally
*!*		loPageFrame = Null
*!*		loError = Null

*!*	Endtry



ENDPROC
PROCEDURE hookafterautosetup
Lparameters tlOnlyPosition As Boolean
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try

	With This.Parent As abmgenericform Of FW\Comunes\vcx\prxmainform.vcx
		DoDefault( tlOnlyPosition )
		If .Navigator.Visible
			.Navigator.ExpandedHeight = This.Height
			.Navigator.ContractedHeight = This.Height
			.Navigator.Contract( .T. )

		Endif && .Navigator.Visible
		
	Endwith

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError
	
Finally
	loError = Null
	
Endtry

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2EM14SJ0X
[CLASS] abstractbutton
[CLASSLOC] buttons.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdDebugInfo
[PARENT] abmgenericform
[START PROPERTIES]
Top = 12
Left = 12
Height = 21
Width = 16
FontBold = .T.
Caption = "?"
lperformautosetup = .F.
lautosetup = .F.
Name = "cmdDebugInfo"
[END PROPERTIES]
[START METHODS]
PROCEDURE Refresh

With This As CommandButton
	.Move( -500, -500 )
* .ZOrder()
	.lEnabled = .F.
	.lIsActive = .F.
	.Enabled = .F.
	
Endwith

ENDPROC
PROCEDURE RightClick

Local lnOpcion As Number
Local lcRet As String
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
	*!*	lnOpcion = xmenu( 'Ver Bordes;Ocultar Bordes;Ver Propiedades;Ver Propiedades Nativas;Copiar Info' )

	*!*	Do Case
	*!*		Case lnOpcion = 1
	*!*			VerBordes( Thisform )

	*!*		Case lnOpcion = 2
	*!*			OCultarBordes( Thisform )

	*!*		Case lnOpcion = 3
	*!*			lcRet = VerProperties( Thisform  )
	*!*			_Cliptext = lcRet

	*!*		Case lnOpcion = 4
	*!*			lcRet = VerProperties( Thisform, 0, .T. )
	*!*			_Cliptext = lcRet

	*!*		Case lnOpcion = 5
	*!*			lcInfo = ''

	*!*			TEXT To lcInfo NoShow TextMerge Pretext 1 + 2 ADDITIVE
	*!*		Caption: <<Thisform.Caption>>
	*!*		DataSessionId: <<Thisform.DataSessionId>>
	*!*		WindowType: <<Thisform.WindowType>>
	*!*		cDataConfigurationKey: <<thisform.cDataConfigurationKey>>
	*!*		nEntidadId: <<Thisform.nEntidadId>>
	*!*		nProcessType: <<Thisform.nProcessType>>
	*!*		nStatus: <<Thisform.nStatus>>
	*!*		BindControls: <<Thisform.BindControls>>
	*!*		oEntity.Name: <<Thisform.oEntity.Name>>
	*!*		oEntity.Class: <<Thisform.oEntity.Class>>
	*!*		oEntity.ClassLibrary: <<Thisform.oEntity.ClassLibrary>>
	*!*		oEntity.ParentClass: <<Thisform.oEntity.ParentClass>>
	*!*		oEntity.lIsChild: <<Thisform.oEntity.lIsChild>>
	*!*		oEntity.nEntidadId: <<Thisform.oEntity.nEntidadId>>
	*!*		Txnlevel: <<Txnlevel()>>
	*!*		Tablas:


	*!*			ENDTEXT

	*!*			For i = 1 To Aused( lAUsed )
	*!*				lcAlias = Alias( lAUsed[ i, 1 ] )
	*!*				lnRecno = SaveRecNo( lcAlias )
	*!*				llIsTrans = IsTransactable( lcAlias )
	*!*				llBof = Bof( lcAlias )
	*!*				llEof = Eof( lcAlias )

	*!*				Try
	*!*					lnBuffer = CursorGetProp( "Buffering", lcAlias )
	*!*				Catch To oErr
	*!*					lnBuffer = 0
	*!*				Endtry

	*!*				Try
	*!*					lnSourceType = CursorGetProp( "SourceType", lcAlias )
	*!*				Catch To oErr
	*!*					lnSourceType = 0
	*!*				Endtry

	*!*				Try
	*!*					lcSourceName = CursorGetProp( "SourceName", lcAlias )
	*!*				Catch To oErr
	*!*					lcSourceName = ''
	*!*				Endtry

	*!*				Try
	*!*					lcSQL = CursorGetProp( "SQL", lcAlias )
	*!*				Catch To oErr
	*!*					lcSQL = ''
	*!*				Endtry

	*!*				Try
	*!*					lcTables = CursorGetProp( "Tables", lcAlias )
	*!*				Catch To oErr
	*!*					lcTables = ''
	*!*				Endtry

	*!*				Try
	*!*					lcDatabase = CursorGetProp( "Database", lcAlias )
	*!*				Catch To oErr
	*!*					lcDatabase = ''
	*!*				Endtry

	*!*				Try
	*!*					lnWhereType = CursorGetProp( "WhereType", lcAlias )
	*!*				Catch To oErr
	*!*					lnWhereType = 0
	*!*				Endtry

	*!*				* lnReccount = Reccount( Alias( lAUsed[ i, 1 ] ) )
	*!*				TEXT To lcCommand NoShow TextMerge Pretext 15
	*!*					Calculate Cnt() for ! Deleted( '<<lcAlias>>' ) to lnReccount in <<lcAlias>>

	*!*				ENDTEXT

	*!*				Try
	*!*					&lcCommand
	*!*				Catch To oErr
	*!*					lnReccount = 0
	*!*				Endtry

	*!*				TEXT To lcInfo NoShow TextMerge Pretext 1 + 2 ADDITIVE
	*!*				<<lcAlias>> bof: <<llBof>> eof: <<llEof>> reg: <<lnRecno>> de <<lnReccount>> Tx: <<llIsTrans>> Bf: <<lnBuffer>> St: <<lnSourceType>> Sn: <<lcSourceName>> SQL: <<lcSQL>> Db: <<lcDatabase>> Tbl: <<lcTables>> Wt: <<lnWhereType>>

	*!*				ENDTEXT

	*!*				RestRecNo( lnRecno, Alias( lAUsed[ i, 1 ] ) )

	*!*			Endfor

	*!*			lcRet = lcInfo


	*!*			_Cliptext = lcRet

	*!*		Otherwise

	*!*	Endcase

Catch To oErr
	loError = Newobject( "ErrorHandler", "Tools\ErrorHandler\Prg\ErrorHandler.prg" )
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = Null

Endtry

ENDPROC
PROCEDURE autosetup
Lparameters tvParam As Variant
With This As CommandButton
	.Move( -500, -500 )
	* .ZOrder()
	.lEnabled = .F.
	.lIsActive = .F.
	.Enabled = .F.

Endwith

ENDPROC
PROCEDURE hookbeforeclick
* Cancelo el evento
#Define CR Chr( 13 )
Local lcInfo As String
Local lnRecno As Number
Local lnReccount As Number
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local llIsTrans As Boolean
Local lnBuffer As Number
Local llBof As Boolean
Local llEof As Boolean
Local lcSQL As String
Local lcTables As String
Local lnWhereType As Number

Try

	*!*	lcInfo = ''

	*!*	TEXT To lcInfo NoShow TextMerge Pretext 1 + 2 ADDITIVE
	*!*		Caption: <<Thisform.Caption>>
	*!*		DataSessionId: <<Thisform.DataSessionId>>
	*!*		WindowType: <<Thisform.WindowType>>
	*!*		cDataConfigurationKey: <<thisform.cDataConfigurationKey>>
	*!*		nEntidadId: <<Thisform.nEntidadId>>
	*!*		nProcessType: <<Thisform.nProcessType>>
	*!*		nStatus: <<Thisform.nStatus>>
	*!*		BindControls: <<Thisform.BindControls>>
	*!*		oEntity.Name: <<Thisform.oEntity.Name>>
	*!*		oEntity.Class: <<Thisform.oEntity.Class>>
	*!*		oEntity.ClassLibrary: <<Thisform.oEntity.ClassLibrary>>
	*!*		oEntity.ParentClass: <<Thisform.oEntity.ParentClass>>
	*!*		oEntity.lIsChild: <<Thisform.oEntity.lIsChild>>
	*!*		oEntity.nEntidadId: <<Thisform.oEntity.nEntidadId>>
	*!*		Txnlevel: <<Txnlevel()>>
	*!*		Tablas:


	*!*	ENDTEXT

	*!*	For i = 1 To Aused( lAUsed )
	*!*		lcAlias = Alias( lAUsed[ i, 1 ] )
	*!*		lnRecno = SaveRecNo( lcAlias )
	*!*		llIsTrans = IsTransactable( lcAlias )
	*!*		llBof = Bof( lcAlias )
	*!*		llEof = Eof( lcAlias )

	*!*		Try
	*!*			lnBuffer = CursorGetProp( "Buffering", lcAlias )
	*!*		Catch To oErr
	*!*			lnBuffer = 0
	*!*		Endtry

	*!*		Try
	*!*			lnSourceType = CursorGetProp( "SourceType", lcAlias )
	*!*		Catch To oErr
	*!*			lnSourceType = 0
	*!*		Endtry

	*!*		Try
	*!*			lcSourceName = CursorGetProp( "SourceName", lcAlias )
	*!*		Catch To oErr
	*!*			lcSourceName = ''
	*!*		Endtry

	*!*		Try
	*!*			lcSQL = CursorGetProp( "SQL", lcAlias )
	*!*		Catch To oErr
	*!*			lcSQL = ''
	*!*		Endtry

	*!*		Try
	*!*			lcTables = CursorGetProp( "Tables", lcAlias )
	*!*		Catch To oErr
	*!*			lcTables = ''
	*!*		Endtry

	*!*		Try
	*!*			lcDatabase = CursorGetProp( "Database", lcAlias )
	*!*		Catch To oErr
	*!*			lcDatabase = ''
	*!*		Endtry

	*!*		Try
	*!*			lnWhereType = CursorGetProp( "WhereType", lcAlias )
	*!*		Catch To oErr
	*!*			lnWhereType = 0
	*!*		Endtry

	*!*		* lnReccount = Reccount( Alias( lAUsed[ i, 1 ] ) )
	*!*		TEXT To lcCommand NoShow TextMerge Pretext 15
	*!*		Calculate Cnt() for ! Deleted( '<<lcAlias>>' ) to lnReccount in <<lcAlias>>

	*!*		ENDTEXT

	*!*		Try
	*!*			&lcCommand
	*!*		Catch To oErr
	*!*			lnReccount = 0
	*!*		Endtry

	*!*		TEXT To lcInfo NoShow TextMerge Pretext 1 + 2 ADDITIVE
	*!*			<<lcAlias>> bof: <<llBof>> eof: <<llEof>> reg: <<lnRecno>> de <<lnReccount>> Tx: <<llIsTrans>> Bf: <<lnBuffer>> St: <<lnSourceType>> Sn: <<lcSourceName>> SQL: <<lcSQL>> Db: <<lcDatabase>> Tbl: <<lcTables>> Wt: <<lnWhereType>>

	*!*		ENDTEXT

	*!*		RestRecNo( lnRecno, Alias( lAUsed[ i, 1 ] ) )

	*!*	Endfor
	*!*	Messagebox( lcInfo )

Catch To oErr
	loError = Newobject( "ErrorHandler", "Tools\ErrorHandler\Prg\ErrorHandler.prg" )
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = Null

Endtry

Return .F.

ENDPROC
PROCEDURE hookbeforeinit

With This As CommandButton
	.Visible = .F. && ! IsRuntime()&&  And ( Thisform.WindowType = 1 )
	Bindevent( Thisform, 'HookAfterAutoSetup', This, 'AutoSetup' )
	.Move( -500, -500 )
	.lEnabled = .F.
	.lIsActive = .F.
	.Enabled = .F.
	* .ZOrder()

Endwith

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Z90RDR7V
[CLASS] tablenavigator
[CLASSLOC] prxmainform.vcx
[BASECLASS] container
[OBJNAME] Navigator
[PARENT] abmgenericform
[START PROPERTIES]
Top = 168
Left = 0
Width = 256
Height = 39
TabIndex = 1
ZOrderSet = 2
Name = "Navigator"
Shape.Name = "Shape"
shpLabel.Name = "shpLabel"
lblTitulo.Name = "lblTitulo"
cmdFirst.Name = "cmdFirst"
cmdPrior.Name = "cmdPrior"
cmdNext.Name = "cmdNext"
cmdLast.Name = "cmdLast"
OrderBy.Name = "OrderBy"
picExpand.Height = 32
picExpand.Width = 16
picExpand.Name = "picExpand"
picContract.Height = 32
picContract.Width = 16
picContract.Name = "picContract"
[END PROPERTIES]
[START METHODS]
PROCEDURE MouseEnter
Lparameters nButton, nShift, nXCoord, nYCoord
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
    With Thisform As ABMGenericForm Of FW\Comunes\vcx\prxmainform.vcx
        If Inlist( .nStatus, IS_IDLE, IS_READING )
            DoDefault( nButton, nShift, nXCoord, nYCoord )

        EndIf && Inlist( .nStatus, IS_IDLE, IS_READING )

    EndWith

Catch To oErr
    loError = Thisform.oError
    Thisform.cXMLoError = loError.Process( oErr )

Finally
    loError = Null

Endtry

ENDPROC
PROCEDURE expand
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
    With Thisform As ABMGenericform Of FW\Comunes\vcx\prxmainform.vcx
        If .nStatus = IS_EDITING
            .Close()

        EndIf && .nStatus = IS_EDITING

        If Inlist( .nStatus, IS_IDLE, IS_READING )
            DoDefault()
            .SynchronizeButtons( .F. )

        EndIf && Inlist( .nStatus, IS_IDLE, IS_READING )

    Endwith
Catch To oErr
    loError = Thisform.oError
    Thisform.cXMLoError = loError.Process( oErr )
    Throw loError

Finally
    loError = Null

Endtry

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] abmgenericform
[START PROPERTIES]
Arial, 0, 9, 5, 15, 12, 32, 3, 0
Arial, 1, 9, 6, 15, 12, 32, 3, 0
[END PROPERTIES]
[START RESERVED1]
  ..\..\tieradapter\include\ta.hÏîU ..\include\praxis.hÐs~\V ..\include\foxpro.hÑÊrûF ..\include\strings.hÒZOJ* ..\..\..\tools\namespaces\include\system.h&Ó±ÙF[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Y30L14CQ
[CLASS] prxgridsearch
[CLASSLOC] prxsearch.vcx
[BASECLASS] grid
[OBJNAME] prxactiongrid
[START PROPERTIES]
MemberClassLibrary = ..\..\tieradapter\comun\prxbaselibrary.prg
MemberClass = "PrxColumn"
ColumnCount = -1
AllowHeaderSizing = .F.
AllowRowSizing = .F.
DeleteMark = .F.
GridLines = 0
Height = 183
RecordMark = .F.
RowHeight = 16
ScrollBars = 2
Width = 295
GridLineColor = 192,192,192
HighlightForeColor = 0,0,64
HighlightStyle = 2
AllowAutoColumnFit = 2
AllowCellSelection = .F.
Optimize = .T.
casociatedcursor = 
lcastdatetime = .T.
gridautofit = .T.
nlastkeystroke = 0
csearchbuffer = 
nupdatefontsize = 0
rowsperpage = 0
cfitcolumn = 
nlastrow = 0
ocolgridlayout = .NULL.
noriginalwidth = 0
lischeckfitcolumn = .F.
otable = .NULL.
cmaincursorname = 
lcanupdate = .F.
_memberdata =     4115<VFPData><memberdata name="fillgrid" type="method" display="FillGrid"/><memberdata name="handlesearch" type="method" display="HandleSearch"/><memberdata name="asociatedcursor" type="property" display="AsociatedCursor" favorites="True"/><memberdata name="castdatetime" type="property" display="CastDateTime" favorites="True"/><memberdata name="fieldlist" type="property" display="FieldList" favorites="True"/><memberdata name="gridautofit" type="property" display="GridAutofit" favorites="True"/><memberdata name="headercaptions" type="property" display="HeaderCaptions" favorites="True"/><memberdata name="lastkeystroke" type="property" display="LastKeyStroke"/><memberdata name="pkfield" type="property" display="PKField" favorites="True"/><memberdata name="searchbuffer" type="property" display="SearchBuffer"/><memberdata name="oder" type="property" display="Oder" favorites="True"/><memberdata name="order" type="property" display="Order" favorites="True"/><memberdata name="nupdatefontsize" type="property" display="nUpdateFontSize"/><memberdata name="nupdatefontsize_assign" type="method" display="nUpdateFontSize_Assign"/><memberdata name="emptygrid" type="method" display="EmptyGrid"/><memberdata name="rowsperpage" type="property" display="RowsPerPage" favorites="True"/><memberdata name="performlayout" type="method" display="PerformLayout"/><memberdata name="enabled_assign" type="method" display="Enabled_Assign"/><memberdata name="fitcolumn" type="property" display="FitColumn"/><memberdata name="adjustfitcolumn" type="method" display="AdjustFitColumn"/><memberdata name="getfields" type="method" display="GetFields"/><memberdata name="adjustgridtocolumns" type="method" display="AdjustGridToColumns"/><memberdata name="autosetup" type="method" display="AutoSetUp"/><memberdata name="setselected" type="method" display="SetSelected"/><memberdata name="llllllPerformAutoSetUp" type="property" display="llllllPerformAutoSetUp" favorites="True"/><memberdata name="fill" type="method" display="Fill"/><memberdata name="classbeforefill" type="method" display="ClassBeforeFill"/><memberdata name="classafterfill" type="method" display="ClassAfterFill"/><memberdata name="hookbeforefill" type="method" display="HookBeforeFill"/><memberdata name="hookafterfill" type="method" display="HookAfterFill"/><memberdata name="empty" type="method" display="Empty"/><memberdata name="classbeforeempty" type="method" display="ClassBeforeEmpty"/><memberdata name="classafterempty" type="method" display="ClassAfterEmpty"/><memberdata name="hookbeforeempty" type="method" display="HookBeforeEmpty"/><memberdata name="hookafterempty" type="method" display="HookAfterEmpty"/><memberdata name="nlastrow" type="property" display="nLastRow"/><memberdata name="casociatedcursor" type="property" display="cAsociatedCursor" favorites="True"/><memberdata name="lcastdatetime" type="property" display="lCastDateTime" favorites="True"/><memberdata name="cfitcolumn" type="property" display="cFitColumn" favorites="True"/><memberdata name="csearchbuffer" type="property" display="cSearchBuffer"/><memberdata name="nlastkeystroke" type="property" display="nLastKeystroke"/><memberdata name="ocolgridlayout" display="oColGridLayout"/><memberdata name="ocolgridlayout_access" display="oColGridLayout_Access"/><memberdata name="noriginalwidth" type="property" display="nOriginalWidth"/><memberdata name="cfitcolumn_access" type="property" display="cFitColumn_Access" favorites="True"/><memberdata name="lischeckfitcolumn" type="property" display="lIsCheckFitColumn"/><memberdata name="columnmouseenter" type="method" display="ColumnMouseEnter"/><memberdata name="columnmouseleave" type="method" display="ColumnMouseLeave"/><memberdata name="setgridlayout" display="SetGridLayout"/><memberdata name="otable" display="oTable"/><memberdata name="otable_access" display="oTable_Access"/><memberdata name="definetable" display="DefineTable"/><memberdata name="cmaincursorname" display="cMainCursorName"/><memberdata name="cmaincursorname_access" display="cMainCursorName_Access"/><memberdata name="lcanupdate" display="lCanUpdate"/></VFPData>
Name = "prxactiongrid"
[END PROPERTIES]
[START PROTECTED]
nlastkeystroke
csearchbuffer
nlastrow
noriginalwidth
lischeckfitcolumn
classbeforefill
classafterfill
classbeforeempty
classafterempty
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy

Local lcCommand As String

Try

	lcCommand = ""

	With This As prxactiongrid Of FW\Comunes\vcx\prxmainform.vcx
		* .oColGridLayout.Remove( -1 )
		.oColGridLayout = Null

	Endwith
	Unbindevents( This )


Catch To oErr
	Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
	loError = Newobject( "ErrorHandler", "ErrorhandlerPrg\ErrorHandler.prg" )
	loError.Cremark = lcCommand
	loError.Process( oErr )
	Throw loError

Finally


Endtry

ENDPROC
PROCEDURE KeyPress
Lparameters nKeyCode As Integer, nShiftAltCtrl As Integer

Local lcCommand as String

Try

	lcCommand = ""
    Do Case
        Case nShiftAltCtrl = 0
            Do Case
                Case nKeyCode > 31
                    This.HandleSearch( nKeyCode )
                Otherwise
                    DoDefault( nKeyCode, nShiftAltCtrl )
            Endcase
        Otherwise
            DoDefault( nKeyCode, nShiftAltCtrl )
    EndCase

Catch To oErr
	Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
	loError = Newobject( "ErrorHandler", "ErrorhandlerPrg\ErrorHandler.prg" )
	loError.Cremark = lcCommand
	loError.Process( oErr )
	Throw loError

Finally
	
	
EndTry

ENDPROCPROCEDURE Resize

Local lcCommand As String

Try

	lcCommand = ""
	
	With This As prxactiongrid Of FW\Comunes\vcx\prxmainform.vcx
		If This.ColumnCount > 0
			This.AdjustFitColumn()
		Endif
	Endwith


Catch To oErr
	Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
	loError = Newobject( "ErrorHandler", "ErrorhandlerPrg\ErrorHandler.prg" )
	loError.Cremark = lcCommand
	loError.Process( oErr )
	Throw loError

Finally


Endtry

ENDPROC
PROCEDURE adjustfitcolumn
#INCLUDE "FW\Comunes\Include\Praxis.h"

Local lnFitColumnWidth As Integer
Local lnTotalColumnsWidth As Integer
Local loColumn As Column
Local loFitColumn As Column
Local lcFitColumn As String
	
Local lcCommand as String

Try

	lcCommand = ""
	lnFitColumnWidth = 0
	lnTotalColumnsWidth = 0
	loFitColumn = Null
	With This As prxactiongrid Of FW\Comunes\vcx\prxmainform.vcx
		lcFitColumn = .cFitColumn
		If ! Empty( lcFitColumn )
			lcFitColumn = Lower( lcFitColumn )
			For Each loColumn In This.Columns
				If Lower( loColumn.Name ) = lcFitColumn
					lnFitColumnWidth = loColumn.Width
					loFitColumn = loColumn

				Endif && Lower( loColumn.Name ) = lcFitColumn
				lnTotalColumnsWidth = lnTotalColumnsWidth + loColumn.Width
			Endfor
			If Empty( lnFitColumnWidth )
				Assert .F. Message "No existe la columna " + lcFitColumn

			Else

*!*					If This.ScrollBars >= 2 && Tiene la ScrollBar Vertical
*!*						lnTotalColumnsWidth = lnTotalColumnsWidth + SCROLLBARS_WIDTH
*!*					Endif

				
				Try
				
					loFitColumn.Width = lnFitColumnWidth + ( .Width - lnTotalColumnsWidth )					
				
				Catch To oErr
					lnWidth = lnFitColumnWidth + ( .Width - lnTotalColumnsWidth )					

				Finally

				EndTry

				

			Endif && Empty( lnFitColumnWidth )

		Endif && ! Empty( lcFitColumn )

	EndWith

Catch To oErr
	Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
	loError = Newobject( "ErrorHandler", "ErrorhandlerPrg\ErrorHandler.prg" )
	loError.Cremark = lcCommand
	loError.Process( oErr )
	Throw loError

Finally
	loColumn = Null
	loFitColumn = Null
	
EndTry
	

ENDPROC
PROCEDURE autosetup
#INCLUDE "FW\Comunes\Include\Praxis.h"

Local lnTotalColumnsWidth As Integer
Local loColumn As Column
Local loItem As Object
Local iQ As Number
Local lnColumnWidth As Number
	
Local lcCommand as String

Try

	lcCommand = ""



	With This As prxactiongrid Of FW\Comunes\vcx\prxmainform.vcx
		If .lPerformAutoSetUp
			lnTotalColumnsWidth = 0

			.ColumnCount = .oColGridLayout.Count
			iQ = 1

			For Each loColumn In .Columns
				loItem = .oColGridLayout.Item( iQ )
				loColumn.ReadOnly = !This.lCanUpdate
				.PerformLayout( loColumn, loItem )
				lnColumnWidth = loItem.ColumnWidth
				lnTotalColumnsWidth = lnTotalColumnsWidth + lnColumnWidth
				If Pemstatus( loColumn, 'nOriginalWidth', 5 )
					loColumn.nOriginalWidth = lnColumnWidth

				Endif && PemStatus( loColumn, 'nOriginalWidth', 5 )
				iQ = iQ + 1

			Endfor

			If This.ScrollBars >= 2 && Tiene la ScrollBar Vertical
				lnTotalColumnsWidth = lnTotalColumnsWidth + SCROLLBARS_WIDTH
			EndIf

			.Width = lnTotalColumnsWidth
			.nOriginalWidth = lnTotalColumnsWidth

		Endif
	EndWith
	
Catch To oErr
	Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
	loError = Newobject( "ErrorHandler", "ErrorhandlerPrg\ErrorHandler.prg" )
	loError.Cremark = lcCommand
	loError.Process( oErr )
	Throw loError

Finally
	loItem = Null
	loColumn = Null
	
	
EndTry

ENDPROC
PROCEDURE cfitcolumn_access

Local loData
Local loColFilter As ColFilters Of "fw\tieradapter\comun\prxbaselibrary.prg"
Local loFilter As oFilter Of "fw\tieradapter\comun\prxbaselibrary.prg"
Local loColData As PrxCollection Of fw\tieradapter\comun\prxbaselibrary.prg
Local loField As oGridLayout Of "Fw\comunes\Prg\colGridLayout.Prg"
Local lcCommand as String

Try

	lcCommand = ""

    With This As prxactiongrid Of fw\Comunes\vcx\prxmainform.vcx
        If Empty( .cFitColumn ) And ! .lIsCheckFitColumn
            loColFilter = Newobject( 'ColFilters', 'fw\tieradapter\comun\prxbaselibrary.prg' )
            loFilter = loColFilter.New ( 'FiltroFitColumn' )
            loFilter.cField = 'lFitColumn'
            loFilter.cOperator = '='
            loFilter.cExpr = '.T.'
            loColData = .oColGridLayout.Where ( loColFilter )
            If loColData.Count > 0
            	loField = loColData.Item(1)
				.cFitColumn = loField.Name
            EndIf

            .lIsCheckFitColumn = .T.

        Endif && Empty( .cFitColumn ) And ! .lIsCheckFitColumn

    Endwith

Catch To oErr
	Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
	loError = Newobject( "ErrorHandler", "ErrorhandlerPrg\ErrorHandler.prg" )
	loError.Cremark = lcCommand
	loError.Process( oErr )
	Throw loError

Finally
    loColFilter = Null
    loFilter = Null
    loColData = Null
	
	
EndTry

Return This.cFitColumn

ENDPROC
PROCEDURE classbeforeempty

Return .T.

ENDPROC
PROCEDURE classbeforefill

Return .T.

ENDPROC
PROCEDURE cmaincursorname_access
return This.cMainCursorName

ENDPROC
PROCEDURE columnmouseenter
Lparameters tnButton As Number, tnShift As Number, tnXCoord As Number, tnYCoord As Number

#INCLUDE "FW\TierAdapter\Include\TA.h"

Local lcCommand As String

Try

	lcCommand = ""

	Debugout Datetime(), Program()

	If Inlist( Thisform.nStatus, IS_EDITING, IS_READING )
		This.SetAll( 'MousePointer', 15 )

	Else && Inlist( Thisform.nStatus, IS_EDITING, IS_READING )
		This.SetAll( 'MousePointer', 0 )

	Endif && Inlist( Thisform.nStatus, IS_EDITING, IS_READING )


Catch To oErr
	This.SetAll( 'MousePointer', 0 )
	
Finally


Endtry

ENDPROC
PROCEDURE columnmouseleave
Lparameters tnButton As Number, tnShift As Number, tnXCoord As Number, tnYCoord As Number

Debugout Datetime(), Program()

This.SetAll( 'MousePointer', 0 )

ENDPROC
PROCEDURE empty
Local loColumn As Column
	
Local lcCommand as String

Try

	lcCommand = ""
	With This As prxactiongrid Of fw\comunes\vcx\prxmainform.vcx
		If .ClassBeforeEmpty()
			If .HookBeforeEmpty()
				* Apago todo antes, para despues volver a conectarlo
				For Each loColumn In .Columns
					With loColumn As Column
						.ReadOnly = !This.lCanUpdate
						.ControlSource = ''
						
					EndWith
					
				Next
				
				* .RecordSource = ''
				
				.Refresh()
				.HookAfterEmpty()
				.ClassAfterEmpty()
				
			Endif
		Endif
	EndWith

Catch To oErr
	Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
	loError = Newobject( "ErrorHandler", "ErrorhandlerPrg\ErrorHandler.prg" )
	loError.Cremark = lcCommand
	loError.Process( oErr )
	Throw loError

Finally
	loColumn = Null
	
	
EndTry
	

ENDPROC
PROCEDURE fill

Local lnColumns As Integer
Local i As Integer
Local q As Integer
Local llLockScreen As Boolean
Local llDone As Boolean
Local lcAsociatedCursor As String
Local laColumnWidth[ 1 ] As Integer
Local llRestoreColW As Boolean

Local lcCommand As String

Try

	lcCommand = ""

	llLockScreen = Thisform.LockScreen
	Thisform.LockScreen = .T.
	llRestoreColW = .F.

	With This As prxactiongrid Of fw\comunes\vcx\prxmainform.vcx
		If .ClassBeforeFill()
			If .HookBeforeFill()

				lcAsociatedCursor = This.cMainCursorName

				If Used( lcAsociatedCursor )
					If .ColumnCount > 0
						* Guardo la configuración de las columnas, para restaurarlas despues
						Dimension laColumnWidth[ .ColumnCount ]
						Store 0 To laColumnWidth
						For q = 1 To .ColumnCount
							With .Columns[ q ] As Column
								laColumnWidth[ q ] = .Width
								* Apago todo antes, para despues volver a conectarlo
								.ReadOnly = !This.lCanUpdate
								.ControlSource = ''

							Endwith

						Endfor
						llRestoreColW = .T.

					Endif && .ColumnCount > 0

					* Builds the grid
					llDone = .F.

					* A veces quedaba una columna, pese a que ColumnCount = 0
					* Con esto me aseguro de eliminar todas las columnas (RA: 01/10/2008)
					Do While ! llDone
						Try
							loColumn = .Columns( 1 )
							.RemoveObject( loColumn.Name )
						Catch To oErr
							llDone = .T.
						Finally
						Endtry
					Enddo



					.ColumnCount = -1
					.RecordSource = ""

					lnColumns = .oColGridLayout.Count

					.ColumnCount = lnColumns

					.RecordSource = lcAsociatedCursor

					lnGridWidth = 0


					For q = 1 To lnColumns
						With .Columns[ q ] As Column
							.ReadOnly = !This.lCanUpdate
							This.PerformLayout( This.Columns[ q ], This.oColGridLayout.Item( q ) )
							.ControlSource = lcAsociatedCursor + "." + .ControlSource
							If This.lCastDateTime
								If Vartype( Evaluate( .ControlSource ) ) == "T"
									.ControlSource = "=Ttod( " + .ControlSource + " )"

								Endif && Vartype( Evaluate( .ControlSource ) ) == "T"

							Endif && This.CastDateTime

							If Vartype( Evaluate( .ControlSource ) ) == "C"
								loGridLayout = This.oColGridLayout.Item( q )
								If loGridLayout.IsNumeric
									.ControlSource = "Val( " + .ControlSource + " )"

								Endif && loGridLayout.IsNumeric

							Endif && Vartype( Evaluate( .ControlSource ) ) == "C"

						Endwith
					Next

					.Refresh()

					If lnColumns = 1
						* Si muestro una sola columna, saco las líneas divisorias y pongo
						* el ancho de la columna al máximo
						.GridLines = 0
						.Columns[ 1 ].Width = This.Width
					Else && lnColumns = 1
						.GridLines = 2
					Endif && lnColumns = 1

					If llRestoreColW
						* Restauro la configuración de las columnas que pudiera
						* haber hecho el usuario
						Try
							For q = 1 To .ColumnCount
								.Columns[ q ].Width = laColumnWidth[ q ]

							Endfor
						Catch To oErr
							* Si algo falla ....
							.AutoFit()

						Finally
						Endtry
					Endif && llRestoreColW


					.AdjustFitColumn()
					.Refresh()

				Endif

				.HookAfterFill()
				.ClassAfterFill()

			Endif
		Endif
	Endwith

Catch To oErr
	Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
	loError = Newobject( "ErrorHandler", "ErrorhandlerPrg\ErrorHandler.prg" )
	loError.Cremark = lcCommand
	loError.Process( oErr )
	Throw loError

Finally
	Thisform.LockScreen = llLockScreen
	loGridLayout = Null

Endtry


ENDPROC
PROCEDURE handlesearch
Lparameters tnKeyCode As Integer

Local lcCommand as String

Try

	lcCommand = ""
	
    With This As prxactiongrid Of FW\Comunes\vcx\prxmainform.vcx
        * If the time of the last keystroke exceeded
        * Incremental Seek setting, then reinitialize buffer
        If ( Seconds() - .nLastKeystroke ) > _Incseek
            .cSearchBuffer = ''

        EndIf && ( Seconds() - .nLastKeystroke ) > _Incseek
        * Stores this keystroke time
        .nLastKeystroke = Seconds()
        .cSearchBuffer = .cSearchBuffer + Upper( Chr( tnKeyCode ) )
        Select ( .RecordSource )
        * @TODO Chequear si no hay indice activo  si se puede realizar la busqueda
        *		En el modelo nuevo los indices no servirian
        *		para la busqueda, si los armamos con una expresion compuesta.
        If Empty( Key() )
            * No active index

        Else && Empty( Key() )
            * @TODO Se pueden implementar busquedas mas inteligentes utilizando el operador like
            * If the active index is of character type, then search
            If Type( Key() ) = "C"
                Seek .cSearchBuffer
                .Refresh()

            EndIf && Type( Key() ) = "C"

        EndIf && Empty( Key() )
    EndWith


Catch To oErr
	Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
	loError = Newobject( "ErrorHandler", "ErrorhandlerPrg\ErrorHandler.prg" )
	loError.Cremark = lcCommand
	loError.Process( oErr )
	Throw loError

Finally
	
	
EndTry

ENDPROC
PROCEDURE hookbeforeempty

Return .T.

ENDPROC
PROCEDURE hookbeforefill

Return .T.

ENDPROC
PROCEDURE nupdatefontsize_assign
Lparameters tuNewValue As Integer

Local lnFS0 As Integer
Local lnFS1 As Integer
Local loColumn As Column
Local lcCommand as String

Try

	lcCommand = ""

    With This As prxactiongrid Of fw\comunes\vcx\prxmainform.vcx
        For Each loColumn In .Columns
            Try
                lnFS0 = loColumn.FontSize
                lnFS1 = loColumn.Controls[ 1 ].FontSize
                loColumn.FontSize = loColumn.FontSize + tuNewValue
                loColumn.Controls[ 1 ].FontSize = loColumn.Controls[ 1 ].FontSize + tuNewValue
                If tuNewValue >= 0
                    loColumn.Width = Round( loColumn.Width * 1.1, 0 )
                Else
                    loColumn.Width = Round( loColumn.Width * 0.9, 0 )
                Endif
            Catch To oErr
                loColumn.FontSize = lnFS0
                loColumn.Controls[ 1 ].FontSize = lnFS1
            Finally
            Endtry
        Endfor
    EndWith

Catch To oErr
	Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
	loError = Newobject( "ErrorHandler", "ErrorhandlerPrg\ErrorHandler.prg" )
	loError.Cremark = lcCommand
	loError.Process( oErr )
	Throw loError

Finally
    loColumn = Null
    This.nUpdateFontSize = tuNewValue
	
	
EndTry

ENDPROC
PROCEDURE ocolgridlayout_access
Local lcCommand As String

Try

	lcCommand = ""

	With This As prxactiongrid Of FW\Comunes\vcx\prxmainform.vcx
		If Vartype( .oColGridLayout ) # 'O'
			.oColGridLayout = Newobject( "colGridLayout",  ;
				"Fw\Comun\Prg\colGridLayout.prg" )

			.SetGridLayout()

		Endif && Vartype( .oColGridLayout ) # 'O'

	Endwith

Catch To oErr
	Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
	loError = Newobject( "ErrorHandler", "ErrorhandlerPrg\ErrorHandler.prg" )
	loError.Cremark = lcCommand
	loError.Process( oErr )
	Throw loError

Finally

Endtry


Return This.oColGridLayout

ENDPROC
PROCEDURE otable_access
If Isnull( This.oTable )
	This.oTable = This.DefineTable()
Endif

Return This.oTable

ENDPROC
PROCEDURE performlayout
Lparameters toColumn As Column, toParam As oGridLayout Of "Fw\Comunes\Prg\colGridLayout.Prg"

#INCLUDE "FW\Comunes\Include\Praxis.h"

Local laMember[1]
* Local lnLen As Integer
Local i As Integer
Local lcSourceProperty As String
Local lcTargetProperty As String
Local lcPrefix As String
Local loControl As Object

Local lcCommand as String

Try

	lcCommand = ""
	
	* lnLen = Amembers( laMember, toParam, 0, "U" )
	* For i = 1 To lnLen
	For i = 1 To Amembers( laMember, toParam, 0, "U" )
		Try
			lcSourceProperty = laMember[ i ]
			lcTargetProperty = Substr( lcSourceProperty, 7 )
			lcPrefix = Lower( Substr( lcSourceProperty, 1, 6 ) )

			Do Case
				Case lcPrefix == "header"
					toColumn.Controls[1].&lcTargetProperty = toParam.&lcSourceProperty

				Case lcPrefix  == "column"
					toColumn.&lcTargetProperty = toParam.&lcSourceProperty

				Case Lower( lcSourceProperty ) == 'ocurrentcontrol'

					If ! IsEmpty( toParam.oCurrentControl )

						If ! ( Lower( toColumn.CurrentControl ) == Lower( toParam.oCurrentControl.Name ) )
							toColumn.RemoveObject( toColumn.CurrentControl )
							toColumn.Newobject( toParam.oCurrentControl.Name,;
								toParam.oCurrentControl.Name,;
								toParam.oCurrentControl.Class )

							lcControlName = toParam.oCurrentControl.Name
							toColumn.&lcControlName..Visible = .T.

							toColumn.CurrentControl = toParam.oCurrentControl.Name

						Endif && ! ( Lower( toColumn.CurrentControl ) == Lower( toParam.oCurrentControl.Name ) )

					Endif && ! IsEmpty( toParam.oCurrentControl )

				Otherwise
			EndCase
			
		Catch To oErr
			Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
			loError = Newobject( "ErrorHandler", "ErrorhandlerPrg\ErrorHandler.prg" )
			loError.Ctracelogin = 'Source Property: ' + lcSourceProperty + CR ;
				+ 'Target Property: ' + lcTargetProperty + CR ;
				+ 'Prefix: ' + lcPrefix

			loError.Cremark = lcCommand
			loError.Process( oErr )
			

		Finally
		EndTry
		
	EndFor
	
	AddProperty( toColumn, "oField", toParam.oField )
	AddProperty( toColumn, "Check", toParam.oField.cCheck )
	If !Empty( toColumn.Check )
		toColumn.Check = Strtran( toColumn.Check,;
			toParam.oField.Name,;
			"loCurrentControl.Value",;
			-1,;
			-1,;
			1 )
	Endif
	
	
	If toParam.lFitColumn
		This.cFitColumn = toParam.ColumnName
	Endif && toParam.lFitColumn

	For Each loControl In toColumn.Controls
		If Lower( loControl.BaseClass ) == "header"
			* Nothing to do for Headers
		Else && loControl.BaseClass = "Header"
			* Binds all the controls' *Click events to the grid's
			If Pemstatus( loControl, "Click", 5 )
				Bindevent( loControl, "Click", This, "Click" )

			Endif && Pemstatus( loControl, "Click", 5 )

			If Pemstatus( loControl, "DblClick", 5 )
				Bindevent( loControl, "DblClick", This, "DblClick" )

			Endif && Pemstatus( loControl, "DblClick", 5 )

			If Pemstatus( loControl, "RightClick", 5 )
				Bindevent( loControl, "RightClick", This, "RightClick" )

			Endif && Pemstatus( loControl, "RightClick", 5 )

			If Pemstatus( loControl, "KeyPress", 5 )
				Bindevent( loControl, "KeyPress", This, "KeyPress" )

			Endif && Pemstatus( loControl, "KeyPress", 5 )

			If Pemstatus( loControl, "MouseEnter", 5 )
				Bindevent( loControl, "MouseEnter", This, "ColumnMouseEnter" )

			Endif && Pemstatus( loControl, "MouseEnter", 5 )

			If Pemstatus( loControl, "MouseLeave", 5 )
				Bindevent( loControl, "MouseLeave", This, "ColumnMouseLeave" )

			Endif && Pemstatus( loControl, "MouseLeave", 5 )

		Endif && loControl.BaseClass = "Header"

	Next
	

Catch To oErr
	Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
	loError = Newobject( "ErrorHandler", "ErrorhandlerPrg\ErrorHandler.prg" )
	loError.Cremark = lcCommand
	loError.Process( oErr )
	Throw loError

Finally
	loControl = Null
	
EndTry
	
ENDPROC
PROCEDURE setgridlayout
*!*	Local loField As oField Of "Tools\Sincronizador\colDataBases.prg"
*!*	Local loFieldAux As oField Of "Tools\Sincronizador\colDataBases.prg"
*!*	Local loTable As oTable Of "Tools\Sincronizador\colDataBases.prg"
Local loGridLayout As oGridLayout Of "Fw\Comunes\Prg\colGridLayout.prg"
Local loColData As PrxCollection Of fw\tieradapter\comun\prxbaselibrary.prg
*!*	Local loColFields As ColFields Of "Tools\Sincronizador\colDataBases.prg"

Local loColTables As oColTables Of "Tools\DataDictionary\Prg\oColTables.prg"
Local loTable As oTable Of "Tools\DataDictionary\Prg\oTable.prg"
Local loColFields As oColFields Of "Tools\DataDictionary\Prg\oColFields.prg"
Local loField As oField Of "Tools\DataDictionary\Prg\oField.prg"
Local loFieldAux As oField Of "Tools\DataDictionary\Prg\oField.prg"
Local loColIndexes As oColIndexes Of "Tools\DataDictionary\Prg\oColIndexes.prg"


*
Local lcName As String
Local lcWhere As String
*
Local lnCnt As Integer
Local i As Integer
Local j As Integer
Local lnIndex As Integer

Local lcCommand As String

Try

	lcCommand = ""

	lnCnt = 0

	* Obtengo la tabla
	loTable = This.oTable

	*!*	lcWhere = 'lShowInGrid = .T. '
	lcWhere = ' nGridOrder # 0 '

	loColData =  loTable.oColFields.Query( "", 0, .F., "", lcWhere, .F., 'nGridOrder' )

	For i = 1 To loColData.Count
		loField = loColData.Item[ i ]
		lnCnt = lnCnt + 1 && Contador para ver cuantos Objetos se han procesado

		If .F. && ! Empty( loField.References )
			* RA 2012-04-14(09:49:27)
			* Por ahora no analizo las referencias
			
			loTable = loColTables.GetItem( loField.References )
			loColFields = loTable.oColFields.Query( '', 0, .F., '', ' nDefaultReference # 0 ', .F., 'nDefaultReference' )
			For j = 1 To loColFields.Count
				loFieldAux = loColFields.Item[ j ]
				* DA 2009-07-15(11:55:58)
				* Tomo la configuración del campo original sin importar si se reemplazó
				= loFieldAux.cCaption
				lcName = Lower( loField.References + loFieldAux.Name )
				lnIndex = .oColGridLayout.GetKey( lcName )
				If Empty( lnIndex )
					loGridLayout = .oColGridLayout.NewFromField( loFieldAux, lcName )

					If .lHasDefault
						loGridLayout.ColumnDynamicFontBold = 'Iif( Default = 1, .T., .F. )'

					Endif && .lHasDefault

					* DA 2009-07-15(11:55:58)
					* Tomo la configuración del campo original sin importar si se reemplazó
					loGridLayout.lFitColumn = loFieldAux.lFitColumn
					loGridLayout.Width = Iif( loField.nGridOrder > 0, loGridLayout.Width, 0 )
					loGridLayout.ColumnWidth = Iif( loField.nGridOrder > 0, loGridLayout.ColumnWidth, 0 )

				Endif && Empty( lnIndex )

			Endfor

		Else && ! Empty( loField.References )
			loFieldAux = loField
			lcName = Lower( loFieldAux.Name )
			lnIndex = .oColGridLayout.GetKey( lcName )
			If Empty( lnIndex )
				* DA 2009-07-15(11:55:58)
				* Tomo la configuración del campo original sin importar si se reemplazó
				= loFieldAux.cCaption
				loGridLayout = .oColGridLayout.NewFromField( loFieldAux, lcName )

*!*					If .lHasDefault
*!*						loGridLayout.ColumnDynamicFontBold = 'Iif( Default = 1, .T., .F. )'

*!*					Endif && .lHasDefault

				* DA 2009-07-15(11:55:58)
				* Tomo la configuración del campo original sin importar si se reemplazó
				loGridLayout.lFitColumn = loFieldAux.lFitColumn
				loGridLayout.Width = Iif( loFieldAux.nGridOrder > 0, loGridLayout.Width, 0 )
				loGridLayout.ColumnWidth = Iif( loFieldAux.nGridOrder > 0, loGridLayout.ColumnWidth, 0 )

			Endif && Empty( lnIndex )

		Endif && ! Empty( loField.References )

	Endfor


Catch To oErr
	Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
	loError = Newobject( "ErrorHandler", "ErrorhandlerPrg\ErrorHandler.prg" )
	loError.Cremark = lcCommand
	loError.Process( oErr )
	Throw loError

Finally
	loField = Null
	loFieldAux = Null
	loTable = Null
	loGridLayout = Null
	loColData = Null
	

Endtry

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
casociatedcursor Nombre del Cursor Asociado. Es el cursor real, sobre el que se replican todas las acciones.
lcastdatetime Indica si convierte los campos DateTime a Date, antes de mostrarlos en la grilla
gridautofit Indica si la grilla ejecuta el metodo Autofit() en forma automática
nlastkeystroke Guarda el momento en que se precionó la última tecla
csearchbuffer Guarda el string de búsqueda
order Indica el número de la columna por la que se ordena la grilla
nupdatefontsize
rowsperpage Cantidad de líneas a mostrar. Si está en 0, se utiliza el valor declarado en la UserTier para la entidad.
cfitcolumn Nombre de la Columna que absorbe las diferencias en el ancho para que ajuste perfecto
performautosetup Indeica si la grilla se adapta automáticamente a la colección oColLayout
nlastrow
ocolgridlayout
noriginalwidth
lischeckfitcolumn
otable Tabla asociada a la grilla
cmaincursorname
lcanupdate Indica como se seta por default la propiedad ReadOnly de las columnas al crearse dinamicamente
*handlesearch Búsqueda incremental dentro de la columna activa
*nupdatefontsize_assign 
*performlayout Obtiene las propiedades para cada columna de la colección This.oColLayout
*adjustfitcolumn Ajusta el ancho de la columna indicada en FitColumn
*fill Llena la grilla con datos
*classbeforefill 
*classafterfill 
*hookbeforefill 
*hookafterfill 
*empty Vacia los datos de la grilla
*classbeforeempty 
*classafterempty 
*hookbeforeempty 
*hookafterempty 
*ocolgridlayout_access 
*cfitcolumn_access 
*columnmouseenter 
*columnmouseleave 
*setgridlayout Define los campos de la grilla asociada a partir de una tabla
*otable_access 
*definetable Define el objeto oTable
*cmaincursorname_access 
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] prxactiongrid
[START PROPERTIES]
Arial, 0, 9, 5, 15, 12, 32, 3, 0
[END PROPERTIES]
[START RESERVED1]
  ..\include\praxis.höìs~\V ..\include\foxpro.hþíÊrûF ..\include\strings.hïZOJ* ..\..\..\tools\namespaces\include\system.hð±ÙF ..\..\tieradapter\include\ta.hñîU[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Y50ZVU4W
[CLASS] optionpanelbase
[CLASSLOC] prxmainform.vcx
[BASECLASS] container
[OBJNAME] optionpanel
[START PROPERTIES]
Width = 578
Height = 44
StatusBarText = "Seleccionar una acción a ejecutar"
obuttons = Null
ntoppadding = 8
_memberdata =     1024<VFPData><memberdata name="autofit" type="method" display="Autofit"/><memberdata name="nGap" type="property" display="nGap"/><memberdata name="lautofit" type="property" display="lAutofit"/><memberdata name="lautosetup" type="property" display="lAutoSetup"/><memberdata name="samerowasprevious" type="property" display="SameRowAsPrevious" favorites="True"/><memberdata name="fittoparent" type="method" display="FitToParent"/><memberdata name="nupdatefontsize" type="property" display="nUpdateFontSize"/><memberdata name="nupdatefontsize_assign" type="method" display="nUpdateFontSize_Assign"/><memberdata name="nBottomPadding" type="Property" favorites="True"/><memberdata name="synchronizebuttons" type="method" display="SynchronizeButtons"/><memberdata name="obuttons" type="property" display="oButtons"/><memberdata name="obuttons_access" type="method" display="oButtons_Access"/><memberdata name="setbuttons" type="method" display="SetButtons"/><memberdata name="lisactive" type="property" display="lIsActive"/></VFPData>
lfittoparent = .T.
nfitmode = 12
Name = "optionpanel"
Shape.Top = 14
Shape.Left = -100
Shape.Height = 125
Shape.Width = 95
Shape.Name = "Shape"
shpLabel.Top = -498
shpLabel.Left = -492
shpLabel.Height = 20
shpLabel.Width = 131
shpLabel.Visible = .F.
shpLabel.Name = "shpLabel"
lblTitulo.Caption = "Opciones"
lblTitulo.Height = 23
lblTitulo.Left = -492
lblTitulo.Top = -498
lblTitulo.Visible = .F.
lblTitulo.Width = 107
lblTitulo.TabIndex = 1
lblTitulo.Name = "lblTitulo"
[END PROPERTIES]
[START METHODS]
PROCEDURE classafterautosetup
Lparameters tlOnlyPosition As Boolean

#INCLUDE "FW\Comunes\Include\Praxis.h"

Local loButton As CommandButton
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try

	With This As OptionPanel Of FW\Comunes\vcx\prxmainform.vcx
		.AnchorStatus( .T. )
		.ZOrder( 1 )
		.BorderWidth = 0
		.BackColor = .Parent.BackColor
	Endwith

	With This.Shape As Shape
		.Top = 0
		.Height = This.Height
		.Left = 0
		.Width = This.Width
		.BackColor = .Parent.BackColor
		.ZOrder( 1 )
		.Anchor = ANCHOR_Top_Absolute ;
			+ ANCHOR_Left_Absolute ;
			+ ANCHOR_Bottom_Absolute ;
			+ ANCHOR_Right_Absolute
	Endwith

	With This.lblTitulo As Label
		.Top = 0
		.Left = This.Shape.Left + ( .Height / 2 )
		.BackColor = .Parent.BackColor
		.DisabledBackColor = Thisform.BackColor
	Endwith

	With This.shpLabel As Shape
		.Top = 0
		.Left = This.lblTitulo.Left
		.Visible = This.lblTitulo.Visible
	Endwith

	This.AnchorStatus( .F. )

	For Each loButton In This.Objects
		If Lower( loButton.BaseClass ) == 'commandbutton' ;
				And loButton.Visible

			Do Case
				Case Inlist( Lower( loButton.Name ), 'cmdclose', 'cmdReport' )
					loButton.Anchor = ANCHOR_Left_Absolute

				Otherwise
					loButton.Anchor = ANCHOR_Right_Absolute

			Endcase
		Endif
	EndFor
	
	This.cmdNew.TabIndex 	= 1
	This.cmdOpen.TabIndex 	= 2
	This.cmdEdit.TabIndex 	= 3
	This.cmdSave.TabIndex 	= 4
	This.cmdClose.TabIndex 	= 5
	This.cmdDelete.TabIndex = 6
	This.cmdReport.TabIndex = 7

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = Null

Endtry

ENDPROC
PROCEDURE classafterinit

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try

    DoDefault()
    Bindevent( Thisform.oGlobalSettings.oApp, 'SynchronizeButtons', This, 'SetButtons' )

Catch To oErr
    loError = Thisform.oError
    Thisform.cXMLoError = loError.Process( oErr )
    Throw loError
Finally
    loError = Null
Endtry

ENDPROC
PROCEDURE classbeforeautosetup
Lparameters tlOnlyPosition As Boolean

With This As OptionPanel Of FW\Comunes\vcx\prxmainform.vcx
	.SetAll( 'lSameRowAsPrevious', .T. )
	If ! tlOnlyPosition
		* Delete
		.CmdDelete.Visible = ! Thisform.lIsChildForm

		* Edit
		.cmdEdit.Visible = ! Thisform.lIsChildForm

		* New
		.CmdNew.Visible = ! Thisform.lIsChildForm

		* Abrir
		.CmdOpen.Visible = ! Thisform.lIsChildForm

		* Report
*!*			.CmdReport.Visible = ! Thisform.lIsChildForm
		* DA 2009-11-09(12:06:44)
		.CmdReport.Visible = .CmdReport.Visible And ! Thisform.lIsChildForm

	Endif
Endwith

Return DoDefault( tlOnlyPosition )

ENDPROC
PROCEDURE nupdatefontsize_assign
Lparameters tuNewValue As Integer

Local loCtrl As Object
Local lnOldUpdateFontSize As Integer
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
    Try
        lnOldUpdateFontSize = This.nUpdateFontSize
        This.nUpdateFontSize = tuNewValue
    Catch To oErr
        This.nUpdateFontSize = lnOldUpdateFontSize
    Endtry

    For Each loCtrl In This.oColObjects
        loCtrl.FontSize = loCtrl.FontSize + This.nUpdateFontSize
    Endfor
    * This.AutoSetup()
Catch To oErr
    loError = Thisform.oError
    Thisform.cXMLoError = loError.Process( oErr )
    Throw loError
Finally
    loError = Null
Endtry

ENDPROCPROCEDURE obuttons_access

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"

Try
    With This As optionpanel Of fw\comunes\vcx\prxmainform.vcx
        If Vartype( .oButtons ) # "O"
            .oButtons = Thisform.oGlobalSettings.oApp.oButtons
        Endif
    Endwith
Catch To oErr
    loError = Thisform.oError
    Thisform.cXMLoError = loError.Process( oErr )
    Throw loError
Finally
    loError = Null
Endtry

Return This.oButtons


ENDPROC
PROCEDURE releaseobjects

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
    DoDefault()
    This.oButtons = Null
    Unbindevent( Thisform.oGlobalSettings.oApp, 'SynchronizeButtons', This, 'SetButtons' )
Catch To oErr
    loError = Thisform.oError
    Thisform.cXMLoError = loError.Process( oErr )
    Throw loError
Finally
    loError = Null
Endtry

ENDPROC
PROCEDURE setbuttons

#INCLUDE "FW\Tieradapter\Include\TA.h"

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
	With This As OptionPanel Of FW\Comunes\vcx\prxmainform.vcx
		
			* DAE 2009-06-30 (16:57:34)
			* Siempre esta activo Cambia el label dependiendo el estado
			.CmdClose.Enabled = Thisform.lIsActive And .oButtons.Close And .CmdClose.lVisible
			.CmdClose.Caption = Iif( ( Thisform.nStatus = IS_EDITING ), 'Cancelar', 'Cerrar' )

			* Delete
			.CmdDelete.Enabled = Thisform.lIsActive And .oButtons.Delete And .CmdDelete.lVisible
			.CmdDelete.Visible = ! Thisform.lIsChildForm And .CmdDelete.lVisible

			* Edit
			.cmdEdit.Enabled = Thisform.lIsActive And .oButtons.Edit And .cmdEdit.lVisible
			.cmdEdit.Visible = ! Thisform.lIsChildForm And .cmdEdit.lVisible

			* New
			.CmdNew.Enabled = Thisform.lIsActive And .oButtons.New And .CmdNew.lVisible
			.CmdNew.Visible = ! Thisform.lIsChildForm And .CmdNew.lVisible

			* Abrir
			.CmdOpen.Enabled = Thisform.lIsActive And .oButtons.Open And .CmdOpen.lVisible
			.CmdOpen.Visible = ! Thisform.lIsChildForm And .CmdOpen.lVisible

			* Report
			.CmdReport.Enabled = Thisform.lIsActive And .oButtons.Report And .CmdReport.lVisible
			.CmdReport.Visible = ! Thisform.lIsChildForm And .CmdReport.lVisible

			* Save
			.CmdSave.Enabled = Thisform.lIsActive And .oButtons.Save And .CmdSave.lVisible
			.CmdSave.Caption = Iif( Thisform.lIsChildForm, Iif( Thisform.nProcessType = TR_DELETE, 'Confirma', 'Aplicar' ), 'Grabar' )
			.CmdSave.Picture = Iif( Thisform.lIsChildForm, 'Fw\Comunes\Image\bmp\ok.bmp', 'Fw\Comunes\Image\bmp\save.bmp' )
			.CmdSave.DisabledPicture = Iif( Thisform.lIsChildForm, 'Fw\Comunes\Image\bmp\ok.bmp', 'Fw\Comunes\Image\bmp\#save.bmp' )
	Endwith
Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr, .T. )
	* No propago el error porque estoy conectado mediante BindEvents
	* Throw loError
Finally
	loError = Null
Endtry


ENDPROC
PROCEDURE synchronizebuttons
Lparameters nStatus As Integer

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
8[END RESERVED2]
[START RESERVED3]
obuttons Estado de los botones
*synchronizebuttons 
*obuttons_access 
*setbuttons Setea el estado de los botones
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Y5101JEP
[CLASS] close
[CLASSLOC] buttons.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdClose
[PARENT] optionpanel
[START PROPERTIES]
AutoSize = .F.
Top = 10
Left = 4
Height = 27
Width = 78
TabIndex = 2
SpecialEffect = 2
lautosetup = .T.
Name = "cmdClose"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Y50ZVU4W
[CLASS] delete
[CLASSLOC] buttons.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdDelete
[PARENT] optionpanel
[START PROPERTIES]
AutoSize = .F.
Top = 10
Left = 409
Height = 27
Width = 78
TabIndex = 7
SpecialEffect = 2
lautosetup = .T.
Name = "cmdDelete"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Y5101JER
[CLASS] new
[CLASSLOC] buttons.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdNew
[PARENT] optionpanel
[START PROPERTIES]
AutoSize = .F.
Top = 10
Left = 166
Height = 27
Width = 78
Caption = "Nuevo"
TabIndex = 4
SpecialEffect = 2
lautosetup = .T.
Name = "cmdNew"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Y5101JES
[CLASS] save
[CLASSLOC] buttons.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdSave
[PARENT] optionpanel
[START PROPERTIES]
AutoSize = .F.
Top = 10
Left = 490
Height = 27
Width = 78
Caption = "\<Grabar"
TabIndex = 8
SpecialEffect = 2
lautosetup = .T.
Name = "cmdSave"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1ZA0SS7XU
[CLASS] open
[CLASSLOC] buttons.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdOpen
[PARENT] optionpanel
[START PROPERTIES]
AutoSize = .F.
Top = 10
Left = 247
Height = 27
Width = 78
Caption = "\<Abrir"
TabIndex = 5
SpecialEffect = 2
lautosetup = .T.
Name = "cmdOpen"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _25X0PYZKP
[CLASS] report
[CLASSLOC] buttons.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdReport
[PARENT] optionpanel
[START PROPERTIES]
AutoSize = .F.
Top = 10
Left = 85
Height = 27
Width = 78
TabIndex = 3
SpecialEffect = 2
lautosetup = .T.
Name = "cmdReport"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2ND0X6MOM
[CLASS] edit
[CLASSLOC] buttons.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdEdit
[PARENT] optionpanel
[START PROPERTIES]
AutoSize = .F.
Top = 10
Left = 328
Height = 27
Width = 78
TabIndex = 6
SpecialEffect = 2
lautosetup = .T.
Name = "cmdEdit"
[END PROPERTIES]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] optionpanel
[START PROPERTIES]
Arial, 0, 9, 5, 15, 12, 32, 3, 0
[END PROPERTIES]
[START RESERVED1]
  ..\..\tieradapter\include\ta.h^SîU ..\include\praxis.hfTs~\V ..\include\foxpro.hnUÊrûF ..\include\strings.hvVZOJ* ..\..\..\tools\namespaces\include\system.h~W±ÙF[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1YH0LB9WS
[CLASS] ccmarco
[CLASSLOC] controles_varios.vcx
[BASECLASS] container
[OBJNAME] abmchildcontainer
[START PROPERTIES]
Width = 458
Height = 280
TabIndex = 2
childformname = 
keeponinserting = .T.
buttonsposition = 2
editingcursorpk = 
lkeeponinserting = .T.
nreccount = 0
nmaxrec = 999999
nminrec = 0
oparent = .NULL.
cparentconfigurationkey = 
oldentidadid = 
activecount = 0
ckeyname = 
hijos = .NULL.
caliasconfigurationkey = 
lischild = .F.
cdataconfigurationkey = 
oimagelist = .NULL.
oentity = .NULL.
_memberdata =     8161<VFPData><memberdata name="autofit" type="method" display="Autofit"/><memberdata name="nGap" type="property" display="nGap"/><memberdata name="lautofit" type="property" display="lAutofit"/><memberdata name="lautosetup" type="property" display="lAutoSetup"/><memberdata name="samerowasprevious" type="property" display="SameRowAsPrevious" favorites="True"/><memberdata name="deletechild" type="method" display="DeleteChild"/><memberdata name="editchild" type="method" display="EditChild"/><memberdata name="addchild" type="method" display="AddChild"/><memberdata name="newchild" type="method" display="NewChild"/><memberdata name="contextualmenu" type="method" display="ContextualMenu"/><memberdata name="fillgrid" type="method" display="FillGrid"/><memberdata name="deletevalid" type="method" display="DeleteValid"/><memberdata name="deletehook" type="method" display="DeleteHook"/><memberdata name="childformname" type="property" display="ChildFormName" favorites="True"/><memberdata name="serialize" type="method" display="Serialize"/><memberdata name="getdata" type="method" display="GetData"/><memberdata name="keeponinserting" type="property" display="KeepOnInserting" favorites="True"/><memberdata name="emptygrid" type="method" display="EmptyGrid"/><memberdata name="buttonsposition" type="property" display="ButtonsPosition" favorites="True"/><memberdata name="synchronizebuttons" type="method" display="SynchronizeButtons"/><memberdata name="applydiffgram" type="method" display="ApplyDiffgram"/><memberdata name="update" type="method" display="Update"/><memberdata name="getone" type="method" display="GetOne"/><memberdata name="launch" type="method" display="Launch"/><memberdata name="editingcursorname" type="property" display="EditingCursorName" favorites="True"/><memberdata name="editingcursorpk" type="property" display="EditingCursorPK" favorites="True"/><memberdata name="editingcursorname_access" type="method" display="EditingCursorName_Access"/><memberdata name="validateupdate" type="method" display="ValidateUpdate"/><memberdata name="getentityid" type="method" display="GetEntityId"/><memberdata name="filleditingrecord" type="method" display="FillEditingRecord"/><memberdata name="updateprivatecursor" type="method" display="UpdatePrivateCursor"/><memberdata name="updateasociatedcursor" type="method" display="UpdateAsociatedCursor"/><memberdata name="cconfignexttierfilename" type="property" display="cConfigNextTierFileName" favorites="True"/><memberdata name="oentity" type="property" display="oEntity"/><memberdata name="dataconfigurationkey" type="property" display="DataConfigurationKey" favorites="True"/><memberdata name="oentity_access" type="method" display="oEntity_Access"/><memberdata name="lkeeponinserting" type="property" display="lKeepOnInserting" favorites="True"/><memberdata name="nreccount" type="property" display="nRecCount"/><memberdata name="nreccount_assign" type="property" display="nRecCount_Assign"/><memberdata name="nmaxrec" type="property" display="nMaxRec" favorites="True"/><memberdata name="nminrec" type="property" display="nMinRec" favorites="True"/><memberdata name="grillallena" type="method" display="GrillaLlena"/><memberdata name="grillavacia" type="method" display="GrillaVacia"/><memberdata name="griilaconunregistro" type="method" display="GriilaConUnRegistro"/><memberdata name="grillaconunregistro" type="method" display="GrillaConUnRegistro"/><memberdata name="hookbeforelaunchform" type="method" display="HookBeforeLaunchForm"/><memberdata name="gridstatus" type="method" display="GridStatus"/><memberdata name="hookafterupdate" type="method" display="HookAfterUpdate"/><memberdata name="emptytree" type="method" display="EmptyTree"/><memberdata name="filltree" type="method" display="FillTree"/><memberdata name="fillcontrol" type="method" display="FillControl"/><memberdata name="emptycontrol" type="method" display="EmptyControl"/><memberdata name="llenarhijos" type="method" display="LlenarHijos"/><memberdata name="vaciarhijos" type="method" display="VaciarHijos"/><memberdata name="hijosconunregistro" type="method" display="HijosConUnRegistro"/><memberdata name="hijoslleno" type="method" display="HijosLleno"/><memberdata name="hijosvacio" type="method" display="HijosVacio"/><memberdata name="oparent" type="property" display="oParent"/><memberdata name="oparent_access" type="property" display="oParent_Access"/><memberdata name="parentconfigurationkey" type="property" display="ParentConfigurationKey" favorites="True"/><memberdata name="oldidentidad" type="property" display="OldIdEntidad"/><memberdata name="activecolumncount" type="property" display="ActiveColumnCount"/><memberdata name="activecolumncount_access" type="property" display="ActiveColumnCount_Access"/><memberdata name="new" type="method" display="New"/><memberdata name="classbeforenew" type="method" display="ClassBeforeNew"/><memberdata name="classafternew" type="method" display="ClassAfterNew"/><memberdata name="hookbeforenew" type="method" display="HookBeforeNew"/><memberdata name="hookafternew" type="method" display="HookAfterNew"/><memberdata name="edit" type="method" display="Edit"/><memberdata name="classbeforeedit" type="method" display="ClassBeforeEdit"/><memberdata name="classafteredit" type="method" display="ClassAfterEdit"/><memberdata name="hookbeforeedit" type="method" display="HookBeforeEdit"/><memberdata name="hookafteredit" type="method" display="HookAfterEdit"/><memberdata name="delete" type="method" display="Delete"/><memberdata name="classbeforedelete" type="method" display="ClassBeforeDelete"/><memberdata name="classafterdelete" type="method" display="ClassAfterDelete"/><memberdata name="hookbeforedelete" type="method" display="HookBeforeDelete"/><memberdata name="hookafterdelete" type="method" display="HookAfterDelete"/><memberdata name="open" type="method" display="Open"/><memberdata name="classbeforeopen" type="method" display="ClassBeforeOpen"/><memberdata name="classafteropen" type="method" display="ClassAfterOpen"/><memberdata name="hookbeforeopen" type="method" display="HookBeforeOpen"/><memberdata name="hookafteropen" type="method" display="HookAfterOpen"/><memberdata name="classbeforeupdate" type="method" display="ClassBeforeUpdate"/><memberdata name="classafterupdate" type="method" display="ClassAfterUpdate"/><memberdata name="hookbeforeupdate" type="method" display="HookBeforeUpdate"/><memberdata name="cancreate" type="method" display="CanCreate"/><memberdata name="canupdate" type="method" display="CanUpdate"/><memberdata name="candelete" type="method" display="CanDelete"/><memberdata name="canread" type="method" display="CanRead"/><memberdata name="cdataconfigurationkey" type="property" display="cDataConfigurationKey" favorites="True"/><memberdata name="cparentconfigurationkey" type="property" display="cParentConfigurationKey" favorites="True"/><memberdata name="setbuttons" type="method" display="SetButtons"/><memberdata name="classbeforesetbuttons" type="method" display="ClassBeforeSetButtons"/><memberdata name="classaftersetbuttons" type="method" display="ClassAfterSetButtons"/><memberdata name="hookbeforesetbuttons" type="method" display="HookBeforeSetButtons"/><memberdata name="hookaftersetbuttons" type="method" display="HookAfterSetButtons"/><memberdata name="visiblecount" type="property" display="VisibleCount"/><memberdata name="visiblecount_access" type="method" display="VisibleCount_Access"/><memberdata name="activecount" type="property" display="ActiveCount"/><memberdata name="activecount_access" type="method" display="ActiveCount_Access"/><memberdata name="cobjectfactoryfilename" type="property" display="cObjectFactoryFileName"/><memberdata name="oimagelist" type="property" display="oImageList"/><memberdata name="oimagelist_access" type="method" display="oImageList_Access"/><memberdata name="setupentity" type="method" display="SetupEntity"/><memberdata name="classbeforesetupentity" type="method" display="ClassBeforeSetupEntity"/><memberdata name="classaftersetupentity" type="method" display="ClassAfterSetupEntity"/><memberdata name="oldentidadid" type="property" display="OldEntidadId"/></VFPData>

nleftpadding = 5
nrightpadding = 5
Name = "abmchildcontainer"
Shape.Top = 4
Shape.Left = 8
Shape.Name = "Shape"
shpLabel.Name = "shpLabel"
lblTitulo.Caption = "Datos Tabla Hija"
lblTitulo.TabIndex = 1
lblTitulo.Name = "lblTitulo"
[END PROPERTIES]
[START PROTECTED]
oldentidadid
classbeforenew
classafternew
classbeforeedit
classafteredit
classbeforedelete
classafterdelete
classbeforeopen
classafteropen
classbeforeupdate
classafterupdate
classbeforesetbuttons
classaftersetbuttons
classaftersynchronizebuttons
classafterllenarhijos
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try

    * Limpio los mensajes de error
    loError = Thisform.oError
    loError.Ctracelogin = ''
    loError.Cremark = ''

    With This As abmchildcontainer Of FW\Comunes\vcx\prxmainform.vcx
        .oEntity = Null
        .oColObjects = Null
        .oImageList = Null
        .ReleaseObjects()

    Endwith
    Unbindevents( This )

Catch To oErr
    loError = Thisform.oError
    Thisform.cXMLoError = loError.Process( oErr )
    Throw loError

Finally
    * Limpio los mensajes de error
    loError = Thisform.oError
    loError.Ctracelogin = ''
    loError.Cremark = ''

    loError = Null
Endtry

ENDPROC
PROCEDURE activecount_access

Return This.ActiveCount

ENDPROC
PROCEDURE calculatereccount
Lparameters tcFilterCriteria As String

Local lnRecCount As Integer

lnRecCount = 0

Return lnRecCount

ENDPROC
PROCEDURE cancreate

Return ThisForm.oGlobalSettings.oUser.CanRead( This.cDataConfigurationKey )
ENDPROC
PROCEDURE candelete

Return ThisForm.oGlobalSettings.oUser.CanDelete( This.cDataConfigurationKey )
ENDPROC
PROCEDURE canread

Return ThisForm.oGlobalSettings.oUser.CanRead( This.cDataConfigurationKey )
ENDPROC
PROCEDURE canupdate

Return ThisForm.oGlobalSettings.oUser.CanUpdate( This.cDataConfigurationKey )
ENDPROC
PROCEDURE ckeyname_access

If Empty( This.cKeyName )
	This.cKeyName = Lower( This.oEntity.cMainTableName + "." + This.Name )

Endif

Return This.cKeyName

ENDPROC
PROCEDURE classafterautosetup
Lparameters tlOnlyPosition As Boolean

#INCLUDE "FW\Comunes\Include\Praxis.h"

#Define BOTTOMSIDE 1
#Define RIGHTSIDE 2

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
	With This As abmchildcontainer Of fw\comunes\vcx\prxmainform.vcx

		If .ButtonsPosition = BOTTOMSIDE
			.optionpanel.Anchor = ANCHOR_Left_Absolute ;
				+ ANCHOR_Bottom_Absolute ;
				+ ANCHOR_Right_Absolute

		Else
			.optionpanel.Anchor = ANCHOR_Top_Absolute ;
				+ ANCHOR_Bottom_Absolute ;
				+ ANCHOR_Right_Absolute



		Endif

	Endwith
	DoDefault( tlOnlyPosition )

	Assert .optionpanel.Anchor = 13 Message 'El Anchor no es 13'

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError
Finally
	loError = Null
Endtry

ENDPROC
PROCEDURE classafterdelete
This.Hijos.SetFocus()
ENDPROC
PROCEDURE classafteredit
This.Hijos.SetFocus()
ENDPROC
PROCEDURE classafterinit
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try

	* DAE 2009-07-16(11:40:36)
	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''

	DoDefault()
	If Pemstatus( Thisform, 'Empty', 5 )
		Bindevent( Thisform, 'Empty', This, 'VaciarHijos' )

	Endif && Pemstatus( Thisform, 'Empty', 5 )

	If Pemstatus( Thisform, 'Fill', 5 )
		Bindevent( Thisform, 'Fill', This, 'LlenarHijos' )

	Endif && Pemstatus( Thisform, 'Fill', 5 )

	If Pemstatus( Thisform, 'HookAfterSynchronizeButtons', 5 )
		Bindevent( Thisform, 'HookAfterSynchronizeButtons', This, 'SetButtons' )

	Endif && Pemstatus( Thisform, 'HookAfterSynchronizeButtons', 5 )

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''
	loError = Null

Endtry

ENDPROC
PROCEDURE classafternew
This.Hijos.SetFocus()
ENDPROC
PROCEDURE classafteropen
This.Hijos.SetFocus()
ENDPROC
PROCEDURE classaftersetupentity
Lparameters toEntity As Object
ENDPROC
PROCEDURE classafterupdate
Lparameters nAction as Integer, nIdEntity as Integer

Return .T.
ENDPROC
PROCEDURE classbeforeautosetup
Lparameters tlOnlyPosition As Boolean

#Define BOTTOMSIDE 1
#Define RIGHTSIDE 2

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"

Try
	With This As abmchildcontainer Of FW\Comunes\vcx\prxmainform.vcx
		Do Case
			Case .ButtonsPosition = BOTTOMSIDE
				.optionpanel.SetAll( 'lSameRowAsPrevious', .T. )
				.optionpanel.lSameRowAsPrevious = .F.
				.optionpanel.lFitToParent = .T.
				.optionpanel.nFitMode = 5

			Otherwise && RIGHTSIDE
				.optionpanel.SetAll( 'lSameRowAsPrevious', .F. )
				.optionpanel.lSameRowAsPrevious = .T.
				.optionpanel.lFitToParent = .T.
				.optionpanel.nFitMode = 10

		Endcase
	Endwith
Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError
Finally
	loError = Null
Endtry

Return DoDefault( tlOnlyPosition )

ENDPROC
PROCEDURE classbeforedelete

Return .T.

ENDPROC
PROCEDURE classbeforeedit

Return .T.

ENDPROC
PROCEDURE classbeforeinit

* DAE 2009-11-05(15:58:06)
If Pemstatus( Thisform, "OnSubscribeToParent", 5 ) And This.lIsChild
	Bindevent( Thisform, "OnSubscribeToParent", This, "HookSubscribeToParent" )

Endif && Pemstatus( Thisform, "OnSubscribeToParent", 5 ) And This.lIsChild

Return DoDefault()

ENDPROC
PROCEDURE classbeforenew

Return .T.

ENDPROC
PROCEDURE classbeforeopen

Return .T.

ENDPROC
PROCEDURE classbeforesetupentity
Lparameters toEntity As Object

Return .T.

ENDPROC
PROCEDURE classbeforeupdate
Lparameters nAction As Integer

Return .T.

ENDPROC
PROCEDURE cobjectfactoryfilename_access
*To do: Modify this routine for the Access method
If Empty( This.cObjectFactoryFileName )
	If !IsRuntime()
		Local loProject As PjHook Of "Tools\ProjectHook\Vcx\ProjectHookVss.vcx"
		Local lcProjectPath As String

		lcProjectPath = ""
		loProject = _vfp.ActiveProject

		lcProjectPath = JustPath( loProject.Name )

		This.cObjectFactoryFileName = Addbs( lcProjectPath ) ;
			+ "ObjectFactoryCfg.xml"

		loProject = Null

	Else
		This.cObjectFactoryFileName = "ObjectFactoryCfg.xml"

	Endif
Endif

Return This.cObjectFactoryFileName



ENDPROC
PROCEDURE contextualmenu
Lparameters tcMenuName As String, tnMrow As Integer, tnMcol As String

#INCLUDE "FW\Tieradapter\Include\TA.h"


#Define BAR_NEW 4
#Define BAR_EDIT 3
#Define BAR_OPEN 8
#Define BAR_RECALL 6
#Define BAR_SAVE 5
#Define BAR_DELETE 2
#Define BAR_CLOSE 7
#Define BAR_PRINT 11
#Define BAR_PREVIEW 12
#Define BAR_EXPORT 13

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local lnSelected As Integer
Local lcMessage As String
Local llIdle As Boolean
Local llEditing As Boolean
Local llCanCreate As Boolean
Local llCanRead As Boolean
Local llCanDelete As Boolean
* Local llCantRecall As Boolean
Local llCanEdit As Boolean
* @TODO Pasar el menu contextual al modelo de menu por objetos
* 		y validar los permisos de las operaciones
Try

    Do Case
        Case Lower( tcMenuName ) == 'hijos'

            lnSelected = 0
            llIdle = ( Thisform.nStatus == IS_IDLE )
            llEditing = ( Thisform.nStatus == IS_EDITING )
            llCanCreate = This.CanCreate()
            llCanRead = This.CanRead()
            llCanDelete = This.CanDelete()
            llCanEdit = This.CanUpdate()

            Define Popup emergente ShortCut Relative From Mrow(),Mcol()

            Define Bar BAR_NEW Of emergente Prompt "Agregar" ;
                KEY F4, "F4 - Ins" ;
                PICTURE "fw\comunes\image\bmp\new.bmp" ;
                MESSAGE "Agrega un nuevo elemento" ;
                SKIP For ! ( llEditing And llCanCreate )

            Define Bar BAR_EDIT Of emergente Prompt "Modificar" ;
                PICTURE "fw\comunes\image\bmp\edit.bmp" ;
                MESSAGE "Abre un elemento existente para modificar" ;
                STYLE "B" ;
                SKIP For ! ( llEditing And llCanEdit )

            Define Bar BAR_OPEN Of emergente Prompt "Consultar" ;
                PICTURE "fw\comunes\image\bmp\open.bmp" ;
                MESSAGE "Abre un elemento existente para consultar" ;
                SKIP For ! ( llIdle And llCanRead )

            Define Bar BAR_DELETE Of emergente Prompt "Eliminar" ;
                KEY DEL, "Del" ;
                PICTURE "fw\comunes\image\bmp\delete.bmp" ;
                MESSAGE "Elimina el elemento actual" ;
                SKIP For ! ( llEditing And llCanDelete )

            On Selection Bar BAR_NEW Of emergente lnSelected = BAR_NEW
            On Selection Bar BAR_EDIT Of emergente lnSelected = BAR_EDIT
            On Selection Bar BAR_DELETE Of emergente lnSelected = BAR_DELETE
            On Selection Bar BAR_OPEN Of emergente lnSelected = BAR_OPEN

            Activate Popup emergente
            Release Popups emergente

            If ! Empty( lnSelected )
                Do Case
                    Case lnSelected = BAR_NEW
                    	This.OptionPanel.cmdNew.SetFocus()
                        This.New()
                    Case lnSelected = BAR_EDIT
                    	This.OptionPanel.cmdEdit.SetFocus()
                        This.Edit()
                    Case lnSelected = BAR_DELETE
                       	This.OptionPanel.cmdDelete.SetFocus()
                        This.Delete()
                    Case lnSelected = BAR_OPEN
						This.OptionPanel.cmdOpen.SetFocus()
                        This.Open()
                    Otherwise
                Endcase
            Endif
        Otherwise
            DoDefault( tcMenuName, tnMrow, tnMcol )
    Endcase
Catch To oErr
    loError = Thisform.oError
    Thisform.cXMLoError = loError.Process( oErr )
    Throw loError
Finally
    loError = Null
Endtry


ENDPROC
PROCEDURE delete
#INCLUDE "FW\Tieradapter\Include\TA.h"

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
    * Limpio los mensajes de error
    loError = Thisform.oError
    loError.Ctracelogin = ''
    loError.Cremark = ''

    With This As abmchildcontainer Of fw\comunes\vcx\prxmainform.vcx
        If .CanDelete()
            If .ClassBeforeDelete()
                If .HookBeforeDelete()
                    .Update( TR_DELETE )
                    .HookAfterDelete()
                    .ClassAfterDelete()

                EndIf && .HookBeforeDelete()

            EndIf && .ClassBeforeDelete()

        Else
            Error 'No tiene permisos suficientes para realizar la operación'

        EndIf && .CanDelete()

    Endwith
Catch To oErr
    loError = Thisform.oError
    Thisform.cXMLoError = loError.Process( oErr, .T. )

Finally
    * Limpio los mensajes de error
    loError = Thisform.oError
    loError.Ctracelogin = ''
    loError.Cremark = ''
    loError = Null

Endtry



ENDPROC
PROCEDURE documentacion
*!*	La ChildGrid y el ChildForm se encuentran en la misma DataSession
*!*	ChildGrid le indica a ChildForm la acción a realizar.
*!*	En ChildForm se edita y valida el registro, y si se confirma la accion,
*!*	en ChildGrid se aplican los cambios.

*!*	Existen 3 Cursores:

*!*	This.Hijos.AsociatedCursor: Es el cursor que contiene la tabla Hija de la Entidad Principal
*!*	This.Hijos.PrivateCursor: Es el cursor que utiliza el Grid como ControlSource
*!*	This.EditingCursorName: Es el cursor que se edita en el ChildForm

*!*	Acciones posibles:
*!*	Alta, Baja o Modificacion

*!*	Se le pasa al ChildForm la Accion y el objeto ChildEntity, que ya conoce los alias del
*!*	EditingCursorName y AsociatedCursor, para poder realizar todas las validaciones.

*!*	ChildForm devuelve un booleano, indicando si se confirmó la acción.
*!*	La aplicación de los cambios se realiza sincronizando los registros correspondientes de
*!*	los cursores PrivateCursor y AsociatedCursor.

ENDPROC
PROCEDURE edit
#INCLUDE "FW\Tieradapter\Include\TA.h"

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
    * Limpio los mensajes de error
    loError = Thisform.oError
    loError.Ctracelogin = ''
    loError.Cremark = ''

    With This As abmchildcontainer Of fw\comunes\vcx\prxmainform.vcx
        If .CanUpdate()
            If .ClassBeforeEdit()
                If .HookBeforeEdit()
                    .Update( TR_UPDATE )
                    .HookAfterEdit()
                    .ClassAfterEdit()
                Endif
            Endif
        Else
            Error 'No tiene permisos suficientes para realizar la operación'
        Endif
    Endwith
Catch To oErr
    loError = Thisform.oError
    Thisform.cXMLoError = loError.Process( oErr, .T. )

Finally
    * Limpio los mensajes de error
    loError = Thisform.oError
    loError.Ctracelogin = ''
    loError.Cremark = ''
    loError = Null

Endtry


ENDPROC
PROCEDURE enabled_assign
Lparameters vNewVal As Boolean

DoDefault( vNewVal )
This.Hijos.Enabled = vNewVal

ENDPROC
PROCEDURE filleditingrecord
Lparameters nIdEntity As Integer, nAction As Integer

#INCLUDE "FW\Tieradapter\Include\TA.h"

Local lcFilterCriteria As String
Local lcEditingCursorName As String
Local lcCommand As String
Local loPadre As UserTierAdapter Of "FW\Tieradapter\UserTier\UserTierAdapter.prg"
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local loEntity As Object
Try
	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''

	With This As abmchildcontainer Of fw\comunes\vcx\prxmainform.vcx
		loEntity = .oEntity
		* Llenar el registro con los datos a modificar
		lcEditingCursorName = loEntity.cEntityCursor
		*!*	* DA 2009-07-10: No debo cerrar el cursor!
		*!*	* Use In Select( Alias(lcEditingCursorName) )
		*!*	TEXT To lcFilterCriteria  NoShow TextMerge Pretext 15
		*!*		<<loEntity.cMainCursorPk>> = <<Transform( nIdEntity )>>
		*!*	ENDTEXT
		*!*	AppendFromCursor( loEntity.cMainCursorName, lcEditingCursorName, lcFilterCriteria )
		*!*	* .OldIdEntidad = loEntity.nEntidadId
		* DA 2009-07-13
		.OldEntidadId = loEntity.nEntidadId
		If nAction = TR_NEW
			* Select Alias( loEntity.EditingCursorName )
			* Append Blank In (lcEditingCursorName)
			loEntity.nEntidadId = 0
			loPadre = .oParent
			If Vartype( loPadre ) == "O"
				TEXT To lcCommand NoShow TextMerge Pretext 15
					Replace <<loPadre.cMainCursorPK>> with <<loPadre.nEntidadId>>,
					<<Thisform.oEntity.cMainCursorPK>> with <<Thisform.oEntity.nEntidadId>>
					in <<lcEditingCursorName>>
				ENDTEXT
				Select Alias( lcEditingCursorName )
				Locate
				&lcCommand
			Endif
		Endif
	Endwith

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''

	loError = Null
	loPadre = Null
	loEntity = Null
	
Endtry

ENDPROC
PROCEDURE getentityid
Lparameters nAction As Integer

#INCLUDE "FW\Tieradapter\Include\TA.h"

Local lnEntidadId As Integer
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local loEntity As UserTierAdapter Of "FW\Tieradapter\UserTier\UserTierAdapter.prg"

Try
	* Limpio los mensajes de error
	loError = Thisform.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''

	If nAction = TR_NEW
		lnEntidadId = 0

	Else
		loEntity = This.oEntity
		* lnEntidadId = This.oEntity.nEntidadId
		lnEntidadId = Evaluate( loEntity.cEntityCursor + '.' + loEntity.cMainCursorPk )
		Assert lnEntidadId # 0 Message 'Se esperaba un nEntidadId distinto de 0'

	Endif

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	* Limpio los mensajes de error
	loError = Thisform.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
	loError = Null
	loEntity = Null

Endtry

Return lnEntidadId

ENDPROC
PROCEDURE hijos_access
return This.Hijos

ENDPROC
PROCEDURE hijosconunregistro
* Es llamado por nRecNo_Assign cuando la cantidad de registros deja de ser cero
* Para colgarse con BindEvent()
* @TODO Sacar del evento el cambio de estado de los botones
With This As ABMChildcontainer Of FW\Comunes\vcx\prxmainform.vcx
*!*	.CmdDelete.Enabled = .T.
*!*	.cmdEdit.Enabled = .T.
*!*	.cmdNew.Enabled = .T.
    .StatusBarText = ''
Endwith

ENDPROC
PROCEDURE hijoslleno
* Es llamado por nRecNo_Assign cuando la cantidad de registros llega a This.nMaxRec
* Para colgarse con BindEvent()
* @TODO Sacar del evento el cambio de estado de los botones
With This As ABMChildcontainer Of FW\Comunes\vcx\prxmainform.vcx
*!*	.cmdDelete.Enabled = .T.
*!*	.cmdEdit.Enabled = .T.
*!*	.cmdNew.Enabled = .F.
    .StatusBarText = "No es posible agregar más registros"
Endwith

ENDPROC
PROCEDURE hijosvacio
* Es llamado por nRecNo_Assign cuando la cantidad de registros llega a cero
* Para colgarse con BindEvent()
* @TODO Sacar del evento el cambio de estado de los botones
With This As ABMChildcontainer Of FW\Comunes\vcx\prxmainform.vcx
*!* .cmdnew.Enabled = .T.
*!* .cmdEdit.Enabled = .F.
*!* .cmddelete.Enabled = .F.
    .StatusBarText = "El control está vacío"
Endwith

ENDPROC
PROCEDURE hookaftersetupentity
Lparameters toEntity As Object

ENDPROC
PROCEDURE hookafterupdate
Lparameters nAction as Integer, nIdEntity as Integer

Return .T.
ENDPROC
PROCEDURE hookbeforedelete

Return .T.

ENDPROC
PROCEDURE hookbeforeedit

Return .T.

ENDPROC
PROCEDURE hookbeforelaunchform
Lparameters toParam as Object, tnAction as Integer, toParamFrmName as Object

Return .T.
ENDPROC
PROCEDURE hookbeforenew

Return .T.

ENDPROC
PROCEDURE hookbeforeopen

Return .T.

ENDPROC
PROCEDURE hookbeforesetupentity
Lparameters toEntity As Object

Return .T.

ENDPROC
PROCEDURE hookbeforeupdate
Lparameters nAction As Integer

Return .T.

ENDPROC
PROCEDURE hookonparentchange
Lparameters tcFilterCriteria As String

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local loEntity As utArchivo Of "FW\TierAdapter\UserTier\utArchivo.prg"
Local lnEntidadId As Integer
Local lcEntityCursor As String
Local lnRecCount As Integer

Try

	This.Refresh()

	* This.Hijos.SetAll( 'Enabled', .T. )
	loEntity = This.oEntity
	lcEntityCursor = loEntity.cEntityCursor

	If ! Eof( lcEntityCursor )
		lnEntidadId = Evaluate( loEntity.cEntityCursor + '.' +  loEntity.cMainCursorPk )
		loEntity.nEntidadId = lnEntidadId
		loEntity.SetSelected(  lnEntidadId )
		This.InteractiveChange( lnEntidadId )

	Else
		loEntity.nEntidadId = 0

	Endif

	tcFilterCriteria = Strtran( tcFilterCriteria, loEntity.cMainTableName, lcEntityCursor, -1, -1, 1 )
	lnRecCount = This.CalculateRecCount( tcFilterCriteria )
	This.nRecCount = lnRecCount
	loEntity.UpdateRecOrder()

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''
	loError = Null
	loEntity = Null

Endtry

ENDPROC
PROCEDURE hookonparentclear

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"

Try
	* @TODO Damian Eiff 2009-11-05 (16:13:17)
	* Implementar el vaciado y/o deshabilitado del control Hijo


Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''
	loError = Null

Endtry

ENDPROC
PROCEDURE hooksubscribetoparent

* DAE 2009-11-05(15:58:46)

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local loParent As Object
Local loEntity As Object

Try
	If This.lIsChild
		loParent = This.oParent
		loEntity = This.oEntity

		Bindevent( loParent, "OnChange", loEntity, "HookOnParentChange" )
		Bindevent( loParent, "OnClear", loEntity, "HookOnClear" )

	Endif && This.lIsChild

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally

	loParent = Null
	loEntity = Null

	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''
	loError = Null

Endtry

ENDPROC
PROCEDURE interactivechange
Lparameters tnEntidadId As Integer

* DAE 2009-11-05(16:11:09)
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local loEntity As utArchivo Of "FW\TierAdapter\UserTier\utArchivo.prg"
LOCAL llLockScreen as Boolean
Try
	llLockScreen = Thisform.LockScreen
	Thisform.LockScreen = .T.
	loEntity = This.oEntity
	If Vartype( loEntity ) = 'O'
		loEntity.InteractiveChange( tnEntidadId )

	Endif && Vartype( loEntity ) = 'O'

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''
	loError = Null
	loEntity = Null

	Thisform.LockScreen = llLockScreen

Endtry

ENDPROC
PROCEDURE llenarhijos
Lparameters tnEntityId As Integer

#INCLUDE "FW\Tieradapter\Include\TA.h"

Local lcPK As String
Local llHasDefault As Boolean
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local q As Integer
Local lnTotalWidth As Integer
Local lnDifference As Integer
Local lnRecCount As Integer
Local loEntity As Object
Local loColumn As Column
Local lcEntityCursor As String
Local lLockScreen As Boolean
Local lcAlias As String

Try
	lcAlias = Alias()
	lLockScreen = Thisform.LockScreen
	Thisform.LockScreen = .T.
	* Limpio los mensajes de error
	loError = Thisform.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''

	If Empty( tnEntityId )
		tnEntityId = 0

	Endif && Empty( tnEntityId )

	llHasDefault = .F.
	With This.Hijos As prxActionGrid Of "FW\Comunes\Vcx\prxMainForm.vcx"
		loEntity = .oEntity
		lcEntityCursor = loEntity.cEntityCursor
		lcPK = loEntity.cMainCursorPK

		If Pemstatus(  This.Hijos, 'Fill', 5 )
			.Fill()

		Endif && PemStatus(  This.Hijos, 'Fill', 5 )

		This.ClassAfterLlenarHijos()
		This.HookAfterLlenarHijos()

		If Used( lcEntityCursor  )

			lnRecCount = This.CalculateRecCount()

			This.nRecCount = lnRecCount

			If Empty( tnEntityId )
				Try
					Locate For Selected = TRUE

				Catch To oErr
					llHasDefault = .F.
					Locate
				Finally
				Endtry

			Else && Empty( tnEntityId )
				TEXT To lcCommand NoShow TextMerge Pretext 15
					Locate For <<lcPK>> = <<tnEntityId>>

				ENDTEXT

				&lcCommand

			Endif && Empty( tnEntityId )

			If Eof( lcEntityCursor )
				Locate

			Endif && Eof( lcEntityCursor )

			tnEntityId = Evaluate( lcEntityCursor + '.' + lcPK )
			* tnEntityId = loEntity.GetValue( lcPK )

			.Refresh()

			loEntity.nEntidadId = tnEntityId
			loEntity.UpdateRecOrder()

		Else
			* DA 2009-08-31(14:52:46)
			* Faltaba El 'This'
			This.nRecCount = 0
			tnEntityId = 0

			loEntity.nEntidadId = tnEntityId
			
		EndIf
		
	EndWith
	
Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )

Finally
	loEntity = Null
	* Limpio los mensajes de error
	loError = Thisform.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
	loError = Null

	Thisform.LockScreen = lLockScreen

	If Used( lcAlias )
		Select Alias( lcAlias )

	Endif && Used( lcAlias )

Endtry

ENDPROC
PROCEDURE new
#INCLUDE "FW\Tieradapter\Include\TA.h"

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
    * Limpio los mensajes de error
    loError = Thisform.oError
    loError.Ctracelogin = ''
    loError.Cremark = ''

    With This As abmchildcontainer Of fw\comunes\vcx\prxmainform.vcx
        If .CanCreate()
            If .ClassBeforeNew()
                If .HookBeforeNew()
                    Do While .Update( TR_NEW )
                    Enddo
                    .HookAfterNew()
                    .ClassAfterNew()

                Endif && .HookBeforeNew()

            Endif && .ClassBeforeNew()

        Else
            Error 'No tiene permisos suficientes para realizar la operación'

        Endif && .CanCreate()
    Endwith
Catch To oErr
    loError = Thisform.oError
    Thisform.cXMLoError = loError.Process( oErr, .T. )

Finally
* Limpio los mensajes de error
	loError = Thisform.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
    loError = Null

Endtry


ENDPROC
PROCEDURE nreccount_assign
Lparameters nNewValue As Integer

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
    * Limpio los mensajes de error
    loError = Thisform.oError
    loError.Ctracelogin = ''
    loError.Cremark = ''

    With This As abmchildcontainer Of fw\comunes\vcx\prxmainform.vcx
        * Setear valores mínimos
        If nNewValue < 0
            nNewValue = 0

        EndIf && nNewValue < 0

        If .nRecCount < 0
            .nRecCount = 0

        EndIf && .nRecCount < 0

        Do Case
            Case .nRecCount = 0 And nNewValue > 0
                .HijosConUnRegistro()

            Case .nRecCount >= 0 And nNewValue = 0
                .HijosVacio()

            Case nNewValue >= .nMaxRec
                .HijosLleno()

                nNewValue = .nRecCount
            Case nNewValue <= .nMinRec
                * No definido

            Otherwise
                * No definido

        Endcase
    Endwith
Catch To oErr
    * loError = Newobject( "prxErrorHandler", "prxErrorHandler.prg" )
    loError = Thisform.oError
    Thisform.cXMLoError = loError.Process( oErr )
    Throw loError

Finally
    This.nRecCount = nNewValue

    * Limpio los mensajes de error
    loError = Thisform.oError
    loError.Ctracelogin = ''
    loError.Cremark = ''
    loError = Null

Endtry

ENDPROC
PROCEDURE nupdatefontsize_assign
Lparameters tuNewValue As Integer

Local oCtrl As Object
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
	* Limpio los mensajes de error
    loError = Thisform.oError
    loError.Ctracelogin = ''
    loError.Cremark = ''

	With This As abmchildcontainer Of fw\comunes\vcx\prxmainform.vcx
		.nUpdateFontSize = tuNewValue
		.lblTitulo.FontSize = .lblTitulo.FontSize + tuNewValue
		.lblTitulo.AutoFit( 4 )
		.cmdnew.FontSize = .cmdnew.FontSize + tuNewValue
		.cmddelete.FontSize = .cmddelete.FontSize + tuNewValue
		.cmdEdit.FontSize = .cmdEdit.FontSize + tuNewValue
		.Hijos.nUpdateFontSize = tuNewValue
		If tuNewValue >= 0
			.Width = Round( .Width * 1.1, 0 )
			.Height = Round( .Height * 1.1, 0 )
			
		Else && tuNewValue >= 0
			.Width = Round( .Width * 0.9, 0 )
			.Height = Round( .Height * 0.9, 0 )
			
		EndIf && tuNewValue >= 0
	Endwith
Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	
Finally
	* Limpio los mensajes de error
    loError = Thisform.oError
    loError.Ctracelogin = ''
    loError.Cremark = ''

	loError = Null
Endtry


ENDPROC
PROCEDURE oentity_access
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local loEntity as utArchivo OF "FW\TierAdapter\UserTier\utArchivo.prg"
Try
	
	* Limpio los mensajes de error
    loError = Thisform.oError
    loError.Ctracelogin = ''
    loError.Cremark = ''

	With This As ABMChildContainer Of FW\Comunes\vcx\prxmainform.vcx
		If Vartype( .oEntity ) # "O" And !Thisform.lExit
			* La entidad principal es la que tiene la responsabilidad
			* de instanciar las clases
			
			If Empty( .cAliasConfigurationKey )
				loEntity = Thisform.oEntity.GetEntity( .cDataConfigurationKey )
			
			Else
				loEntity = Thisform.oEntity.oColEntities.GetItem( .cAliasConfigurationKey + "_User" )
				
				If Vartype( loEntity ) # "O"
					loEntity = Thisform.oEntity.InstanciateEntity( This.cDataConfigurationKey )
					Thisform.oEntity.oColEntities.AddItem( loEntity, .cAliasConfigurationKey + "_User" )
				EndIf

			EndIf
			
			.SetupEntity( loEntity )
			loEntity.lIsChild = .T.
			.oEntity = loEntity

		EndIf && Vartype( .oEntity ) # "O"
	EndWith
	
Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError
	
Finally

	* Limpio los mensajes de error
    loError = Thisform.oError
    loError.Ctracelogin = ''
    loError.Cremark = ''
	loError = Null
	loEntity = Null
	
EndTry

Return This.oEntity

ENDPROC
PROCEDURE oparent_access
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
* @TODO Verificar quien es el responsable de devolver la referencia al Objeto Padre
Try
    * Limpio los mensajes de error
    loError = Thisform.oError
    loError.Ctracelogin = ''
    loError.Cremark = ''

    With This As abmchildcontainer Of fw\comunes\vcx\prxmainform.vcx
        If Vartype( .oParent ) # "O"
            If ! Empty( .cParentConfigurationKey )
                .oParent = Thisform.oEntity.GetEntity( .cParentConfigurationKey )

            Else && ! Empty( .cParentConfigurationKey )
                .oParent = .oEntity.oParent

            EndIf && ! Empty( .cParentConfigurationKey )

        EndIf && Vartype( .oParent ) # "O"
    Endwith
Catch To oErr
    loError = Thisform.oError
    loError.Process( oErr )
    Throw loError

Finally
    * Limpio los mensajes de error
    loError = Thisform.oError
    loError.Ctracelogin = ''
    loError.Cremark = ''

    loError = Null

Endtry

Return This.oParent

ENDPROC
PROCEDURE open
#INCLUDE "FW\Tieradapter\Include\TA.h"

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
	* Limpio los mensajes de error
	loError = Thisform.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''

	With This As abmchildcontainer Of fw\comunes\vcx\prxmainform.vcx
		If .CanRead()
			If .ClassBeforeOpen()
				If .HookBeforeOpen()
					.Update( TR_QUERY )
					.HookAfterOpen()
					.ClassAfterOpen()
				Endif
			Endif
		Else
			Error 'No tiene permisos suficientes para realizar la operación'
		Endif
	Endwith
Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr, .T. )
	
Finally
	* Limpio los mensajes de error
	loError = Thisform.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
	loError = Null
	
Endtry

ENDPROC
PROCEDURE releaseobjects

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
    With This As abmchildcontainer Of FW\Comunes\vcx\prxmainform.vcx
        .oImageList = Null
        .oParent = Null
    Endwith
    DoDefault()
Catch To oErr
    loError = Thisform.oError
    Thisform.cXMLoError = loError.Process( oErr )
    Throw loError
Finally
    loError = Null
Endtry

ENDPROC
PROCEDURE setbuttons
Lparameters tlActivate As Boolean

#INCLUDE "FW\TierAdapter\Include\TA.h"

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local llEditing As Boolean
Local llIdle As Boolean
Local llEnabled As Boolean
Local lnEntidadId As Integer
Try

	Debugout Datetime(), Program(), tlActivate

	* Limpio los mensajes de error
	loError = Thisform.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''

	With This As ABMChildcontainer Of FW\Comunes\vcx\prxmainform.vcx
		If .ClassBeforeSetButtons()
			If .HookBeforeSetButtons()
				llEditing = ( Thisform.nStatus == IS_EDITING )
				llIdle = Inlist( Thisform.nStatus, IS_IDLE, IS_READING )
				lnEntidadId = Thisform.nEntidadId

				Do Case
					Case .nRecCount = 0
						* New
						.optionpanel.cmdNew.Enabled = Thisform.lIsActive And tlActivate And llEditing And .CanCreate()
						.optionpanel.cmdNew.Visible = .optionpanel.cmdNew.lVisible
						* Edit
						.optionpanel.cmdEdit.Enabled = .F.
						.optionpanel.cmdEdit.Visible = .optionpanel.cmdEdit.lVisible
						* Open
						.optionpanel.cmdOpen.Enabled = .F.
						.optionpanel.cmdOpen.Visible = .optionpanel.cmdOpen.lVisible
						* Delete
						.optionpanel.cmdDelete.Enabled = .F.
						.optionpanel.cmdDelete.Visible = .optionpanel.cmdDelete.lVisible

					Case .nRecCount > 0
						* New
						.optionpanel.cmdNew.Enabled = Thisform.lIsActive And tlActivate And llEditing And .CanCreate()
						.optionpanel.cmdNew.Visible = .optionpanel.cmdNew.lVisible
						* Edit
						.optionpanel.cmdEdit.Enabled = Thisform.lIsActive And tlActivate And llEditing And .CanUpdate()
						.optionpanel.cmdEdit.Visible = .optionpanel.cmdEdit.lVisible
						* Open
						llEnabled = llIdle
						* llEnabled = llEnabled And ! Empty( Thisform.oEntity.nEntidadId )
						llEnabled = llEnabled And ! Empty( lnEntidadId )
						llEnabled = llEnabled Or llEditing
						llEnabled = llEnabled And .CanRead()

						.optionpanel.cmdOpen.Enabled = Thisform.lIsActive And tlActivate And llEnabled
						* .optionpanel.cmdOpen.Enabled = tlActivate And ( llEditing Or ( llIdle And ! Empty( lnEntidadId ) ) ) And .CanRead()
						.optionpanel.cmdOpen.Visible = .optionpanel.cmdOpen.lVisible
						* Delete
						.optionpanel.cmdDelete.Enabled = Thisform.lIsActive And tlActivate And llEditing And .CanDelete()
						.optionpanel.cmdDelete.Visible = .optionpanel.cmdDelete.lVisible

					Case .nRecCount = .nMaxRec
						* New
						.optionpanel.cmdNew.Enabled = .F.
						.optionpanel.cmdNew.Visible = .optionpanel.cmdNew.lVisible
						* Edit
						.optionpanel.cmdEdit.Enabled = Thisform.lIsActive And tlActivate And llEditing And .CanUpdate()
						.optionpanel.cmdEdit.Visible = .optionpanel.cmdEdit.lVisible
						* Open
						llEnabled = llIdle
						llEnabled = llEnabled And ! Empty( lnEntidadId )
						llEnabled = llEnabled Or llEditing
						llEnabled = llEnabled And .CanRead()

						.optionpanel.cmdOpen.Enabled = Thisform.lIsActive And tlActivate And llEnabled
						.optionpanel.cmdOpen.Visible = .optionpanel.cmdOpen.lVisible
						* Delete
						.optionpanel.cmdDelete.Enabled = Thisform.lIsActive And tlActivate And llEditing And .CanDelete()
						.optionpanel.cmdDelete.Visible = .optionpanel.cmdDelete.lVisible

				Endcase
				.HookAfterSetButtons()
				.ClassBeforeSetButtons()
			Endif
		Endif
	Endwith
Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	* Limpio los mensajes de error
	loError = Thisform.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
	loError = Null

Endtry

ENDPROC
PROCEDURE setupentity
Lparameters toEntity As Object @

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
	* Limpio los mensajes de error
	loError = Thisform.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''

	With This As abmchildcontainer Of FW\Comunes\vcx\prxmainform.vcx
		If .ClassBeforeSetupEntity( @toEntity )
			If .HookBeforeSetupEntity( @toEntity )
				* DAE 2009-11-05(16:08:29)
				If This.lIschild
					Bindevent( toEntity, "OnParentChange", This, "HookOnParentChange" )
					Bindevent( toEntity, "OnParentClear", This, "HookOnParentClear" )

				Endif && this.lIschild

				Thisform.SetupEntity( toEntity )

				* DAE 2009-07-10
				toEntity.lIschild = .T.

				.HookAfterSetupEntity( @toEntity )
				.ClassAfterSetupEntity( @toEntity )

			Endif && .HookBeforeSetupEntity( toEntity )

		Endif && .ClassBeforeSetupEntity( toEntity )

	Endwith

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	* Limpio los mensajes de error
	loError = Thisform.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
	loError = Null

Endtry

ENDPROCPROCEDURE update
Lparameters tnAction As Integer

#INCLUDE "FW\Tieradapter\Include\TA.h"

Local lnIdEntity As Integer
Local llRepeat As Boolean
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"

Local loEntity As utArchivo Of "FW\TierAdapter\UserTier\utArchivo.prg"
Local loParent As utArchivo Of "FW\TierAdapter\UserTier\utArchivo.prg"

Local lcAlias As String
Local lnOldIdEntity As Integer
Local lcEntityCursor As String
Local lcParentCursor As String
Local llLockScreen As Boolean

Try
	llLockScreen = Thisform.LockScreen
	lcAlias = Alias()
	* Limpio los mensajes de error
	loError = Thisform.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''

	With This As ABMChildcontainer Of FW\Comunes\vcx\prxmainform.vcx
		If Thisform.lIsOk And .ClassBeforeUpdate( tnAction )
			If Thisform.lIsOk And .HookBeforeUpdate( tnAction )
				loEntity = .oEntity
				loParent = loEntity.oParent

				* DAE 2009-09-10(18:49:52)
				* Cuando necesito utilizar una entidad como Padre y Child en simultaneo (Parametros)
				* No existe el oParent asi que no puedo filtrar el cursor del padre
				If Vartype( loParent ) = 'O'
					lcParentCursor = loParent.cEntityCursor

				Else
					lcParentCursor = ''

				Endif


				lnOldIdEntity = loEntity.nEntidadId
				loEntity.TransactionBegin()
				llRepeat = .F.

				* Obtener el Id del registro que se va a modificar && No es necesario, y produce error
				*!*					lnIdEntity = .GetEntityId( tnAction )
				*!*					Assert ! ( lnIdEntity = 0 And tnAction # TR_NEW ) Message 'nIdEntity errorneo'
				*!*					loEntity.nEntidadId = lnIdEntity


				loEntity.LocatePk( loEntity.nEntidadId, .T. )

				*!*	Select Alias( loEntity.cEntityCursor )
				*!*	TEXT To lcCommand NoShow TextMerge Pretext 15
				*!*		Locate For <<loEntity.cMainCursorPk>> = <<lnIdEntity>>
				*!*
				*!*	ENDTEXT

				*!*	&lcCommand

				* DA 2009-17-14
				*!* * Llenar el registro con los datos a modificar
				*!* .FillEditingRecord( lnIdEntity, tnAction )

				If .ValidateUpdate( tnAction )
					* DAE 2009-11-05(17:24:49)
					Thisform.LockScreen = .T.

					* Aplicar la actualizacion a los cursores
					* Primero actualizo AsociatedCursor, y me devuelve el Id a utilizar en
					* caso de que sea un INSERT
					lnIdEntity = .UpdateAsociatedCursor( tnAction, lnIdEntity )
					* No es necesario reflejar los cambios en PrivateCursor, porque el metodo
					* This.LlenarHijos( lnIdEntity ) lo vuelve a crear (RA. 01/08/2008)

					* Luego actualizo PrivateCursor
					***This.UpdatePrivateCursor( tnAction, lnIdEntity )

					* Termino la transacion
					loEntity.TransactionEnd()

					* DAE 2009-08-04(16:52:15) No es necesario llamar a la funcion llenar hijos
					* Hago visible el cambio en la grilla
					* .LlenarHijos( lnIdEntity )
					* .Hijos.Refresh()

					Wait Clear
					Do Case
						Case tnAction = TR_NEW And .lKeepOnInserting
							llRepeat = .T.

						Case tnAction = TR_DELETE

						Case tnAction = TR_UPDATE

						Otherwise

					Endcase

					llRepeat = .HookAfterUpdate( tnAction, lnIdEntity )
					llRepeat = llRepeat And .ClassAfterUpdate( tnAction, lnIdEntity )
					llRepeat = llRepeat And .lKeepOnInserting

					.nRecCount = This.CalculateRecCount()

					loEntity.UpdateRecOrder()

					* Hago visible el cambio
					.Hijos.Refresh()

				Else
					loError.Ctracelogin = 'Antes de llamar al RollBack'

					loEntity.TransactionRollBack()

					* Fuerza a ejecutar nRecCount_Assign
					.nRecCount = .nRecCount

					loEntity.nEntidadId = lnOldIdEntity

				Endif && .ValidateUpdate( tnAction )

			Endif && .HookBeforeUpdate( tnAction )

		Endif && .ClassBeforeUpdate( tnAction )

	Endwith

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	* Limpio los mensajes de error
	loError = Thisform.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
	loError = Null

	loEntity = Null

	If Used( lcAlias )
		Select Alias( lcAlias )

	Endif && Used( lcAlias )

	If Used( lcParentCursor )
		Set Filter To In &lcParentCursor

	Endif && Used( lcParentCursor )

	Thisform.LockScreen = llLockScreen

Endtry

Return llRepeat

ENDPROC
PROCEDURE updateasociatedcursor
Lparameters tnAction As Integer, tnIdEntity As Integer

#INCLUDE "FW\Tieradapter\Include\TA.h"

Local lcPKField As String
Local lcEntityCursor As String
*!*	Local lcFiltro As String
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local loEntity As UserTierAdapter Of "FW\TierAdapter\UserTier\UserTierAdapter.prg"
Local lcAlias As String

Try
	lcAlias = Alias()

	* Limpio los mensajes de error
	*!*	loError = Thisform.oError
	*!*	loError.TraceLogin = ''
	*!*	loError.Remark = ''

	With This As abmchildcontainer Of fw\comunes\vcx\prxmainform.vcx
		* lcFiltro = ""
		loEntity = .oEntity
		* lcMainCursorPK = loEntity.cMainCursorPK
		* lcEntityCursor = loEntity.cEntityCursor
		* Select Alias( lcEntityCursor )

		Do Case
			Case tnAction = TR_NEW
				* DAE 2009-08-04(16:41:11)
				* Si es un registro nuevo la entidad sabe cual es el Id
				tnIdEntity = loEntity.nEntidadId

				* DAE 2009-07-28(16:22:09)
				*!* No hago nada si es un registro nuevo
				*!* las claves ya las agrego la entidad
				*!* ----------------------------------------

				*!*	* Los registros nuevos no tiene asignada la PK
				*!*	* Aprovecho que todas las PK son Integer, y la inicializo con el Recno()
				*!*	* que por ser un insert, es un valor negativo, por lo tanto, no hay riesgo
				*!*	* de que se duplique

				*!*	*!* Select Alias( loEntity.cEntityCursor )

				*!*	* Si el cursot está filtrado por el padre, guardo la condición, y le saco el filtro
				*!*	* para que sea visible  al hacer el Append Blanc

				*!*	*!* lcFiltro = Set( 'Filter' )
				*!*	* Set Filter To
				*!*	*!* Append Blank In Alias(.Hijos.AsociatedCursor)
				*!*	Locate For &lcMainCursorPK = 0

				*!*	* Tomo la nueva PK y la grabo
				*!*	tnIdEntity = Recno( lcEntityCursor )
				*!*	*!* Replace &lcMainCursorPK With tnIdEntity In Alias(.Hijos.AsociatedCursor)
				*!*	loEntity.SetValue( lcMainCursorPK, tnIdEntity )

				*!*	*!* * Grabo la PK en EditingCursorName
				*!*	*!* Select Alias(loEntity.cEntityCursor)
				*!*	*!* Replace &lcMainCursorPK With tnIdEntity In Alias(loEntity.cEntityCursor)
				*!*	*!* loEntity.nEntidadId = tnIdEntity

			Case tnAction = TR_DELETE
				* DAE 2009-08-24(16:21:02)
				*!*	TEXT To lcCommand NoShow TextMerge Pretext 15
				*!*		Locate For <<lcMainCursorPK>> = <<tnIdEntity>>

				*!*	ENDTEXT

				*!*	&lcCommand

				*!*	If Found( lcEntityCursor )
				*!*		loEntity.DeleteEntity()
				*!*		* tnIdEntity = loEntity.nEntidadId

				*!*	Else
				*!*		Error "No se pudo actualizar correctamente"

				*!*	Endif && Found( lcEntityCursor )

				loEntity.LocatePK()
				loEntity.DeleteEntity()

			Otherwise

		Endcase

	Endwith

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	* Limpio los mensajes de error
	loError = Thisform.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
	loError = Null
	loEntity = Null

	If Used( lcAlias )
		Select Alias( lcAlias )

	Endif && Used( lcAlias )

Endtry

* Si hubo un INSERT, tnIdEntity contiene un valor negativo
Return tnIdEntity


ENDPROC
PROCEDURE updateprivatecursor
Lparameters nAction As Integer, nIdEntity As Integer

#INCLUDE "FW\Tieradapter\Include\TA.h"

Local lcPKField As String
Local lcFiltro As String
Local lnRecCount As Integer
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local loEntity As Object
Try
	
	With This As abmchildcontainer Of fw\comunes\vcx\prxmainform.vcx
		loEntity = .oEntity
		lcFiltro  = ""
		lcPKField =  .Hijos.PKField
		Select Alias( loEntity.EditingCursorName )
		Locate
		Select Alias( .Hijos.PrivateCursor )
		lnRecCount = 0
		Scan For ! Deleted( Alias( .Hijos.PrivateCursor ) )
			lnRecCount = lnRecCount + 1
		Endscan
		If nAction = TR_NEW
			Select Alias( .Hijos.PrivateCursor )
			* Si el cursot está filtrado por el padre, guardo la condición, y le saco el filtro
			* para que sea visible  al hacer el Append Blank
			lcFiltro = Set( 'Filter' )
			Set Filter To In Alias( .Hijos.PrivateCursor )
			Append Blank In Alias( .Hijos.PrivateCursor )
			UpdateFromCursor( loEntity.EditingCursorName, .Hijos.PrivateCursor )
			.nRecCount = lnRecCount + 1
		Endif
		Select Alias( .Hijos.PrivateCursor )
		Locate For &lcPKField = nIdEntity
		If Found( Alias( .Hijos.PrivateCursor ) )
			Do Case
				Case nAction = TR_DELETE
					Delete In Alias( .Hijos.PrivateCursor )
					Skip In Alias( .Hijos.PrivateCursor )
					If Eof( Alias( .Hijos.PrivateCursor ) )
						Go Bottom In Alias( .Hijos.PrivateCursor )
					Endif
					.nRecCount = lnRecCount - 1
				Case nAction = TR_UPDATE
					UpdateFromCursor( loEntity.EditingCursorName, .Hijos.PrivateCursor )
					* Aplico el filtro y verifico la posición del puntero
					If ! Empty( lcFiltro )
						Set Filter To &lcFiltro In Alias( .Hijos.PrivateCursor )
						Locate For &lcPKField = nIdEntity
					Endif
				Otherwise
			Endcase
		Else
			Error "No se pudo actualizar correctamente"
		Endif
	Endwith
Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError
Finally
	loError = Null
	loEntity = Null
Endtry

ENDPROC
PROCEDURE validateupdate
Lparameters nAction As Integer

#INCLUDE "FW\Tieradapter\Include\TA.h"

Local loParam As Object
Local lnTop As Integer
Local lnLeft As Integer
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local loEntity As Object
Local loParamFrmName As Object
Local lcFormName As String
Try
	* Limpio los mensajes de error
	loError = Thisform.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''

	With This As ABMChildContainer Of FW\Comunes\vcx\prxmainform.vcx
		loEntity = .oEntity
		llValid = .F.
		loParam = Createobject( 'Empty' )

		* Le paso el tipo de accion que debe realizar
		AddProperty( loParam, 'nProcessType', nAction )

		* El nombre del cursor que contiene el registro a editar
		AddProperty( loParam, 'EditingCursorName', loEntity.cEntityCursor )

		* El objeto oEntity
		AddProperty( loParam, 'oEntity', loEntity )

		* Ubicarlo a un costado del form
		lnTop = Thisform.Top + Objtoclient( .Hijos, 1 )
		lnLeft = Thisform.Left + Objtoclient( .Hijos, 2 ) + Objtoclient( .Hijos, 3 )
		AddProperty( loParam, 'Top', lnTop )
		AddProperty( loParam, 'Left', lnLeft )

		* Indica que es un ChildForm
		AddProperty( loParam, 'lIsChildForm', .T. )

		* nEntidadId para identificar el registro
		AddProperty( loParam, 'nEntidadId', loEntity.nEntidadId )

		* DataSessionID Para que compartan la misma Session de datos
		* La DataSessionId, para que trabajen ambos formularios en la misma DataSession
		* AddProperty( loParam, 'DataSessionId', Set( 'Datasession' ) )
		AddProperty( loParam, 'DataSessionID', Thisform.DataSessionId )

		* lModalWindowType Indica que el formulario es modal
		AddProperty( loParam, 'lModalWindowType', .T. )

		If nAction = TR_NEW
			loEntity.FilterEntity( 0, 3 )

		Endif && nAction = TR_NEW
		
		loParamFrmName = Createobject( 'Empty' )

		* @TODO Invertir el orden de los parametros
		If .HookBeforeLaunchForm( loParam, nAction, loParamFrmName )
			
			AddProperty( loParamFrmName, 'lIsChild', .T. )
			If ! Empty( .ChildFormName )
				AddProperty( loParamFrmName, 'cFormName', .ChildFormName )
			
			EndIf
			
			* DA 2009-07-17(10:02:39)
			* Tomo el nombre del formulario a lanzar
			lcFormName = Juststem( loEntity.GetFormName( loParamFrmName ) )
			loError.Ctracelogin = 'Antes de disparar el formulario ' + lcFormName

			* Do Form ( lcFormName ) With loParam To llValid
			llValid = Launchform( lcFormName, loParam, .T. )

		Endif

	Endwith
Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	* Limpio los mensajes de error
	loError = Thisform.oError
	loError.Ctracelogin = ''
	loError.Cremark = ''
	loError = Null

	loParam = Null
	loEntity = Null
	loParamFrmName = Null

Endtry

Return llValid

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
6[END RESERVED2]
[START RESERVED3]
childformname Nombre del Formulario que debe llamarse para editar la entidad
keeponinserting Indica si el método NewChild() continúa agregando items luego de la grabacíon
buttonsposition 1 - Al pie       2 -  Al Costado
editingcursorpk
cobjectfactoryfilename Nombre del archivo de configuracion que permite instanciar la Capa de Usuario
lkeeponinserting Indica si se continua agregando hijos despues de confirmado un ingreso
nreccount Lleva el control de la cantidad de registros de la grilla
nmaxrec Límite máximo de registros que puede contener la grilla
nminrec Límite mínimo de registros que puede contener la grilla
oparent Referencia a la entidad Padre
cparentconfigurationkey Nombre de la entidad padre
oldentidadid Guarda el Id de la entidad, para recuperarlo luego. Se utiliza en un NEW, para poder blanquear la propiedad nEntidadId del objeto oEntity.
activecount Devuelve la cantidad visible de elementos del Hijo
ckeyname cKeyName nombre unico en el sistema
hijos
caliasconfigurationkey Se utiliza cuando quiere generarse una nueva instancia de la clase
lischild Indica si el container se comporta como hijo de otro control
*contextualmenu 
*update 
*validateupdate 
*getentityid 
*filleditingrecord 
*updateprivatecursor 
*updateasociatedcursor 
*nreccount_assign 
*hookbeforelaunchform 
*hookafterupdate 
*llenarhijos 
*vaciarhijos 
*hijosconunregistro 
*hijoslleno 
*hijosvacio 
*oparent_access 
*new 
*classbeforenew 
*classafternew 
*hookbeforenew 
*hookafternew 
*edit 
*classbeforeedit 
*classafteredit 
*hookbeforeedit 
*hookafteredit 
*delete Delete Event.
*classbeforedelete 
*classafterdelete 
*hookbeforedelete 
*hookafterdelete 
*open 
*classbeforeopen 
*classafteropen 
*hookbeforeopen 
*hookafteropen 
*classbeforeupdate 
*classafterupdate 
*hookbeforeupdate 
*cancreate 
*canupdate 
*candelete 
*canread 
*setbuttons 
*classbeforesetbuttons 
*classaftersetbuttons 
*hookbeforesetbuttons 
*hookaftersetbuttons 
*activecount_access 
*cobjectfactoryfilename_access 
*classaftersynchronizebuttons 
*hijos_access 
*classafterllenarhijos 
*hookafterllenarhijos 
*calculatereccount Calcula la cantidad de registros del Container
*ckeyname_access 
*hooksubscribe 
*hooksubscribetoparent Delegado para que se conecte a los eventos del padre
*interactivechange Occurs when the user changes the value of a control using the keyboard or the mouse.
*hookonparentclear 
*hookonparentchange 
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]
[START RESERVED7]
Permite administrar las tablas hijas[END RESERVED7]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2NE0P8JN7
[CLASS] optionpanelbase
[CLASSLOC] prxmainform.vcx
[BASECLASS] container
[OBJNAME] OptionPanel
[PARENT] abmchildcontainer
[START PROPERTIES]
Top = 204
Left = 12
Width = 432
Height = 66
TabIndex = 2
ctarget = This.Parent
ngap = 0
ntoppadding = 0
nleftpadding = 0
nrightpadding = 0
nbottompadding = 0
Name = "OptionPanel"
Shape.Visible = .F.
Shape.Name = "Shape"
shpLabel.Visible = .F.
shpLabel.Name = "shpLabel"
lblTitulo.Left = 12
lblTitulo.Top = 0
lblTitulo.Visible = .F.
lblTitulo.TabIndex = 1
lblTitulo.Name = "lblTitulo"
[END PROPERTIES]
[START METHODS]
PROCEDURE classafterautosetup
Lparameters tlOnlyPosition As Boolean

#INCLUDE "FW\Comunes\Include\Praxis.h"

Local loCmd As CommandButton
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"

Try
	DoDefault( tlOnlyPosition )

	For Each loCmd In This.oColObjects
		lcName = Lower( loCmd.Name )
		Do Case
			Case Inlist( lcName, 'cmdnew', 'cmdedit', 'cmdopen' )
				If This.Parent.ButtonsPosition = 1
					loCmd.Anchor = ANCHOR_Left_Absolute

				Else
					loCmd.Anchor = ANCHOR_Top_Absolute
					
				Endif

			Case lcName = 'cmddelete'
				If This.Parent.ButtonsPosition = 1
					loCmd.Anchor = ANCHOR_Right_Absolute

				Else
					loCmd.Anchor = ANCHOR_Bottom_Absolute

				Endif

		Endcase
	Endfor

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError
Finally
	loError = Null
Endtry

ENDPROC[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2NE0P8JP4
[CLASS] new
[CLASSLOC] buttons.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdNew
[PARENT] abmchildcontainer.OptionPanel
[START PROPERTIES]
AutoSize = .F.
Top = 24
Left = 12
Height = 27
Width = 83
Picture = ..\image\bmp\new.bmp
DisabledPicture = ..\image\bmp\#new.bmp
Caption = "\<Agregar"
TabIndex = 2
ToolTipText = "Agrega un nuevo elemento"
SpecialEffect = 2
PictureSpacing = 1
Alignment = 0
lsamerowasprevious = .T.
lautosetup = .T.
Name = "cmdNew"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2NE0P8JPQ
[CLASS] edit
[CLASSLOC] buttons.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdEdit
[PARENT] abmchildcontainer.OptionPanel
[START PROPERTIES]
AutoSize = .F.
Top = 24
Left = 122
Width = 83
Picture = ..\image\bmp\edit.bmp
TabIndex = 3
SpecialEffect = 2
lsamerowasprevious = .T.
lautosetup = .T.
Name = "cmdEdit"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2NE0P8JQ8
[CLASS] open
[CLASSLOC] buttons.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdOpen
[PARENT] abmchildcontainer.OptionPanel
[START PROPERTIES]
AutoSize = .F.
Top = 24
Left = 232
Width = 83
Picture = ..\image\bmp\open.bmp
Caption = "Consultar"
TabIndex = 4
SpecialEffect = 2
lsamerowasprevious = .T.
lautosetup = .T.
Name = "cmdOpen"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2NE0P8JQT
[CLASS] delete
[CLASSLOC] buttons.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdDelete
[PARENT] abmchildcontainer.OptionPanel
[START PROPERTIES]
AutoSize = .F.
Top = 24
Left = 342
Width = 83
TabIndex = 5
SpecialEffect = 2
lsamerowasprevious = .T.
lautosetup = .T.
Name = "cmdDelete"
[END PROPERTIES]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] abmchildcontainer
[START PROPERTIES]
Arial, 0, 9, 5, 15, 12, 32, 3, 0
[END PROPERTIES]
[START RESERVED1]
  ..\..\tieradapter\include\ta.h^SîU ..\include\praxis.hfTs~\V ..\include\foxpro.hnUÊrûF ..\include\strings.hvVZOJ* ..\..\..\tools\namespaces\include\system.h~W±ÙF[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Z813RMVF
[CLASS] optionpanelbase
[CLASSLOC] prxmainform.vcx
[BASECLASS] container
[OBJNAME] tablenavigator
[START PROPERTIES]
Width = 252
Height = 32
BackStyle = 1
BorderWidth = 0
BackColor = 255,255,220
StatusBarText = "Examinar otros registros"
contractedwidth = 0
expandedwidth = 0
contractedheight = 0
expandedheight = 0
cfieldname = Descripcion,Codigo
cfieldnamelist = Descripcion,Codigo
lexpanded = .T.
_memberdata =     1601<VFPData><memberdata name="autofit" type="method" display="Autofit"/><memberdata name="nGap" type="property" display="nGap"/><memberdata name="lautofit" type="property" display="lAutofit"/><memberdata name="lautosetup" type="property" display="lAutoSetup"/><memberdata name="samerowasprevious" type="property" display="SameRowAsPrevious" favorites="True"/><memberdata name="fittoparent" type="method" display="FitToParent"/><memberdata name="nupdatefontsize" type="property" display="nUpdateFontSize"/><memberdata name="nupdatefontsize_assign" type="method" display="nUpdateFontSize_Assign"/><memberdata name="contract" type="method" display="Contract"/><memberdata name="expand" type="method" display="Expand"/><memberdata name="contractedwidth" type="property" display="ContractedWidth"/><memberdata name="expandedwidth" type="property" display="ExpandedWidth"/><memberdata name="contractedheight" type="property" display="ContractedHeight"/><memberdata name="expandedheight" type="property" display="ExpandedHeight"/><memberdata name="cfieldname" type="property" display="cFieldName" favorites="True"/><memberdata name="cfieldnamelist" type="property" display="cFieldNameList" favorites="True"/><memberdata name="nbutonslayout" type="property" display="nButonsLayout" favorites="True"/><memberdata name="lexpanded" type="property" display="lExpanded"/><memberdata name="getfilter" type="method" display="GetFilter"/><memberdata name="hookbeforegetfilter" type="method" display="HookBeforeGetFilter"/><memberdata name="classbeforegetfilter" type="method" display="ClassBeforeGetFilter"/></VFPData>

ntoppadding = 8
Name = "tablenavigator"
Shape.Top = 119
Shape.Left = -104
Shape.BackStyle = 1
Shape.BackColor = 255,255,220
Shape.Name = "Shape"
shpLabel.Top = -513
shpLabel.Left = 288
shpLabel.Name = "shpLabel"
lblTitulo.BackStyle = 0
lblTitulo.Left = -504
lblTitulo.Top = -513
lblTitulo.Visible = .F.
lblTitulo.TabIndex = 1
lblTitulo.Name = "lblTitulo"
[END PROPERTIES]
[START PROTECTED]
lexpanded
classbeforegetfilter
[END PROTECTED]
[START METHODS]
PROCEDURE Click

This.Expand()

ENDPROC
PROCEDURE MouseEnter
Lparameters nButton, nShift, nXCoord, nYCoord

Nodefault

ENDPROC
PROCEDURE autosetup
Lparameters tlOnlyPosition As Boolean

#INCLUDE "FW\Comunes\Include\Praxis.h"

Local lnTop As Integer
Local lnLeft As Integer
Local lnHeight As Integer
Local lnWidth As Integer
Local lnBottomsHeight As Integer
Local loError As ErrorHandler Of "fw\ErrorHandler\prxErrorHandler.prg"

Try
	With This As tablenavigator Of fw\comunes\vcx\prxmainform.vcx
		If .ClassBeforeAutosetup( tlOnlyPosition )
			If .HookBeforeAutosetup( tlOnlyPosition )
				.nLeftPadding = Iif( Vartype( .nLeftPadding )#'N', 0, .nLeftPadding )
				.nTopPadding = Iif( Vartype( .nTopPadding )#'N', 0, .nTopPadding )
				.nRightPadding = Iif( Vartype( .nRightPadding )#'N', 0, .nRightPadding )
				.nBottomPadding = Iif( Vartype( .nBottomPadding )#'N', 0, .nBottomPadding )

				lnLeft = .nLeftPadding
				lnTop = .nTopPadding
				lnHeight = 0
				lnWidth = 0
				.BorderWidth = 0

				With .picExpand
					If .Visible
						.Move( 0, Int( Abs( This.Height - .Height ) / 2 ) )
						lnLeft = lnLeft + .Width
						lnHeight = Max( lnHeight, .Height )
					Endif
				Endwith

				With .picContract
					If .Visible
						.Move( 0, This.picExpand.Top )

					Endif
				Endwith

				If .OrderBy.Visible
					lnBottomsHeight = .OrderBy.Height
					
				Else
					lnBottomsHeight = .cmdFirst.Height
					
				EndIf && .OrderBy.Visible

				With .cmdFirst As CommandButton
					.Top = lnTop
					.Left = lnLeft
					lnLeft = lnLeft + .Width
					If .Visible
						.Height = lnBottomsHeight
						lnHeight = Max( lnHeight, .Height )
						
					EndIf && .Visible
					
				Endwith

				With .CmdPrior As CommandButton
					.Top = lnTop
					.Left = lnLeft
					.Height = lnBottomsHeight
					If .Visible
						lnLeft = lnLeft + .Width
						lnHeight = Max( lnHeight, .Height )
					
					EndIf && .Visible
					
				Endwith

				With .OrderBy As prxcombobox Of fw\comunes\vcx\prxbase.vcx
					*!*	If Pemstatus( Thisform.oEntity, 'lHasCodigo', 5 )
					*!*		.Visible = Thisform.oEntity.lHasCodigo
					*!*	Endif
					If .Visible
						.AutoFit()
						.Height = Max( .Height, This.cmdFirst.Height )
						.Top = lnTop
						.Left = lnLeft
						lnLeft = lnLeft + .Width
						* lnHeight = This.nTopPadding + .Height + This.nBottomPadding
						lnHeight = Max( lnHeight, .Height )
						.ColumnWidths = Transform( .Width * 0.9 ) + ',0'
						
					EndIf && .Visible
					
				Endwith

				With .CmdNext As CommandButton
					.Top = lnTop
					.Left = lnLeft
					.Height = lnBottomsHeight
					If .Visible
						lnLeft = lnLeft + .Width
						lnHeight = Max( lnHeight, .Height )
						
					EndIf && .Visible
					
				Endwith

				With .CmdLast As CommandButton
					.Top = lnTop
					.Left = lnLeft
					.Height = lnBottomsHeight
					If .Visible
						lnLeft = lnLeft + .Width
						lnHeight = Max( lnHeight, .Height )
						
					EndIf && .Visible
					
				Endwith

				*!*	With .CmdClose As CommandButton
				*!*	    .Top = lnTop
				*!*	    .Left = lnLeft + This.nGap
				*!*	    .Height = lnBottomsHeight
				*!*	    If .Visible
				*!*	        lnLeft = lnLeft + .Width + This.nGap
				*!*	        lnHeight = Max( lnHeight, .Height )
				*!*	    Endif
				*!*	Endwith

				lnWidth = lnLeft + .nRightPadding

				.Height = .nTopPadding + lnHeight + .nBottomPadding
				.picExpand.Move( .picExpand.Left, Int( Abs( .Height - .picExpand.Height ) / 2 ) )
				.picContract.Move( .picExpand.Left, .picExpand.Top )

				.Width = lnWidth
				.ExpandedWidth = .Width
				* .ContractedWidth = .nLeftPadding + .picExpand.Width
				.ContractedWidth = .picExpand.Width && + .nGap
				.ExpandedHeight = .Height
				.ContractedHeight = .Height
				.ZOrder( 1 )
				.BorderWidth = 0
				.BackColor = .Parent.BackColor

				With .Shape As Shape
					.Top = 0
					.Left = 0
					.Height = This.Height
					.Width = This.Width
					.ZOrder( 1 )
					.Anchor = ANCHOR_Top_Absolute + ANCHOR_Left_Absolute ;
						+ ANCHOR_Bottom_Absolute + ANCHOR_Right_Absolute
				EndWith
				
				.HookAfterAutosetup()
				.ClassAfterAutosetup()
				
			EndIf
			
		EndIf
		
	EndWith
	
Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError
	
Finally
	loError = Null
	
Endtry

ENDPROC
PROCEDURE classafterautosetup
Lparameters tlOnlyPosition As Boolean

Nodefault

ENDPROC
PROCEDURE classbeforeautosetup
Lparameters tlOnlyPosition As Boolean

Local loEntity As UserTierAdapter Of "FW\TierAdapter\UserTier\UserTierAdapter.prg"
Local loColNavigator As PrxCollection Of "Fw\TierAdapter\Comun\PrxBaseLibrary.prg"
Local lcRowSource As String
Local loField As oField Of "Tools\Sincronizador\colDataBases.prg"
Local lnMax As Integer
Local lcCaption As String

loEntity = Thisform.oEntity
loColNavigator = loEntity.oColNavigator

If loColNavigator.Count > 0
	lcRowSource = ''
	With This.orderBy As ComboBox
		.RowSourceType = 0
		.ColumnCount = 2
		.BoundColumn = 2
		For Each loField In loColNavigator
			lcCaption = Alltrim( loField.Caption )
			.AddItem( lcCaption )
			.ListItem( .NewIndex, 2 ) = loField.Name

		EndFor
		
		.DisplayValue = Alltrim( loColNavigator.Item( 1 ).Caption )
		.ListIndex = 1
		
	Endwith

Else
	This.orderBy.Visible = .F.
	This.orderBy.Enabled = .F.

Endif && loColNavigator.Count > 0

Return DoDefault( tlOnlyPosition )

ENDPROCPROCEDURE classbeforeexecute
Lparameters tcMethod As String @, tcParameters As String @

Local lcFieldName as String
Local lcFilterCriteria as String

lcFieldName = Any2Char( This.OrderBy.ListItem( This.OrderBy.ListIndex, 2 ), .T. )
lcFilterCriteria = Any2Char( This.GetFilter(), .T. )

TEXT To tcParameters NoShow TextMerge Pretext 15
CreateObjParam( "cFieldName", <<lcFieldName>>,
				"cFilterCriteria", <<lcFilterCriteria>> )

ENDTEXT

Return DoDefault( @tcMethod, @tcParameters )

ENDPROC
PROCEDURE classbeforegetfilter
Lparameters tcFilter As String @

Return .T.

ENDPROC
PROCEDURE classbeforeinit

* DAE 2009-07-31(13:08:37)
*!*	With This As TableNavigator Of FW\Comunes\vcx\prxmainform.vcx
*!*	    If Empty( .orderBy.RowSource )
*!*	        .orderBy.ColumnCount = 1
*!*	        .orderBy.RowSource = 'Codigo,Descripcion'
*!*	        .orderBy.RowSourceType = 1
*!*	        .orderBy.DisplayValue = 'Codigo'
*!*	    Endif
*!*	Endwith

Return DoDefault()
ENDPROC
PROCEDURE contract
Lparameters tlFirstTime As Boolean

With This As tablenavigator Of fw\comunes\vcx\prxmainform.vcx
	If .lExpanded
		.lExpanded = .F.
		.Width = .ContractedWidth
		.Height = .ContractedHeight
		If ! tlFirstTime
			.Top = Thisform.Height - Thisform.nBottomPadding - .Height
		Endif
		.picExpand.Top = Int( Abs( .Height - .picExpand.Height ) / 2 )
		.picContract.Top = Int( Abs( .Height - .picContract.Height ) / 2 )
		.ToolTipText = "Expande los Botones de Navegación"
		.picExpand.Visible = .T.
		.picExpand.ToolTipText = .ToolTipText
		.picContract.Visible = .F.
		.picContract.ToolTipText = ''

		* DAE 2009-07-31(12:49:24)
		.cmdFirst.TabStop = .F.
		.CmdLast.TabStop = .F.
		.cmdNext.TabStop = .F.
		.cmdPrior.TabStop = .F.
		.orderBy.TabStop = .F.

		*!* If Pemstatus( Thisform, 'ActiveControl', 5 ) ;
		*!*		And Vartype( Thisform.ActiveControl ) = 'O' ;
		*!*	    And Pemstatus( Thisform.ActiveControl, 'SetFocus', 5 )
		If Type( 'Thisform.ActiveControl' ) = 'O' ;
				And Pemstatus( Thisform.ActiveControl, 'SetFocus', 5 )
			Thisform.ActiveControl.SetFocus()

		EndIf
		
		Thisform.Activate()
		Thisform.oGlobalSettings.oApp.SynchronizeButtons()

	Endif && .lExpanded

Endwith

ENDPROC
PROCEDURE expand

With This As tablenavigator Of fw\comunes\vcx\prxmainform.vcx
	If ! .lExpanded
		.lExpanded = .T.
		.picExpand.Visible = .F.
		.picContract.Visible = .T.
		.picExpand.ToolTipText = 'Contrae los Botones de Navegación'
		
		* DAE 2009-07-31(12:49:24)
		.cmdFirst.TabStop = .T.
		.CmdLast.TabStop = .T.
		.cmdNext.TabStop = .T.
		.cmdPrior.TabStop = .T.
		.orderBy.TabStop = .T.

		.Width = .ExpandedWidth
		.Height = .ExpandedHeight
		.Top = Thisform.Height - Thisform.nBottomPadding - .Height
		.ZOrder( 0 )
		.ToolTipText = ''

	Endif && ! .lExpanded

Endwith

ENDPROC
PROCEDURE getfilter

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local lcFilter As String
Local lcDefaultFilter As String
Local lcRet As String
Try
	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''
	lcFilter = ''
	lcDefaultFilter = ''
	If Thisform.lIsOk And This.ClassBeforeGetFilter( @lcFilter )
		If Thisform.lIsOk And This.HookBeforeGetFilter( @lcFilter )
			lcDefaultFilter = Thisform.oEntity.cNavigatorFilterCriteria

			Do Case
				Case ! Empty( lcFilter ) And ! Empty( lcDefaultFilter )
					lcRet = lcFilter + ' And ' + lcDefaultFilter

				Case ! Empty( lcFilter )
					lcRet = lcFilter

				Case ! Empty( lcDefaultFilter )
					lcRet = lcDefaultFilter

				Otherwise
					lcRet = ''
			Endcase

			If Empty( lcRet )
				lcRet = ''

			EndIf && Empty( lcRet )

		Endif && Thisform.lIsOk And This.HookBeforeGetFilter( @lcFilter )

	Endif && Thisform.lIsOk And This.ClassBeforeGetFilter( @lcFilter )

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''
	loError = Null

Endtry

Return lcRet

ENDPROC
PROCEDURE hookbeforegetfilter
Lparameters tcFilter as String @

Return .t.
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
8[END RESERVED2]
[START RESERVED3]
contractedwidth Ancho del control en estado contraído
expandedwidth Ancho del control cuando está expandido
contractedheight Altura cuando el control está contraído
expandedheight Altura cuando el control está expandido
cfieldname Nombre del campo activo
cfieldnamelist Lista de nombres, separados por comas, de los campos asociados al OptionGroup
lexpanded
*contract Contrae el control
*expand Expande el control
*getfilter 
*hookbeforegetfilter 
*classbeforegetfilter 
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Y50Y00YY
[CLASS] first
[CLASSLOC] buttons.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdFirst
[PARENT] tablenavigator
[START PROPERTIES]
Top = 5
Left = 24
Height = 25
Width = 24
Picture = ..\image\bmp\top.bmp
Caption = ""
TabIndex = 4
ToolTipText = "Primer registro"
Name = "cmdFirst"
[END PROPERTIES]
[START METHODS]
PROCEDURE hookafterinit

This.BackColor = This.Parent.BackColor

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Z814HYPT
[CLASS] prior
[CLASSLOC] buttons.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdPrior
[PARENT] tablenavigator
[START PROPERTIES]
Top = 5
Left = 48
Height = 25
Width = 24
Picture = ..\image\bmp\previous.bmp
Caption = ""
TabIndex = 5
ToolTipText = "Registro anterior"
Name = "cmdPrior"
[END PROPERTIES]
[START METHODS]
PROCEDURE hookafterinit

This.BackColor = This.Parent.BackColor

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Y50Y00YY
[CLASS] next
[CLASSLOC] buttons.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdNext
[PARENT] tablenavigator
[START PROPERTIES]
Top = 5
Left = 192
Height = 25
Width = 24
Picture = ..\image\bmp\next.bmp
Caption = ""
TabIndex = 7
ToolTipText = "Siguiente registro"
Name = "cmdNext"
[END PROPERTIES]
[START METHODS]
PROCEDURE hookafterinit

This.BackColor = This.Parent.BackColor

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _1Y50Y00YY
[CLASS] last
[CLASSLOC] buttons.vcx
[BASECLASS] commandbutton
[OBJNAME] cmdLast
[PARENT] tablenavigator
[START PROPERTIES]
Top = 5
Left = 216
Height = 25
Width = 24
Picture = ..\image\bmp\bottom.bmp
Caption = ""
TabIndex = 8
ToolTipText = "Ultimo registro"
Name = "cmdLast"
[END PROPERTIES]
[START METHODS]
PROCEDURE hookafterinit

This.BackColor = This.Parent.BackColor

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2NV11FGHF
[CLASS] prxcombobox
[CLASSLOC] prxbase.vcx
[BASECLASS] combobox
[OBJNAME] OrderBy
[PARENT] tablenavigator
[START PROPERTIES]
Height = 27
Left = 72
TabIndex = 6
Top = 4
Width = 120
nlength = 30
Name = "OrderBy"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2EM14SJ0X
[CLASS] prximage
[CLASSLOC] prxbase.vcx
[BASECLASS] image
[OBJNAME] picExpand
[PARENT] tablenavigator
[START PROPERTIES]
Picture = ..\image\bmp\grip.bmp
BackStyle = 0
Height = 32
Left = 0
Top = 0
Width = 16
Name = "picExpand"
[END PROPERTIES]
[START METHODS]
PROCEDURE Click

#INCLUDE "FW\TierAdapter\Include\TA.h"

If Thisform.nStatus # IS_EDITING
    This.Parent.Expand()

EndIf && Thisform.nStatus # IS_EDITING


ENDPROC
PROCEDURE MouseEnter
Lparameters nButton, nShift, nXCoord, nYCoord

#INCLUDE "FW\TierAdapter\Include\TA.h"

If Thisform.nStatus # IS_EDITING
    This.MousePointer = 15

EndIf && Thisform.nStatus # IS_EDITING




ENDPROC
PROCEDURE MouseLeave
Lparameters nButton, nShift, nXCoord, nYCoord

This.MousePointer = 0

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2OE0Z28C7
[CLASS] prximage
[CLASSLOC] prxbase.vcx
[BASECLASS] image
[OBJNAME] picContract
[PARENT] tablenavigator
[START PROPERTIES]
Picture = ..\image\bmp\grip2.bmp
BackStyle = 0
Height = 32
Left = 12
Top = 0
Width = 16
Name = "picContract"
[END PROPERTIES]
[START METHODS]
PROCEDURE Click

This.Parent.Contract()

ENDPROC
PROCEDURE MouseEnter
Lparameters nButton, nShift, nXCoord, nYCoord

This.MousePointer = 15



ENDPROC
PROCEDURE MouseLeave
Lparameters nButton, nShift, nXCoord, nYCoord

This.MousePointer = 0

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] tablenavigator
[START PROPERTIES]
Arial, 0, 9, 5, 15, 12, 32, 3, 0
[END PROPERTIES]
[START RESERVED1]
  ..\include\praxis.h¦s~\V ..\include\foxpro.h®ÊrûF ..\include\strings.h¶ZOJ* ..\..\..\tools\namespaces\include\system.h¾±ÙF ..\..\tieradapter\include\ta.hÆîU[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2EM14PYZC
[CLASS] abmchildcontainer
[CLASSLOC] prxmainform.vcx
[BASECLASS] container
[OBJNAME] abmchildgrid
[START PROPERTIES]
lsubscribetocolgrid = .T.
_memberdata =     3628<VFPData><memberdata name="autofit" type="method" display="Autofit"/><memberdata name="nGap" type="property" display="nGap"/><memberdata name="lautofit" type="property" display="lAutofit"/><memberdata name="samerowasprevious" type="property" display="SameRowAsPrevious" favorites="True"/><memberdata name="deletechild" type="method" display="DeleteChild"/><memberdata name="editchild" type="method" display="EditChild"/><memberdata name="addchild" type="method" display="AddChild"/><memberdata name="newchild" type="method" display="NewChild"/><memberdata name="fillgrid" type="method" display="FillGrid"/><memberdata name="deletevalid" type="method" display="DeleteValid"/><memberdata name="deletehook" type="method" display="DeleteHook"/><memberdata name="serialize" type="method" display="Serialize"/><memberdata name="getdata" type="method" display="GetData"/><memberdata name="emptygrid" type="method" display="EmptyGrid"/><memberdata name="synchronizebuttons" type="method" display="SynchronizeButtons"/><memberdata name="applydiffgram" type="method" display="ApplyDiffgram"/><memberdata name="getone" type="method" display="GetOne"/><memberdata name="launch" type="method" display="Launch"/><memberdata name="cconfignexttierfilename" type="property" display="cConfigNextTierFileName" favorites="True"/><memberdata name="dataconfigurationkey" type="property" display="DataConfigurationKey" favorites="True"/><memberdata name="grillallena" type="method" display="GrillaLlena"/><memberdata name="grillavacia" type="method" display="GrillaVacia"/><memberdata name="griilaconunregistro" type="method" display="GriilaConUnRegistro"/><memberdata name="grillaconunregistro" type="method" display="GrillaConUnRegistro"/><memberdata name="gridstatus" type="method" display="GridStatus"/><memberdata name="emptytree" type="method" display="EmptyTree"/><memberdata name="filltree" type="method" display="FillTree"/><memberdata name="fillcontrol" type="method" display="FillControl"/><memberdata name="emptycontrol" type="method" display="EmptyControl"/><memberdata name="parentconfigurationkey" type="property" display="ParentConfigurationKey" favorites="True"/><memberdata name="oldidentidad" type="property" display="OldIdEntidad"/><memberdata name="activecolumncount" type="property" display="ActiveColumnCount"/><memberdata name="activecolumncount_access" type="property" display="ActiveColumnCount_Access"/><memberdata name="visiblecount" type="property" display="VisibleCount"/><memberdata name="visiblecount_access" type="method" display="VisibleCount_Access"/><memberdata name="hijos_access" type="method" display="Hijos_Access"/><memberdata name="hookaftersetupentity" type="method" display="HookAfterSetupEntity"/><memberdata name="ceditingcursorname" type="property" display="cEditingCursorName" favorites="True"/><memberdata name="ceditingcursorname_access" type="method" display="cEditingCursorName_Access"/><memberdata name="ckeyname" type="property" display="cKeyName"/><memberdata name="classaftersynchronizebuttons" type="method" display="ClassAfterSynchronizeButtons"/><memberdata name="cobjectfactoryfilename_access" type="method" display="cObjectFactoryFileName_Access"/><memberdata name="hookbeforesetupentity" type="method" display="HookBeforeSetupEntity"/><memberdata name="ocolobjects_access" type="method" display="oColObjects_Access"/><memberdata name="classafterllenarhijos" type="method" display="ClassAfterLlenarHijos"/><memberdata name="hookafterllenarhijos" type="method" display="HookAfterLlenarHijos"/><memberdata name="lsubscribetocolgrid" type="property" display="lSubscribeToColGrid"/></VFPData>

Name = "abmchildgrid"
Shape.Name = "Shape"
shpLabel.Name = "shpLabel"
lblTitulo.TabIndex = 1
lblTitulo.Name = "lblTitulo"
OptionPanel.Shape.Name = "Shape"
OptionPanel.shpLabel.Name = "shpLabel"
OptionPanel.lblTitulo.Name = "lblTitulo"
OptionPanel.cmdNew.Name = "cmdNew"
OptionPanel.cmdEdit.Name = "cmdEdit"
OptionPanel.cmdOpen.Name = "cmdOpen"
OptionPanel.cmdDelete.Name = "cmdDelete"
OptionPanel.TabIndex = 3
OptionPanel.Name = "OptionPanel"
[END PROPERTIES]
[START METHODS]
PROCEDURE GotFocus
Try
	If Empty( This.nRecCount )
		This.OptionPanel.cmdNew.SetFocus()
	EndIf
	

Catch To oErr
	loError = ThisForm.oError
	ThisForm.cXMLoError = loError.Process( oErr )
	Throw loError

Finally

EndTry

ENDPROC
PROCEDURE activecount_access
Local loGridLayaut As oGridLayout Of "Fw\Comun\Prg\colGridLayout.prg"
Local i As Integer
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
     * Limpio los mensajes de error
    loError = Thisform.oError
    loError.Ctracelogin = ''
    loError.Cremark = ''

    With This As abmchildcontainer Of fw\comunes\vcx\prxmainform.vcx
        If Vartype(.ActiveCount ) # 'N' Or Empty( .ActiveCount )
            i = 0
            For Each loGridLayaut In .Hijos.oColGridLayout
                If !( loGridLayaut.ColumnWidth = 0 Or loGridLayaut.ColumnVisible = .F. )
                    i = i + 1

                EndIf && !( loGridLayaut.ColumnWidth = 0 Or loGridLayaut.ColumnVisible = .F. )

            Endfor
            .ActiveCount = i

        EndIf && Vartype(.ActiveCount ) # 'N' Or Empty( .ActiveCount )

    Endwith
Catch To oErr
    loError = ThisForm.oError
    ThisForm.cXMLoError = loError.Process( oErr )
    Throw loError

Finally
    loGridLayaut = Null

     * Limpio los mensajes de error
    loError = Thisform.oError
    loError.Ctracelogin = ''
    loError.Cremark = ''
    loError = Null

Endtry

Return This.ActiveCount

ENDPROC
PROCEDURE calculatereccount
Lparameters tcFilterCriteria As String

Local lnRecCount As Integer
Local lcEntityCursor As String
Local lcCommand As String

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''

	If Empty( tcFilterCriteria )
		tcFilterCriteria = ' 1 = 1 '

	Endif

	lnRecCount = 0
	lcEntityCursor = This.oEntity.cEntityCursor
	If Used( lcEntityCursor )

		lnRecNo = SaveRecNo( lcEntityCursor )

		TEXT TO lcCommand TEXTMERGE NOSHOW PRETEXT 15
			Calculate Cnt()
			For ! Deleted( '<<lcEntityCursor>>' ) And <<tcFilterCriteria>>
			To lnRecCount
			In <<lcEntityCursor>>

		ENDTEXT

		&lcCommand

		RestRecNo( lnRecNo, lcEntityCursor )

	Endif && Used( lcEntityCursor )

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''
	loError = Null

Endtry

Return lnRecCount



ENDPROC
PROCEDURE classafterautosetup
Lparameters tlOnlyPosition As Boolean

#INCLUDE "FW\Comunes\Include\Praxis.h"

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
    * Limpio los mensajes de error
    loError = Thisform.oError
    loError.Ctracelogin = ''
    loError.Cremark = ''

	With This As abmchildgrid Of FW\Comunes\vcx\prxmainform.vcx
		.GridHijos.Anchor = ANCHOR_Top_Absolute ;
			+ ANCHOR_Left_Absolute ;
			+ ANCHOR_Bottom_Absolute ;
			+ ANCHOR_Right_Absolute

	Endwith

	DoDefault( tlOnlyPosition )

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError
	
Finally
     * Limpio los mensajes de error
    loError = Thisform.oError
    loError.Ctracelogin = ''
    loError.Cremark = ''

	loError = Null
	
Endtry

ENDPROC
PROCEDURE classafterllenarhijos
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''

	With This.GridHijos
		If .ColumnCount > 0

			Do Case
				Case This.ActiveCount = 1
					* Si tiene una sola columna, que ocupe todo el ancho
					*!* .Columns[ 1 ].Width = .Width
					*!* .SetFocus()

					If ! Empty( .cFitColumn )
						For Each loColumn In .Columns
							If Lower( loColumn.Name ) = Lower( .cFitColumn )
								loColumn.Width = .Width

							Endif && Lower( loColumn.Name ) = Lower( .cFitColumn )

						Endfor

					Endif && ! Empty( .cFitColumn )

					.SetFocus()
				Case This.ActiveCount > 1
					* Si tiene más de una columna, adapto el ancho de la última para que
					* llene todo el espacio
					lnTotalWidth = 0
					For q = 1 To .ColumnCount
						lnTotalWidth = lnTotalWidth +  .Columns[ q ].Width

					Endfor

					If lnTotalWidth < .Width
						lnDifference = .Width - lnTotalWidth
						.Columns[ .ColumnCount ].Width =  .Columns[ .ColumnCount ].Width ;
							+ lnDifference

					Endif && lnTotalWidth < .Width
					.SetFocus()

			Endcase

		Endif && .ColumnCount > 0

	Endwith

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''
	loError = Null

Endtry

ENDPROC
PROCEDURE classbeforeinit

If This.lSubscribeToColGrid And Pemstatus( Thisform, "OnSubscribe", 5 )
	Bindevent( Thisform, "OnSubscribe", This, "HookSubscribe" )

Endif

Return DoDefault()

ENDPROC
PROCEDURE classbeforeupdate
Lparameters nAction As Integer

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local llOk As Boolean
Local loParent As utArchivo Of "FW\TierAdapter\UserTier\utArchivo.prg"

Try

	llOk = .T.
	*<###>
	* Filtrar los padres, porque cuando se selecciona un entidad padre,
	* Se dispara la relación nuevamente, y se pierde la posición actual de los
	* punteros.

	loParent = This.oEntity.oParent
	If Vartype( loParent ) = 'O'
		TEXT To lcCommand NoShow TextMerge Pretext 15
		Set Filter To <<loParent.cMainCursorPK>> = <<loParent.nEntidadId>> in <<loParent.cEntityCursor>>
		
		ENDTEXT

		&lcCommand

	Endif && Vartype( loParent ) = 'O'
	
Catch To oErr
	llOk = .F.
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loParent = Null
	loError = Null
	Thisform.oError.Cremark = ''
	Thisform.oError.Ctracelogin = ''

Endtry

Return llOk

ENDPROC
PROCEDURE hijos_access

With This As abmchildgrid Of FW\Comunes\vcx\prxmainform.vcx
	If Vartype( .Hijos ) # 'O'
		.Hijos = .GridHijos

	Endif && Vartype( .Hijos ) # 'O'

Endwith

Return DoDefault()

ENDPROC
PROCEDURE hookbeforelaunchform
Lparameters toParam as Object, tnAction as Integer, toParamFrmName as Object

Local llOk As Boolean

llOk = DoDefault( toParam, tnAction, toParamFrmName )

If llOk
	Local lnTop As Integer,;
		lnLeft As Integer
		
	* Ubicarlo a la Izquierda del form y Abajo,
	* tratando de que la Grilla no quede tapada
	lnTop = Thisform.Top + Objtoclient( This.Hijos, 1 ) + Objtoclient( This.Hijos, 4 )
	lnLeft = Thisform.Left + Objtoclient( This.Hijos, 2 ) + Objtoclient( This.Hijos, 3 )
	toParam.Top = lnTop
	toParam.Left = lnLeft

Endif

Return llOk

ENDPROC
PROCEDURE hooksubscribe
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
	With This As ABMChildGrid Of FW\Comunes\vcx\prxmainform.vcx
		If .lSubscribeToColGrid And Pemstatus( Thisform, "SubscribeToColGrid", 5 )
			Thisform.SubscribeToColGrid( This )

		Endif

	Endwith

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = Null

Endtry

ENDPROCPROCEDURE vaciarhijos

This.Hijos.Empty()
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
2[END RESERVED2]
[START RESERVED3]
lsubscribetocolgrid
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2EM14QT21
[CLASS] prxactiongrid
[CLASSLOC] prxmainform.vcx
[BASECLASS] grid
[OBJNAME] GridHijos
[PARENT] abmchildgrid
[START PROPERTIES]
Left = 32
TabIndex = 2
Top = 20
Name = "GridHijos"
[END PROPERTIES]
[START METHODS]
PROCEDURE DblClick
#INCLUDE "FW\TierAdapter\Include\TA.h"
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
	With This.Parent As abmchildgrid Of FW\Comunes\vcx\prxmainform.vcx
		Do Case
			Case Thisform.nStatus == IS_EDITING
				If .CanUpdate()
					.Edit()
					
				Else && .CanUpdate()
					Error 'No tiene permisos suficientes para realizar la operación'
					
				Endif && .CanUpdate()
				
			Otherwise
				If .CanRead()
					.Open()
					
				Else && .CanRead()
					Error 'No tiene permisos suficientes para realizar la operación'
					
				EndIf && .CanRead()
		Endcase
	Endwith

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	
Finally
	loError = Null
	
Endtry

ENDPROCPROCEDURE KeyPress
Lparameters nKeyCode As Integer, nShiftAltCtrl As Integer

#INCLUDE "FW\Comunes\Include\Praxis.h"
#INCLUDE "FW\Tieradapter\Include\TA.h"

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local llEditing As Boolean
Local llReading As Boolean
Try
	* DA 2009-10-23(08:30:05)
	* Agregue los focos a los botones del OptionPanel
	* Antes de ejecutar los eventos que abren el Childform
	
	llEditing = ( Thisform.nStatus = IS_EDITING )
	llReading = ( Thisform.nStatus = IS_READING )
	With This.Parent As ABMChildGrid Of FW\Comunes\vcx\prxmainform.vcx
		Do Case
			Case nShiftAltCtrl = 0
				Do Case
					Case nKeyCode = KEY_F4 And llEditing && F4 - New
						If .CanCreate()
							.OptionPanel.cmdNew.SetFocus()
							.New()
						Else
							Error 'No tiene permisos suficientes para realizar la operación'
						Endif

					Case nKeyCode = KEY_INS And llEditing && Ins - New
						If .CanCreate()
							.OptionPanel.cmdNew.SetFocus()
							.New()
						Else
							Error 'No tiene permisos suficientes para realizar la operación'
						Endif
					Case nKeyCode = KEY_F3 And llEditing && F3 - Modificar
						If .CanUpdate()
							.OptionPanel.cmdEdit.SetFocus()
							.Edit()
						Else
							Error 'No tiene permisos suficientes para realizar la operación'
						Endif

						* DAE 2009-07-01 (13:55:06)
						* Case nKeyCode = KEY_ENTRAR And llEditing && Enter - Modificar
					Case nKeyCode = KEY_ENTER
						Do Case
							Case llReading
								If .CanRead()
									.OptionPanel.cmdOpen.SetFocus()
									.Open()
								Else
									Error 'No tiene permisos suficientes para realizar la operación'
								Endif
							Case llEditing
								If .CanUpdate()
									.OptionPanel.cmdEdit.SetFocus()
									.Edit()
								Else
									Error 'No tiene permisos suficientes para realizar la operación'
								Endif
						Endcase
					Case nKeyCode = KEY_SUPR And llEditing && Del - Delete
						If .CanDelete()
							.Delete()
						Else
							Error 'No tiene permisos suficientes para realizar la operación'
						Endif
					Case nKeyCode = 93 && Tecla menu contextual
						.ContextualMenu( 'Hijos', Srows(), Int( Scols() / 2 ) )
					Otherwise
						DoDefault( nKeyCode, nShiftAltCtrl )
				Endcase
			Case Inlist( nShiftAltCtrl, 1, 2, 4 )
				Do Case
					Case nKeyCode = 93 && Tecla menu contextual
						.ContextualMenu( "Hijos", Srows(), Int(Scols()/2) )
					Otherwise
						DoDefault( nKeyCode, nShiftAltCtrl )
				Endcase
			Otherwise
				DoDefault( nKeyCode, nShiftAltCtrl )
		Endcase
	Endwith
Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
Finally
	loError = Null
Endtry


ENDPROC
PROCEDURE MouseDown
Lparameters nButton, nShift, nXCoord, nYCoord
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
	Do Case
		Case nButton = 2 And nShift = 0
			This.Parent.ContextualMenu( 'Hijos', Mrow(), Mcol() )
		Otherwise
			DoDefault( nButton, nShift, nXCoord, nYCoord )
	Endcase
Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
Finally
	loError = Null
Endtry


ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] abmchildgrid
[START PROPERTIES]
Arial, 0, 9, 5, 15, 12, 32, 3, 0
[END PROPERTIES]
[START RESERVED1]
  ..\include\praxis.h~ïs~\V ..\include\foxpro.hðÊrûF ..\include\strings.hñZOJ* ..\..\..\tools\namespaces\include\system.hò±ÙF ..\..\tieradapter\include\ta.hóîU[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2EM14SJ0X
[CLASS] abmchildcontainer
[CLASSLOC] prxmainform.vcx
[BASECLASS] container
[OBJNAME] abmchildtree
[START PROPERTIES]
clastevent = 
oimagelist = .NULL.
_memberdata =     6526<VFPData><memberdata name="autofit" type="method" display="Autofit"/><memberdata name="nGap" type="property" display="nGap"/><memberdata name="lautofit" type="property" display="lAutofit"/><memberdata name="lautosetup" type="property" display="lAutoSetup"/><memberdata name="samerowasprevious" type="property" display="SameRowAsPrevious" favorites="True"/><memberdata name="deletechild" type="method" display="DeleteChild"/><memberdata name="editchild" type="method" display="EditChild"/><memberdata name="addchild" type="method" display="AddChild"/><memberdata name="newchild" type="method" display="NewChild"/><memberdata name="contextualmenu" type="method" display="ContextualMenu"/><memberdata name="fillgrid" type="method" display="FillGrid"/><memberdata name="deletevalid" type="method" display="DeleteValid"/><memberdata name="deletehook" type="method" display="DeleteHook"/><memberdata name="childformname" type="property" display="ChildFormName" favorites="True"/><memberdata name="serialize" type="method" display="Serialize"/><memberdata name="getdata" type="method" display="GetData"/><memberdata name="keeponinserting" type="property" display="KeepOnInserting" favorites="True"/><memberdata name="emptygrid" type="method" display="EmptyGrid"/><memberdata name="buttonsposition" type="property" display="ButtonsPosition" favorites="True"/><memberdata name="synchronizebuttons" type="method" display="SynchronizeButtons"/><memberdata name="applydiffgram" type="method" display="ApplyDiffgram"/><memberdata name="update" type="method" display="Update"/><memberdata name="new" type="method" display="New"/><memberdata name="getone" type="method" display="GetOne"/><memberdata name="launch" type="method" display="Launch"/><memberdata name="editingcursorname" type="property" display="EditingCursorName" favorites="True"/><memberdata name="editingcursorpk" type="property" display="EditingCursorPK" favorites="True"/><memberdata name="editingcursorname_access" type="method" display="EditingCursorName_Access"/><memberdata name="validateupdate" type="method" display="ValidateUpdate"/><memberdata name="getentityid" type="method" display="GetEntityId"/><memberdata name="filleditingrecord" type="method" display="FillEditingRecord"/><memberdata name="updateprivatecursor" type="method" display="UpdatePrivateCursor"/><memberdata name="updateasociatedcursor" type="method" display="UpdateAsociatedCursor"/><memberdata name="cconfignexttierfilename" type="property" display="cConfigNextTierFileName" favorites="True"/><memberdata name="oentity" type="property" display="oEntity"/><memberdata name="dataconfigurationkey" type="property" display="DataConfigurationKey" favorites="True"/><memberdata name="oentity_access" type="method" display="oEntity_Access"/><memberdata name="lkeeponinserting" type="property" display="lKeepOnInserting" favorites="True"/><memberdata name="nreccount" type="property" display="nRecCount"/><memberdata name="nreccount_assign" type="property" display="nRecCount_Assign"/><memberdata name="nmaxrec" type="property" display="nMaxRec" favorites="True"/><memberdata name="nminrec" type="property" display="nMinRec" favorites="True"/><memberdata name="grillallena" type="method" display="GrillaLlena"/><memberdata name="grillavacia" type="method" display="GrillaVacia"/><memberdata name="griilaconunregistro" type="method" display="GriilaConUnRegistro"/><memberdata name="grillaconunregistro" type="method" display="GrillaConUnRegistro"/><memberdata name="hookbeforelaunchform" type="method" display="HookBeforeLaunchForm"/><memberdata name="gridstatus" type="method" display="GridStatus"/><memberdata name="hookafterupdate" type="method" display="HookAfterUpdate"/><memberdata name="emptytree" type="method" display="EmptyTree"/><memberdata name="filltree" type="method" display="FillTree"/><memberdata name="fillcontrol" type="method" display="FillControl"/><memberdata name="emptycontrol" type="method" display="EmptyControl"/><memberdata name="llenarhijos" type="method" display="LlenarHijos"/><memberdata name="vaciarhijos" type="method" display="VaciarHijos"/><memberdata name="hijosconunregistro" type="method" display="HijosConUnRegistro"/><memberdata name="hijoslleno" type="method" display="HijosLleno"/><memberdata name="hijosvacio" type="method" display="HijosVacio"/><memberdata name="oparent" type="property" display="oParent"/><memberdata name="oparent_access" type="property" display="oParent_Access"/><memberdata name="parentconfigurationkey" type="property" display="ParentConfigurationKey" favorites="True"/><memberdata name="oldidentidad" type="property" display="OldIdEntidad"/><memberdata name="activecolumncount" type="property" display="ActiveColumnCount"/><memberdata name="activecolumncount_access" type="property" display="ActiveColumnCount_Access"/><memberdata name="deletenodes" type="method" display="DeleteNodes"/><memberdata name="makepathtree" type="method" display="MakePathTree"/><memberdata name="hooknodeclick" type="method" display="HookNodeClick" favorites="True"/><memberdata name="clastevent" type="property" display="cLastEvent"/><memberdata name="hookselecteditem" type="method" display="HookSelectedItem"/><memberdata name="oimagelist" type="property" display="oImageList"/><memberdata name="oimagelist_access" type="method" display="oImageList_Access"/><memberdata name="ceditingcursorname" type="property" display="cEditingCursorName"/><memberdata name="ceditingcursorname_access" type="method" display="cEditingCursorName_Access"/><memberdata name="ckeyname" type="property" display="cKeyName"/><memberdata name="classafterllenarhijos" type="method" display="ClassAfterLlenarHijos"/><memberdata name="classaftersynchronizebuttons" type="method" display="ClassAfterSynchronizeButtons"/><memberdata name="cobjectfactoryfilename_access" type="method" display="cObjectFactoryFileName_Access"/><memberdata name="hookafterllenarhijos" type="method" display="HookAfterLlenarHijos"/><memberdata name="hookaftersetupentity" type="method" display="HookAfterSetupEntity"/><memberdata name="hookbeforesetupentity" type="method" display="HookBeforeSetupEntity"/><memberdata name="ocolobjects_access" type="method" display="oColObjects_Access"/><memberdata name="fillimages" type="method" display="FillImages"/><memberdata name="calculatereccount" type="method" display="CalculateRecCount"/><memberdata name="hooksetupobjinfo" type="method" display="HookSetupObjInfo"/><memberdata name="classsetupobjinfo" type="method" display="ClassSetupObjInfo"/></VFPData>

Name = "abmchildtree"
Shape.Top = 12
Shape.Left = 7
Shape.ZOrderSet = 0
Shape.Name = "Shape"
shpLabel.ZOrderSet = 2
shpLabel.Name = "shpLabel"
lblTitulo.TabIndex = 1
lblTitulo.ZOrderSet = 1
lblTitulo.Name = "lblTitulo"
OptionPanel.Shape.Name = "Shape"
OptionPanel.shpLabel.Name = "shpLabel"
OptionPanel.lblTitulo.Name = "lblTitulo"
OptionPanel.cmdNew.Name = "cmdNew"
OptionPanel.cmdEdit.Name = "cmdEdit"
OptionPanel.cmdOpen.Name = "cmdOpen"
OptionPanel.cmdDelete.Name = "cmdDelete"
OptionPanel.TabIndex = 4
OptionPanel.ZOrderSet = 3
OptionPanel.Name = "OptionPanel"
[END PROPERTIES]
[START PROTECTED]
classsetupobjinfo
[END PROTECTED]
[START METHODS]
PROCEDURE activecount_access

This.ActiveCount = This.TreeHijos.GetVisibleCount()

Return DoDefault()

ENDPROC
PROCEDURE calculatereccount
Lparameters tcFilterCriteria As String

Local lnRecCount As Integer

lnRecCount = This.TreeHijos.Nodes.Count

Return lnRecCount

ENDPROC
PROCEDURE classafterautosetup
Lparameters tlOnlyPosition As Boolean

#INCLUDE "FW\Comunes\Include\Praxis.h"

Try
    * Limpio los mensajes de error
    loError = Thisform.oError
    loError.cTraceLogin = ''
    loError.cRemark = ''

	With This As abmchildgrid Of FW\Comunes\vcx\prxmainform.vcx
		.TreeHijos.Anchor = ANCHOR_Top_Absolute ;
			+ ANCHOR_Left_Absolute ;
			+ ANCHOR_Bottom_Absolute ;
			+ ANCHOR_Right_Absolute

	Endwith

	DoDefault( tlOnlyPosition )

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError
	
Finally
     * Limpio los mensajes de error
    loError = Thisform.oError
    loError.cTraceLogin = ''
    loError.cRemark = ''

	loError = Null
	
Endtry

ENDPROC
PROCEDURE classafterinit

Try
	loError = Thisform.oError
	loError.cRemark = ''
	loError.cTraceLogin = ''

	DoDefault()
	* @TODO Chequear el nombre del Hook
	If Pemstatus( Thisform, 'Save', 5 )
		Bindevent( Thisform, 'Save', This, 'MakePathTree' )

	Endif && Pemstatus( Thisform, 'HookBeforeSave', 5 )

	If Pemstatus( This.TreeHijos, 'NodeClick', 5 )
		Bindevent( This.TreeHijos, 'NodeClick', This, 'HookNodeClick' )

	Endif && Pemstatus( This.TreeHijos, 'NodeClick', 5 )

	*!*	If Pemstatus( This.TreeHijos, 'DblClick', 5 )
	*!*		Bindevent( This.TreeHijos, 'DblClick', This, 'HookDblClick' )

	*!*	Endif && Pemstatus( This.TreeHijos, 'DblClick', 5 )

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )

Finally
	loError = Thisform.oError
	loError.cRemark = ''
	loError.cTraceLogin = ''
	loError = Null

Endtry

ENDPROC
PROCEDURE classafterupdate
Lparameters tnAction As Integer, tnIdEntity As Integer

#INCLUDE "FW\TierAdapter\Include\TA.h"

Local loNode As MSComctlLib.Node
Local loParent As MSComctlLib.Node
Local loNodeSelected As MSComctlLib.Node
Local lcNodeKey As String
Local lcNodeText As String
Local lnIdEntidad As Number

Local loTreeHijos As MSComctlLib.TreeView
Local loObj As Object

Try
	loError = Thisform.oError
	loError.cRemark = ''
	loError.cTraceLogin = ''
	With This As ABMChildtree Of FW\Comunes\vcx\prxmainform.vcx
		loTreeHijos = .TreeHijos
		loNodeSelected = loTreeHijos.SelectedItem()
		lnIdEntidad = tnIdEntity

		lcNodeText = .oEntity.GetLabel( lnIdEntidad )

		Do Case
			Case tnAction = TR_NEW
				* Agrego el nodo al Arbol
				lcNodeKey = Sys( 2015 ) + Sys( 2015 )
				*!* loObj = Createobject( 'Empty' )

				If Vartype( loNodeSelected ) # 'O'
					loNode = loTreeHijos.AddRoot( lcNodeText, lcNodeKey, 1, 1 )
					loNode.Expanded = .T.

					loObj = CreateObjParam( 'EsRaiz', .T., ;
						'EsHoja', .F., ;
						'EsRama', .T., ;
						'Id', lnIdEntidad, ;
						'oEntity', .oEntity )

				Else
					loNode = loTreeHijos.AddChild( lcNodeText, lcNodeKey, loNodeSelected.Key, 1, 1 )

					loObj = CreateObjParam( 'EsRaiz', .T., ;
						'EsHoja', .F., ;
						'EsRama', .F., ;
						'Id', lnIdEntidad, ;
						'oEntity', .oEntity )

					loNode.EnsureVisible()

				Endif && Vartype( loNodeSelected ) # 'O'
				Assert lnIdEntidad # 0 Message 'El Id de la entidad no puede ser = 0'

				This.HookSetupObjInfo( loObj )
				This.ClassSetupObjInfo( loObj )

				loTreeHijos.oColNodeData.Add( loObj, Lower( lcNodeKey ) )

			Case tnAction = TR_DELETE
				* Borro los nodos del Arbol
				If Vartype( loNodeSelected ) == 'O'
					* lcNodeKey = Lower( loNodeSelected.Key )
					lcNodeKey = loNodeSelected.Key

					If loNodeSelected.Children > 0
						.DeleteNodes( loNodeSelected )

					Endif && loNodeSelected.Children > 0

					loTreeHijos.oColNodeData.Remove( Lower( lcNodeKey ) )

					loTreeHijos.Remove( lcNodeKey )

				Else
					Error 'No hay ningún nodo selecionado'

				Endif && Vartype( loNodeSelected ) == 'O'

			Case tnAction = TR_UPDATE
				* Actualizo el nodo del Arbol
				If Vartype( loNodeSelected ) == 'O'
					loNodeSelected.Text = lcNodeText
					loParent = loNodeSelected.Parent

					If Vartype( loParent ) = "O"
						loParent.Sorted =  This.TreeHijos.Sorted

					Else && El nodo seleccionado es Root
						This.TreeHijos.Sorted =  This.TreeHijos.Sorted

					Endif




				Else
					Error 'No hay ningún nodo selecionado'

				Endif && Vartype( loNodeSelected ) == 'O'

		Endcase

		For Each loNode In loTreeHijos.Nodes
			lcNodeKey = Lower( loNode.Key )
			loObj = loTreeHijos.oColNodeData.GetItem( lcNodeKey )
			Assert Vartype( loObj ) = 'O' Message 'loObj No es Objeto'
			*!*	loNode.Tag.EsRaiz = Isnull( loNode.Parent )
			*!*	loNode.Tag.EsRama = ( loNode.Children > 0 )
			*!*	loNode.Tag.EsHoja = ( loNode.Children = 0 )
			loObj.EsRaiz = Isnull( loNode.Parent )
			loObj.EsRama = ( loNode.Children > 0 )
			loObj.EsHoja = ( loNode.Children = 0 )
			lnImage = loTreeHijos.GetImage( lnIdEntidad, loNode )
			loNode.Image = lnImage
			loNode.SelectedImage = lnImage

		Endfor

	Endwith

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = Thisform.oError
	loError.cRemark = ''
	loError.cTraceLogin = ''
	loError = Null
	loNodeSelected = Null
	loNode = Null
	loTreeHijos = Null
	loObj = Null
	loParent = Null

Endtry

Return .T.

ENDPROC
PROCEDURE classsetupobjinfo
Lparameters toParam As Object @


ENDPROC
PROCEDURE deletenodes
Lparameters toNode As MSComctlLib.Node
Local loNode As MSComctlLib.Node
Local loEntity As Object

Try
	With This As ABMChildtree Of FW\Comunes\vcx\prxmainform.vcx
		loEntity = .oEntity
		loNode = toNode.Child
		* Recorre los nodos en forma recursiva hasta que no haya mas nodos'
		Do While Vartype( loNode ) == 'O'
			If Vartype( loNode.Child ) == 'O'
				.DeleteNodes( loNode.Child )
				
			EndIf && Vartype( loNode.Child ) == 'O'
			* Avanzo al Siguiente nodo
			loNode = loNode.Next
			
		Enddo
		loEntity.nEntidadId = toNode.Tag.Id
		loEntity.DeleteEntity()
		
	Endwith
Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError
	
Finally
	toNode.Tag = Null
	loNode = Null
	loError = Null
	loEntity = Null
	
Endtry

ENDPROC
PROCEDURE getentityid
Lparameters tnAction As Integer

#INCLUDE "FW\TierAdapter\Include\TA.h"

Local lnIdEntity As Integer
Local loNode As MSComctlLib.Node

Try

	loNode = This.TreeHijos.SelectedItem()
	If Vartype( loNode ) = 'O'
		* Assert Vartype( loNode.Tag ) = 'O' Message 'El Tag no e sun nodo'
		* lnIdEntity = loNode.Tag.Id
		loObj = This.TreeHijos.oColNodeData.GetItem( loNode.Key )
		lnIdEntity = loObj.Id

	Endif && Vartype( loNode ) = 'O'

	If tnAction = TR_NEW
		lnIdEntity = 0

	Endif && tnAction = TR_NEW

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = Null
	loNode = Null

Endtry

Return lnIdEntity

ENDPROC
PROCEDURE hijos_access

With This As ABMChildTree Of FW\Comunes\vcx\prxmainform.vcx
	If Vartype( .Hijos ) # 'O'
		.Hijos = .TreeHijos

	Endif && Vartype( .Hijos ) # 'O'

Endwith

Return DoDefault()

ENDPROC
PROCEDURE hooknodeclick
Lparameters toNode As MSComctlLib.Node
ENDPROC
PROCEDURE hookselecteditem
Lparameters toNode As MSComctlLib.Node

ENDPROC
PROCEDURE hooksetupobjinfo
Lparameters toParam As Object @


ENDPROC
PROCEDURE makepathtree
Lparam toNode As MSComctlLib.Node, tnLevel As Number, tcSecuencia As String

Local loNode As MSComctlLib.Node
* Local lcPkKey As String
Local lRet As Boolean
Local lcSecuencia As String
Local lnSecuencia As Integer
Local lnParentHierarchicalId As Integer
Local loItem As Object
Local loItemParent As Object
Local lcParentKey as String

Try

	loNode = ifEmpty( toNode, Iif( This.TreeHijos.Nodes.Count > 0, This.TreeHijos.Nodes( 1 ), Null ) )

	tnLevel = ifEmpty( tnLevel, 1 )
	* lcPkKey = ""

	lnSecuencia = Asc( 'A' ) - 1

	If Empty( tcSecuencia )
		tcSecuencia = ''
	Endif && Empty( tcSecuencia )

	lRet = .T.
	* Recorre los nodos en forma recursiva hasta que no haya mas nodos'
	Do While Vartype( loNode ) == 'O'

		lnSecuencia = lnSecuencia + 1
		
		If Between( lnSecuencia, Asc( "a" ), Asc( "z" ) )
			lnSecuencia = Asc( "z" ) + 1
		Endif
		
		lcSecuencia = tcSecuencia + Chr( lnSecuencia )
		lcParentKey = tcSecuencia

		loItem = This.TreeHijos.oColNodeData.GetItem( loNode.Key )
		lnEntidadId = loItem.Id
		loEntity = loItem.oEntity

		If loEntity.lIsHierarchical
			If Vartype( loNode.Parent ) = 'O'
				loItemParent = This.TreeHijos.oColNodeData.GetItem( loNode.Parent.Key )
				lnParentHierarchicalId = loItemParent.Id

			Else
				lnParentHierarchicalId = 0

			Endif && Vartype( loNode.Parent ) = 'O'

			TEXT To lcCommand NoShow TextMerge Pretext 15
                Replace tvwNivel With <<tnLevel>>,
                        tvwSecuencia With '<<lcSecuencia>>',
                        ParentUniqueCode with '<<lcParentKey>>',
                        Parent<<loEntity.cMainCursorPk>> With <<lnParentHierarchicalId>>
                For <<loEntity.cMainCursorPk>> = <<lnEntidadId>>
                In <<loEntity.cEntityCursor>>
			ENDTEXT

		Else
			TEXT To lcCommand NoShow TextMerge Pretext 15
                Replace tvwNivel With <<tnLevel>>,
                        tvwSecuencia With '<<lcSecuencia>>',
                        ParentUniqueCode with '<<lcParentKey>>'
                For <<loEntity.cMainCursorPk>> = <<lnEntidadId>>
                In <<loEntity.cEntityCursor>>
			ENDTEXT

		Endif && loEntity.lIsHierarchical

		&lcCommand

		If Vartype( loNode.Child ) = 'O'
			* Recorro los Nodos que cuelgan del Nodo actual
			lRet = lRet And This.MakePathTree( loNode.Child, tnLevel + 1, lcSecuencia )

		Endif && Vartype( loNode.Child ) = 'O'

		* Avanzo al Siguiente nodo
		loNode= loNode.Next

	Enddo

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = Null
	loEntity = Null

Endtry

Return lRet


ENDPROC
PROCEDURE oimagelist_access

Local loEntity As uthierarchical Of fw\tieradapter\usertier\uthierarchical.prg
Local loImage As oImage Of fw\tieradapter\servicetier\sthierarchical.prg
Local loImg As Object
Local lcImgFile As String

Try

	lcImgFile = ""
	
	With This As ABMChildtree Of fw\Comunes\vcx\prxmainform.vcx
		If Vartype( .oImageList ) # 'O'

			loEntity = .oEntity
			For Each loImage In loEntity.oColImages
				Try
					loImg = .ImageList.ListImages.Item( loImage.cKey )
				Catch To oErr
					loImg = Null
				Endtry
				If Vartype( loImg ) # 'O'
					lcImgFile = Addbs( loImage.cFolder ) + loImage.cFileName
					loImg = .ImageList.ListImages.Add( , loImage.cKey, LoadPicture( lcImgFile ) )

				Endif && Vartype( loImg ) # 'O'

			Endfor

			* .ImageList.ListImages
			.oImageList = .ImageList
			
			.FillImages()

		Endif && Vartype( .oImageList ) # 'O'

	Endwith

Catch To oErr
	loError = Thisform.oError
	loError.cTraceLogin = "lcImgFile = " + Transform( lcImgFile )
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = Null
	loEntity = Null
	loImg = Null
	loImage = Null

Endtry

Return DoDefault()


ENDPROC
PROCEDURE updateprivatecursor
Lparameters nAction As Integer, nIdEntity As Integer

NoDefault
ENDPROC
PROCEDURE vaciarhijos

This.TreeHijos.Clear()
ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
3[END RESERVED2]
[START RESERVED3]
clastevent
*deletenodes 
*makepathtree 
*hooknodeclick Hook al evento NodeClick nativo del TreeView 
*hookselecteditem 
*fillimages 
*hooksetupobjinfo 
*classsetupobjinfo 
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2NH11G9JV
[CLASS] prxactiontree
[CLASSLOC] prxmainform.vcx
[BASECLASS] olecontrol
[OBJNAME] TreeHijos
[PARENT] abmchildtree
[START PROPERTIES]
Top = 24
Left = 12
Height = 168
Width = 372
TabIndex = 3
ZOrderSet = 4
Name = "TreeHijos"
[END PROPERTIES]
[START METHODS]
PROCEDURE KeyPress
*** ActiveX Control Event ***
Lparameters keyascii As Integer

#INCLUDE "FW\Comunes\Include\Praxis.h"
#INCLUDE "FW\TierAdapter\Include\TA.h"

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local lnShiftAltCtrl As Integer
Local lnKeyASCII As Integer
Local llIdle As Boolean
Local llEditing As Boolean

* Declare Integer GetKeyState In user32 Integer vKey
* @TODO Chequear si el usuario activo la combinacion de teclas Ctrl+F
llEditing = ( Thisform.nStatus == IS_EDITING )
llIdle = ( Thisform.nStatus == IS_IDLE ) && Inlist( Thisform.nStatus, IS_IDLE, IS_READING )

Try
	With This As prxtreeviewcontrol Of FW\Comunes\vcx\prxbase.vcx

		Debugout Datetime(), keyascii

		lnShiftAltCtrl = 0
		Do Case
			Case lnShiftAltCtrl = 0
				Do Case
					Case keyascii = KEY_INS
						If llEditing
							This.Parent.New()

						Endif && llEditing


					Case keyascii = KEY_SUPR
						If llEditing
							This.Parent.Delete()

						Endif && llEditing


					Case keyascii = KEY_ENTER
						If llEditing
							This.Parent.Edit()

						Else
							If ! llIdle
								This.Parent.Open()

							Endif && ! llIdle

						Endif && llEditing

					Case keyascii = Asc( '+' )
						If ! llIdle
							This.Parent.Open()

						Endif && ! llIdle

					Otherwise
						DoDefault( keyascii )

				Endcase

			Otherwise
				DoDefault( keyascii )

		Endcase
	Endwith
Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )

Finally
	loError = Null

Endtry

ENDPROC
[END METHODS]
[BINSTART OLE]
CHECKSUM=22049
[BINEND OLE]
[BINSTART OLE2]
CHECKSUM=11510
[BINEND OLE2]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2NH13HGFN
[CLASS] prximagelist
[CLASSLOC] prxbase.vcx
[BASECLASS] olecontrol
[OBJNAME] ImageList
[PARENT] abmchildtree
[START PROPERTIES]
Top = 0
Left = 420
Height = 100
Width = 100
Name = "ImageList"
[END PROPERTIES]
[BINSTART OLE]
CHECKSUM=8499
[BINEND OLE]
[BINSTART OLE2]
CHECKSUM=11510
[BINEND OLE2]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] abmchildtree
[START PROPERTIES]
Arial, 0, 9, 5, 15, 12, 32, 3, 0
[END PROPERTIES]
[START RESERVED1]
  ..\..\tieradapter\include\ta.h^SîU ..\include\praxis.hfTs~\V ..\include\foxpro.hnUÊrûF ..\include\strings.hvVZOJ* ..\..\..\tools\namespaces\include\system.h~W±ÙF[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2ND11CC2K
[CLASS] ccmarco
[CLASSLOC] controles_varios.vcx
[BASECLASS] container
[OBJNAME] optionpanelbase
[START PROPERTIES]
ctarget = ThisForm
otarget = .NULL.
_memberdata =     1505<VFPData><memberdata name="autofit" type="method" display="Autofit"/><memberdata name="nGap" type="property" display="nGap"/><memberdata name="lautofit" type="property" display="lAutofit"/><memberdata name="samerowasprevious" type="property" display="SameRowAsPrevious" favorites="True"/><memberdata name="nBottomPadding" type="Property" favorites="True"/><memberdata name="lresalttittle" type="property" display="lResaltTittle" favorites="True"/><memberdata name="resalttittle" type="method" display="ResaltTittle"/><memberdata name="readonly" type="property" display="ReadOnly" favorites="True"/><memberdata name="readonly_assign" type="property" display="ReadOnly_Assign"/><memberdata name="lsamerowasprevius" type="property" display="lSameRowAsPrevius"/><memberdata name="tabindex" type="property" favorites="True"/><memberdata name="ctarget" type="property" display="cTarget" favorites="True"/><memberdata name="ctarget_access" type="property" display="cTarget_Access"/><memberdata name="otarget" type="property" display="oTarget"/><memberdata name="otarget_access" type="property" display="oTarget_Access"/><memberdata name="execute" type="method" display="Execute"/><memberdata name="classbeforeexecute" type="method" display="ClassBeforeExecute"/><memberdata name="classafterexecute" type="method" display="ClassAfterExecute"/><memberdata name="hookbeforeexecute" type="method" display="HookBeforeExecute"/><memberdata name="hookafterexecute" type="method" display="HookAfterExecute"/></VFPData>

Name = "optionpanelbase"
Shape.Name = "Shape"
shpLabel.Name = "shpLabel"
lblTitulo.Name = "lblTitulo"
[END PROPERTIES]
[START PROTECTED]
otarget
classbeforeexecute
classafterexecute
[END PROTECTED]
[START METHODS]
PROCEDURE classbeforeexecute
Lparameters tcMethod As String @, tcParameters As String @

Return .T.

ENDPROC
PROCEDURE execute
Lparameters tcMethod As String, tcParameters As String

Local loTarget As Object
Local loControl As Object
Local lcParameters As String
Local lcMethod As String
Local loError As ErrorHandler Of 'Tools\ErrorHandler\Prg\ErrorHandler.prg'
Try
	lcMethod = Alltrim( tcMethod )
	If Pcount() = 2
		lcParameters = Alltrim( tcParameters )
	Else
		lcParameters = ''
	Endif

	With This As optionpanelbase Of FW\Comunes\vcx\prxmainform.vcx
		If .ClassBeforeExecute( @lcMethod, @lcParameters )
			If .HookBeforeExecute( @lcMethod, @lcParameters )
				loTarget = .oTarget
				* Verifica que el loTarget tenga el método tcMethod
				If Pemstatus( loTarget, lcMethod, 5 )
					* Si el objeto es un contenedor, y tiene un control activo,
					* obtiene el foco para forzar la actualizacion del valor
					Try
						* If Pemstatus( loTarget, 'ActiveControl', 5 ) ;
						And Vartype( loTarget.ActiveControl ) == 'O'
						If Type( 'loTarget.ActiveControl' ) == 'O'
							loControl = loTarget.ActiveControl
							If Pemstatus( loControl, 'SetFocus', 5 )
								loControl.SetFocus()

							Endif && Pemstatus( loControl, 'SetFocus', 5 )

						Endif && Type( 'loTarget.ActiveControl' ) == 'O'

					Catch To oErr
					Endtry
					* Arma la lista de parámetros
					lcParameters = Iif( Empty( lcParameters ), '', '( ' + lcParameters + ' )' )
					* Ejecuta el Método
					loTarget.&lcMethod &lcParameters
					.HookAfterExecute()
					.ClassAfterExecute()
				Endif
			Endif
		Endif
	Endwith
Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError
Finally
	loError = Null
	loTarget = Null
	loControl = Null
Endtry

ENDPROC
PROCEDURE hookbeforeexecute
Lparameters tcMethod As String @, tcParameters As String @

Return .T.

ENDPROCPROCEDURE otarget_access
Local lcTarget As String
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
    With This As optionpanelbase Of FW\Comunes\vcx\prxmainform.vcx
        If Vartype( .oTarget ) # 'O'
            lcTarget = .cTarget
            .oTarget = &lcTarget
        Endif
    Endwith
Catch To oErr
    loError = Thisform.oError
    Thisform.cXMLoError = loError.Process( oErr )
    Throw loError
Finally
    loError = Null
Endtry

Return This.oTarget


ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
ctarget
otarget
*execute 
*otarget_access 
*classbeforeexecute 
*classafterexecute 
*hookbeforeexecute 
*hookafterexecute 
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] optionpanelbase

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2NG0TB55D
[CLASS] prxtreeviewsearch
[CLASSLOC] prxsearch.vcx
[BASECLASS] olecontrol
[OBJNAME] prxactiontree
[START PROPERTIES]
Height = 100
Width = 100
oimagelist = .NULL.
clastevent = 
ocolnodedata = .NULL.
oentity = .NULL.
_memberdata =     2055<VFPData><memberdata name="empty" type="method" display="Empty"/><memberdata name="classbeforeempty" type="method" display="ClassBeforeEmpty"/><memberdata name="classafterempty" type="method" display="ClassAfterEmpty"/><memberdata name="hookbeforeempty" type="method" display="HookBeforeEmpty"/><memberdata name="hookafterempty" type="method" display="HookAfterEmpty"/><memberdata name="fill" type="method" display="Fill"/><memberdata name="classbeforefill" type="method" display="ClassBeforeFill"/><memberdata name="classafterfill" type="method" display="ClassAfterFill"/><memberdata name="hookbeforefill" type="method" display="HookBeforeFill"/><memberdata name="hookafterfill" type="method" display="HookAfterFill"/><memberdata name="oimagelist" type="property" display="oImageList"/><memberdata name="oimagelist_access" type="method" display="oImageList_Access"/><memberdata name="filltree" type="method" display="FillTree"/><memberdata name="classbeforefilltree" type="method" display="ClassBeforeFillTree"/><memberdata name="classafterfilltree" type="method" display="ClassAfterFillTree"/><memberdata name="hookbeforefilltree" type="method" display="HookBeforeFillTree"/><memberdata name="hookafterfilltree" type="method" display="HookAfterFillTree"/><memberdata name="oentity" type="property" display="oEntity" favorites="True"/><memberdata name="oentity_access" type="property" display="oEntity_Access" favorites="True"/><memberdata name="getimage" type="method" display="GetImage"/><memberdata name="clastevent" type="property" display="cLastEvent"/><memberdata name="ocolnodedata" type="property" display="oColNodeData"/><memberdata name="ocolnodedata_access" type="method" display="oColNodeData_Access"/><memberdata name="hookbeforegetimage" type="method" display="HookBeforeGetImage"/><memberdata name="hookaftergetimage" type="method" display="HookAfterGetImage"/><memberdata name="classaftergetimage" type="method" display="ClassAfterGetImage"/><memberdata name="classbeforegetimage" type="method" display="ClassBeforeGetImage"/></VFPData>

Name = "prxactiontree"
[END PROPERTIES]
[START PROTECTED]
classbeforeempty
classafterempty
classbeforefill
classafterfill
classbeforefilltree
classafterfilltree
classaftergetimage
classbeforegetimage
[END PROTECTED]
[START METHODS]
PROCEDURE MouseUp
*** ActiveX Control Event ***
Lparameters Button, Shift, x, Y

Local loNodeSeleted As MSComctlLib.Node
Local loNode As MSComctlLib.Node
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local lxCol As Number
Local lyRow As Number
Local lnLeft As Number
Local lnTop As Number
Local lnXCoord As Number
Local lnYCoord As Number
Local loEntity As Object

Try

	With This As prxActionTree Of "FW\Comun\vcx\prxmainform.vcx"
		loEntity = .oEntity
		If .cLastEvent # 'nodeclick'
			*!* lnRelation = 96/1440 && No se de donde sale esta relación
			*!*	lxCol = Mcol( 0, 3 )
			*!*	lyRow = Mrow( 0, 3 )
			*!*	lnLeft = Objtoclient( This, 2 )
			*!*	lnTop = Objtoclient( This, 1)
			*!*	lnXCoord = ( lxCol - lnLeft ) / lnRelation
			*!*	lnYCoord = ( lyRow - lnTop ) / lnRelation
			*!* loNode = .HitTest( lnXCoord, lnYCoord )
			loNode = .HitTest( x, Y )

			If Vartype( loNode ) # 'O'
				loNode = .SelectedItem
				If Vartype( loNode ) = 'O'
					loNode.Selected = .F.
				Endif
				loEntity.nEntidadId = 0
				loEntity.FilterEntity( 0, 1 )

			Endif && Vartype( loNode ) # 'O'

		Endif && .cLastEvent # 'NodeClick'

	Endwith

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	* Throw loError

Finally
	loEntity = Null
	loError = Null
	loNode = Null
	loNodeSeleted = Null
	This.cLastEvent = ''

Endtry

ENDPROC
PROCEDURE NodeClick
*** ActiveX Control Event ***
Lparameters Node As MSComctlLib.Node

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local loObj As Object
Local lcKey As String

Try
	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''

	With This As prxactiontree Of FW\Comunes\vcx\prxmainform.vcx
		.cLastEvent = 'nodeclick'
		* .oEntity.nEntidadId = Node.Tag.Id
		lcKey = Node.Key
		loObj = This.oColNodeData.GetItem( Lower( lcKey ) )
		.oEntity.nEntidadId = loObj.Id

		.SetSelected( lcKey )

		* DAE 2009-11-05(16:33:27)
		If Pemstatus( This.Parent, 'InteractiveChange', 5 )
			This.Parent.InteractiveChange(  loObj.Id )

		Endif && Pemstatus( This.Parent, 'InteractiveChange', 5 )

	Endwith

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )

Finally
	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''
	loError = Null
	loObj = Null

Endtry

ENDPROC
PROCEDURE classaftergetimage
Lparameters tnEntidadId As Integer, toNode As MSComctlLib.Node, tcImageKey as String @

ENDPROC
PROCEDURE classbeforeempty

Return .T.

ENDPROC
PROCEDURE classbeforefill

Return .T.

ENDPROC
PROCEDURE classbeforefilltree
Lparameters tcParentPK As String, tcParentNode As String

Return .T.

ENDPROC
PROCEDURE classbeforegetimage
Lparameters tnEntidadId As Integer @, toNode As MSComctlLib.Node


Return .T.

ENDPROC
PROCEDURE clear
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
	
	This.oColNodeData.Remove( - 1 )
	DoDefault()

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''
	loError = Null

Endtry


ENDPROCPROCEDURE empty
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"

Try

    loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''
	
    With This As prxactiontree Of FW\Comunes\vcx\prxmainform.vcx
        If .ClassBeforeEmpty()
            If .HookBeforeEmpty()
                .Clear()
                .HookAfterEmpty()
                .ClassAfterEmpty()

            EndIf && .HookBeforeEmpty()

        EndIf && .ClassBeforeEmpty()

    EndWith

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
    Throw loError

Finally
	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''
	loError = Null
	
Endtry

ENDPROC
PROCEDURE fill

Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local llLockScreen As Boolean
Local lcAlias As String
Local loEntity As UserTierAdapter Of "FW\TierAdapter\UserTier\UserTierAdapter.prg"
Local lcPk As String
Local lcNivel As String
Local lcKey As String
Local lcCursor As String
Local loNode As MSComctlLib.Node
Local loObj As Object
Local lcImageKey As String

Try
	lcAlias = Alias()
	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''

	With This As prxactiontree Of FW\Comunes\vcx\prxmainform.vcx
		If .ClassBeforeFill()
			If .HookBeforeFill()
				llLockScreen = Thisform.LockScreen
				Thisform.LockScreen = .T.
				If Vartype( .ImageList ) # 'O'
					.ImageList = .oImageList

				Endif && Vartype( .ImageList ) # 'O'

				loEntity = .oEntity

				.Clear()
				* .FillTree()

				lcEntityCursor = loEntity.cEntityCursor
				lcPk = loEntity.cMainCursorPk
				lcNivel = lcEntityCursor + '.tvwnivel'
				lcCursor = 'csr' + Sys( 2015 )
				If Used( lcEntityCursor )
					* Select Alias( lcEntityCursor )
					* Locate
					TEXT To lcCommand NoShow TextMerge Pretext 15
						Select <<lcPk>>, tvwSecuencia, tvwnivel
						From <<lcEntityCursor>>
						Where ! Deleted( '<<lcEntityCursor>>' )
						Order By tvwSecuencia
						Into Cursor <<lcCursor>>
					ENDTEXT

					&lcCommand

					Select Alias( lcCursor )
					Locate

					Scan While Thisform.lIsOk
						With This As prxactiontree Of FW\Comunes\vcx\prxmainform.vcx
							lnEntidadId = Evaluate( lcEntityCursor + '.' + lcPk )
							loEntity.nEntidadId = lnEntidadId
							lcLabelText = loEntity.GetLabel( lnEntidadId )
							lcKey = Alltrim( Evaluate( lcEntityCursor + '.tvwSecuencia' ) )
							llEsRaiz = Evaluate( lcCursor + '.tvwnivel' ) = 1
							If llEsRaiz
								loNode = .AddRoot( lcLabelText, lcKey )

							Else
								*!*	lcKeyParent = Left( lcKey, Len( lcKey ) - 1 )
								lcKeyParent = Alltrim( Evaluate( lcEntityCursor + '.ParentUniqueCode' ) )
								loNode = .AddChild( lcLabelText, lcKey, lcKeyParent )

							Endif && Evaluate( lcNivel ) = 1
							loObj = CreateObjParam( ;
								'EsRaiz', llEsRaiz, ;
								'EsHoja', .F., ;
								'EsRama', .F., ;
								'Id', lnEntidadId, ;
								'oEntity', loEntity )

							.oColNodeData.Add( loObj, Lower( lcKey ) )

						Endwith

					Endscan

					Use In Select( lcCursor )

				Endif && Used( lcEntityCursor )

				For Each loNode In This.Nodes
					loObj = .oColNodeData.GetItem( Lower( loNode.Key ) )
					Assert Vartype( loObj ) = 'O' Message 'loObj no es Objeto'
					loObj.EsHoja = ( loNode.Children = 0 )
					loObj.EsRama = ( loNode.Children > 0 )


					If loNode.Children > 0
						loNode.Expanded = loEntity.lExpandNodeOnInit

					Endif && loNode.Children > 0

					* Cambio las imagenes
					lcImageKey = .GetImage( loObj.Id, loNode )

					loNode.Image = lcImageKey
					loNode.SelectedImage = lcImageKey

				Endfor

				.HookAfterFill()
				.ClassAfterFill()

			Endif && .HookBeforeFill()

		Endif && .ClassBeforeFill()

	Endwith

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	Thisform.LockScreen = llLockScreen
	If This.Nodes.Count > 0
		* @TODO Consultar cual es el Nodo que queda selecionado
		* al cargar el Tree
		loNode =  This.Nodes.Item( 1 )
		loNode.Selected = .T.
		* This.SetSelectItem( loNode.Key )
		This.SetSelected( loNode.Key )

	Endif && This.Nodes.Count > 0

	loEntity = Null

	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''
	loError = Null

	loObj = Null
	loNode = Null


	Use In Select( lcCursor )

	If Used( lcAlias )
		Select Alias( lcAlias )

	Endif && Used( lcAlias )

Endtry

ENDPROC
PROCEDURE filltree
Lparameters tcParentPK As String, tcParentNode As String

Local lbRet As Boolean
Local lcExp As String
Local lcNodeKey As String
Local lcNodeText As String
Local lChangeProc As Boolean
Local llLockScreen As Boolean
Local lnCnt As Integer
Local lObj As Object
Local loNode As MSComctlLib.Node
Local llLockScreen As Boolean
Local lnPK As Number
Local lcCursorName As String
Local lnImage As Number
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Local lcEntityCursor As String
Local lcTreeParentPKField As String
Local loEntity As Object

* @TODO Modificar el procedimiento para cargar de forma iterativa y no de forma recursiva
Try
	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''
	With This As prxactiontree Of FW\Comunes\vcx\prxmainform.vcx
		* tcParentPK = Alltrim( ifEmpty( tcParentPK, '' ) )
		tcParentPK = Iif( Vartype( tcParentPK ) = 'C', Alltrim( tcParentPK ),  '' )

		* tcParentNode = Alltrim( ifEmpty( tcParentNode, '' ) )
		tcParentNode = Iif( Vartype( tcParentNode ) = 'C', Alltrim( tcParentNode ),  '' )

		If .ClassBeforeFillTree( tcParentPK, tcParentNode )
			If .HookBeforeFillTree( tcParentPK, tcParentNode )
				loEntity = .oEntity
				lbRet = .T.
				lcEntityCursor = loEntity.cEntityCursor
				If Used( lcEntityCursor )
					* Nombre del cursor temporal
					lcCursorName = 'csr' + Sys( 2015 ) + Sys( 2015 )
					lcTreeParentPKField = loEntity.cTreeParentPKField
					* Consulta para seleccionar los hijos del Nodo
					TEXT To lcExp NoShow TextMerge Pretext 15
                    	select * from <<lcEntityCursor>>
                    	where ! Deleted('<<lcEntityCursor>>')
                    	And <<lcTreeParentPKField>> == '<<tcParentPK>>'

					ENDTEXT

					lcTreeOrderBy = loEntity.cTreeOrderBy
					If ! Empty( lcTreeOrderBy )
						TEXT To lcExp NoShow TextMerge Pretext 15 ADDITIVE
            				order by <<lcTreeOrderBy>>

						ENDTEXT
					Endif

					TEXT To lcExp NoShow TextMerge Pretext 15 ADDITIVE
            			into cursor <<lcCursorName>>

					ENDTEXT
					* Ejecuto el select
					&lcExp

					Select Alias( lcCursorName )
					Locate
					Scan
						* Clave primaria del registro para cargar los nodos hijos
						lcTreePKField = Evaluate( lcCursorName + '.' + loEntity.cTreePKField )
						* Clave del Nodo
						lcNodeKey = Sys( 2015 ) + Sys( 2015 )
						* Texto del Nodo
						lcNodeText = loEntity.GetLabel( Evaluate( lcCursorName + '.' + loEntity.cMainCursorPk ) )
						* IdEntidad
						lnPK = Evaluate( lcCursorName + '.' + loEntity.cMainCursorPk )

						If Empty( tcParentNode )
							loNode = .AddRoot( lcNodeText, lcNodeKey, 1, 1 )

						Else
							loNode = .AddChild( lcNodeText, lcNodeKey, tcParentNode, 1, 1 )

						Endif && Empty( tcParentNode )

						* Creo el objeto para agregar en el Tag del Nodo
						*!*	lObj = Createobject( 'Empty' )
						*!*	AddProperty( lObj, 'EsRaiz', Empty( tcParentNode ) )
						*!*	AddProperty( lObj, 'EsHoja', ( loNode.Children = 0 ) )
						*!*	AddProperty( lObj, 'EsRama', ( loNode.Children > 0 ) )
						*!*	AddProperty( lObj, 'Id', lnPK )

						loObj = CreateObjParam( 'EsRaiz', Empty( tcParentNode ), ;
							'EsHoja', ( loNode.Children = 0 ), ;
							'EsRama', ( loNode.Children > 0 ), ;
							'Id', lnPK )
						loNode.Tag = lObj

						Select Alias( lcCursorName )
						lbRet = lbRet And .FillTree( lcTreePKField, lcNodeKey )

						Select Alias( lcCursorName )
						lbRet = lbRet And .HookAfterFillTree( lnPK, lcTreePKField, lcNodeKey )

						Select Alias( lcCursorName )

						* Actualizo los datos del Tag de los campos
						* EsHoja
						* EsRama
						* Despues de ejecutar el FillTree y el HookAfterFillTree
						loNode.Tag.EsHoja = ( loNode.Children = 0 )
						loNode.Tag.EsRama = ( loNode.Children > 0 )

						If loNode.Children > 0
							loNode.Expanded = loEntity.lExpandNodeOnInit

						Endif && loNode.Children > 0

						* Cambio las imagenes
						lnImage = .GetImage( lnPK, loNode )
						Assert lnImage > 0 Message 'No devolvio imagen'

						loNode.Image = lnImage
						loNode.SelectedImage = lnImage

					Endscan

					Use In Select( Alias( lcCursorName ) )

				Endif

			Endif
		Endif
	Endwith
Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	lbRet = .F.
	Throw loError

Finally
	loNode = Null
	lObj = Null

	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''
	loError = Null

Endtry

Return lbRet


ENDPROC
PROCEDURE getimage
Lparameters tnEntidadId As Integer, toNode As MSComctlLib.Node

Local lcImageKey As String
Local loEntity As utHierarchical Of "FW\Tieradapter\UserTier\utHierarchical.prg"
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"

Try
	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''
	lcImageKey = ''

	If This.ClassBeforeGetImage( @tnEntidadId, toNode )
	
		If This.HookBeforeGetImage( @tnEntidadId, toNode )

			loEntity = This.oEntity
			If Empty( tnEntidadId )
				loObj = This.oColNodeData.GetItem( toNode.Key )
				tnEntidadId = loObj.Id

			Endif && Empty( tnEntidadId )

			lcImageKey = loEntity.GetImage( tnEntidadId, ;
				( Vartype( toNode.Parent ) # 'O' ), ;
				toNode.Expanded, ;
				( toNode.Children > 0 ), ;
				toNode.Selected )

			This.HookAfterGetImage( tnEntidadId, toNode, @lcImageKey )
			
			This.ClassAfterGetImage( tnEntidadId, toNode, @lcImageKey  )
			
		Endif && This.ClasBeforeGetImage( @tnEntidadId, toNode )

	Endif && This.ClasBeforeGetImage( @tnEntidadId, toNode )

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''
	loError = Null
	loObj = Null

Endtry

Return lcImageKey



ENDPROC
PROCEDURE hookafterfilltree

Return .T.

ENDPROC
PROCEDURE hookaftergetimage
Lparameters tnEntidadId As Integer, toNode As MSComctlLib.Node, tcImageKey as String @

ENDPROC
PROCEDURE hookbeforeempty

Return .T.

ENDPROC
PROCEDURE hookbeforefill

Return .T.

ENDPROC
PROCEDURE hookbeforefilltree
Lparameters tcParentPK As String, tcParentNode As String

Return .T.

ENDPROC
PROCEDURE hookbeforegetimage
Lparameters tnEntidadId As Integer @, toNode As MSComctlLib.Node


Return .T.

ENDPROC
PROCEDURE ocolnodedata_access

With This As prxactiontree Of fw\comunes\vcx\prxmainform.vcx
	If Vartype( .oColNodeData ) # 'O'
		.oColNodeData = Newobject( 'prxCollection', 'prxbaselibrary.prg' )

	EndIf && Vartype( .oColNodeData ) # 'O'

Endwith

Return This.oColNodeData

ENDPROC
PROCEDURE oentity_access
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"

Try
    With This As prxactiongrid Of fw\comunes\vcx\prxmainform.vcx
        If Vartype( .oEntity ) # 'O' And !Thisform.lExit
            .oEntity = .Parent.oEntity

        EndIf && Vartype( .oEntity ) # 'O'

    EndWith

Catch To oErr
    loError = Thisform.oError
    Thisform.cXMLoError = loError.Process( oErr )
    Throw loError

Finally
    loError = Null

EndTry

Return This.oEntity


ENDPROC
PROCEDURE oimagelist_access
Local loError As ErrorHandler Of "Tools\ErrorHandler\Prg\ErrorHandler.prg"
Try
	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''
	With This As prxactiontree Of FW\Comunes\vcx\prxmainform.vcx
		If Vartype( .oImageList ) # 'O'
			.oImageList = .Parent.oImageList

		Endif && Vartype( .oImageList ) # 'O'

	Endwith

Catch To oErr
	loError = Thisform.oError
	Thisform.cXMLoError = loError.Process( oErr )
	Throw loError

Finally
	loError = Thisform.oError
	loError.Cremark = ''
	loError.Ctracelogin = ''
	loError = Null

Endtry
Return This.oImageList

ENDPROC
[END METHODS]
[BINSTART OLE]
CHECKSUM=28321
[BINEND OLE]
[BINSTART OLE2]
CHECKSUM=5108
[BINEND OLE2]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
oimagelist
clastevent
ocolnodedata Almacena información adicional de los nodos
*empty 
*classbeforeempty 
*classafterempty 
*hookbeforeempty 
*hookafterempty 
*fill 
*classbeforefill 
*classafterfill 
*hookbeforefill 
*hookafterfill 
*oimagelist_access 
*filltree 
*classbeforefilltree 
*classafterfilltree 
*hookbeforefilltree 
*hookafterfilltree 
*getimage 
*ocolnodedata_access 
*hookbeforegetimage 
*hookaftergetimage 
*classaftergetimage 
*classbeforegetimage 
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] prxactiontree

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2P40SVF47
[CLASS] marcoinvisible
[CLASSLOC] controles_varios.vcx
[BASECLASS] container
[OBJNAME] optionpanelcombo
[START PROPERTIES]
Width = 598
Height = 92
Name = "optionpanelcombo"
Shape.Top = 0
Shape.Left = 0
Shape.Height = 180
Shape.Width = 1152
Shape.Name = "Shape"
shpLabel.Name = "shpLabel"
lblTitulo.Name = "lblTitulo"
[END PROPERTIES]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
3[END RESERVED2]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2P40SYXKU
[CLASS] tablenavigator
[CLASSLOC] prxmainform.vcx
[BASECLASS] container
[OBJNAME] Tablenavigator1
[PARENT] optionpanelcombo
[START PROPERTIES]
Top = 7
Left = 8
Name = "Tablenavigator1"
Shape.Name = "Shape"
shpLabel.Name = "shpLabel"
lblTitulo.Name = "lblTitulo"
cmdFirst.Name = "cmdFirst"
cmdPrior.Name = "cmdPrior"
cmdnext.Name = "cmdnext"
cmdLast.Name = "cmdLast"
ORDERBY.Name = "ORDERBY"
picExpand.Height = 32
picExpand.Width = 16
picExpand.Name = "picExpand"
picContract.Height = 32
picContract.Width = 16
picContract.Name = "picContract"
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _2P40SYXNI
[CLASS] optionpanel
[CLASSLOC] prxmainform.vcx
[BASECLASS] container
[OBJNAME] Optionpanel1
[PARENT] optionpanelcombo
[START PROPERTIES]
Top = 41
Left = 8
Name = "Optionpanel1"
Shape.Name = "Shape"
shpLabel.Name = "shpLabel"
lblTitulo.Name = "lblTitulo"
cmdClose.Name = "cmdClose"
cmdDelete.Name = "cmdDelete"
cmdNew.Name = "cmdNew"
cmdSave.Name = "cmdSave"
cmdOpen.Name = "cmdOpen"
cmdReport.Name = "cmdReport"
cmdEdit.Name = "cmdEdit"
[END PROPERTIES]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] optionpanelcombo
[START PROPERTIES]
Arial, 0, 9, 5, 15, 12, 32, 3, 0
[END PROPERTIES]
[EOF]
