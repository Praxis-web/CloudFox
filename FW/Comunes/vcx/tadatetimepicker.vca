SCCTEXT Version 4.0.0.2
PLATFORM C(8,0),UNIQUEID C(10,0),TIMESTAMP N(10,0),CLASS M(4,0),CLASSLOC M(4,0),BASECLASS M(4,0),OBJNAME M(4,0),PARENT M(4,0),PROPERTIES M(4,0),PROTECTED M(4,0),METHODS M(4,0),OBJCODE M(4,0),OLE M(4,0),OLE2 M(4,0),RESERVED1 M(4,0),RESERVED2 M(4,0),RESERVED3 M(4,0),RESERVED4 M(4,0),RESERVED5 M(4,0),RESERVED6 M(4,0),RESERVED7 M(4,0),RESERVED8 M(4,0),USER M(4,0)
1252

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] Class     
[START RESERVED1]
VERSION =   3.00[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _0C60OH0UM
[CLASS] form
[BASECLASS] form
[OBJNAME] caldatemonth
[START PROPERTIES]
Top = 0
Left = 0
Height = 134
Width = 140
Desktop = .T.
ShowWindow = 2
DoCreate = .T.
Tag = "W=172,H=166"
BorderStyle = 2
Caption = ""
ControlBox = .F.
Closable = .F.
FontSize = 8
MaxButton = .F.
MinButton = .F.
Movable = .F.
Visible = .F.
TitleBar = 0
AlwaysOnTop = .T.
oparent = .NULL.
Name = "caldatemonth"
[END PROPERTIES]
[START METHODS]
PROCEDURE Deactivate
WITH THISFORM
	IF NOT ISNULL( .oParent )
		.oParent.SETFOCUS()	&& Go back to the parent object
		.oParent = .NULL.
	ENDIF
	.VISIBLE = .F.			&& Hode the calendar
ENDWITH

ENDPROC
PROCEDURE Show
LPARAMETERS nStyle

THIS.taCalendar.Setfocus()	&& Make sure we're on the calendar object

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
2[END RESERVED2]
[START RESERVED3]
oparent Parent object
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _0L115QS04
[CLASS] tacalendar
[CLASSLOC] tacal.vcx
[BASECLASS] container
[OBJNAME] taCalendar
[PARENT] caldatemonth
[START PROPERTIES]
Top = 0
Left = 0
BorderWidth = 0
Name = "taCalendar"
txtControl.Name = "txtControl"
cntHeader.cmdLastMonth.Name = "cmdLastMonth"
cntHeader.cmdNextMonth.Name = "cmdNextMonth"
cntHeader.lblMonthYear.Name = "lblMonthYear"
cntHeader.Name = "cntHeader"
[END PROPERTIES]
[START METHODS]
PROCEDURE canceldate
WITH THIS.PARENT
	.VISIBLE = .F.		&& Hide the calendar
	.oParent.Setfocus()	&& Go back to the parent object
ENDWITH

ENDPROC
PROCEDURE selectdate
LPARAMETERS lddateselected

WITH THIS.PARENT
	.oParent.dDateTime = ( .oParent.dDateTime - DTOT( TTOD( .oParent.dDateTime ) ) ) + ;
		DTOT( lddateselected )	&& Load selected date
	.VISIBLE = .F.				&& Hide the calendar
	.oParent.SETFOCUS()			&& Go back to parent object
ENDWITH

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] caldatemonth
[START PROPERTIES]
Arial, 0, 8, 5, 14, 11, 30, 3, 0
Arial, 0, 9, 5, 15, 12, 32, 3, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _0CY0P18WF
[CLASS] caldatemonth
[CLASSLOC] tadatetimepicker.vcx
[BASECLASS] form
[OBJNAME] caldatemonthmodal
[START PROPERTIES]
Desktop = .F.
ShowWindow = 0
DoCreate = .T.
Name = "caldatemonthmodal"
tacalendar.txtControl.Name = "txtControl"
tacalendar.cntHeader.cmdLastMonth.Name = "cmdLastMonth"
tacalendar.cntHeader.cmdNextMonth.Name = "cmdNextMonth"
tacalendar.cntHeader.lblMonthYear.Name = "lblMonthYear"
tacalendar.cntHeader.Name = "cntHeader"
tacalendar.Name = "taCalendar"
[END PROPERTIES]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] caldatemonthmodal
[START PROPERTIES]
Arial, 0, 8, 5, 14, 11, 30, 3, 0
Arial, 0, 9, 5, 15, 12, 32, 3, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _0CY0Z48LL
[CLASS] caldatemonth
[CLASSLOC] tadatetimepicker.vcx
[BASECLASS] form
[OBJNAME] caldatemonthintoplevelform
[START PROPERTIES]
Desktop = .T.
ShowWindow = 1
DoCreate = .T.
Name = "caldatemonthintoplevelform"
tacalendar.txtControl.Name = "txtControl"
tacalendar.cntHeader.cmdLastMonth.Name = "cmdLastMonth"
tacalendar.cntHeader.cmdNextMonth.Name = "cmdNextMonth"
tacalendar.cntHeader.lblMonthYear.Name = "lblMonthYear"
tacalendar.cntHeader.Name = "cntHeader"
tacalendar.Name = "taCalendar"
[END PROPERTIES]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] caldatemonthintoplevelform
[START PROPERTIES]
Arial, 0, 8, 5, 14, 11, 30, 3, 0
Arial, 0, 9, 5, 15, 12, 32, 3, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _0E4121KHX
[CLASS] container
[BASECLASS] container
[OBJNAME] keycalmonthform
[START PROPERTIES]
Width = 170
Height = 20
BackStyle = 0
BorderWidth = 0
nhostformwindowtype = 0
ocalendar = .NULL.
Name = "keycalmonthform"
[END PROPERTIES]
[START PROTECTED]
instantiatecalendar^
[END PROTECTED]
[START METHODS]
PROCEDURE Destroy
WITH THIS
	IF NOT ISNULL( .oCalendar )
		.oCalendar.RELEASE()
		.oCalendar = NULL
	ENDIF
ENDWITH

ENDPROC
PROCEDURE Init
THIS.InstantiateCalendar()

ENDPROC
PROCEDURE Resize
WITH THIS
	.cmdKeyDateTime.LEFT = .WIDTH - .cmdKeyDateTime.WIDTH - 2
	.cmdKeyDateTime.HEIGHT = .HEIGHT - 4
	.KeyDateTime.WIDTH = .WIDTH - .cmdKeyDateTime.WIDTH - 4
	.KeyDateTime.HEIGHT = .HEIGHT - 4
ENDWITH

ENDPROCPROCEDURE instantiatecalendar
#INCLUDE "FW\Comunes\Include\Praxis.h"

WITH THIS
	IF NOT .PARENT.lCalendarInstantiated
		DO CASE
			CASE THISFORM.ShowWindow = 2	&& Host form is Top Level
				.oCalendar = NEWOBJECT( "CalDateMonth", Addbs(FL_LIBS)+"taDateTimePicker" )

			CASE THISFORM.ShowWindow = 1	&& Host form is In Top Level
				.oCalendar = NEWOBJECT( "CalDateMonthInTopLevelForm", Addbs(FL_LIBS)+"taDateTimePicker" )

			OTHERWISE						&& Host form in In Screen
*!*	RR, 15/01/2004 - Quito el control de Modal / Modeless ya que en forms Modales, el control
*!*	no se cerraba si se hacía click fuera del mismo y el usuario estaba obligado a seleccionar
*!*	una fecha - Ver también This.InstantiateCalendar
*!*					IF THISFORM.WindowType = 0	&& Host form is Modeless
					.oCalendar = NEWOBJECT( "CalDateMonth", Addbs(FL_LIBS)+"taDateTimePicker" )
*!*					ELSE
*!*						.oCalendar = NEWOBJECT( "CalDateMonthModal", Addbs(FL_LIBS)+"taDateTimePicker" )
*!*					ENDIF
		ENDCASE

		IF ( TYPE( "THIS.oCalendar" ) = 'O' AND NOT ISNULL( .oCalendar ) )
			.oCalendar.VISIBLE = .F.
		ELSE
			.oCalendar = NULL			&& Can't let 'em use it
			.cmdKeyDate.ENABLED = .F.	&& if it didn't instantiate
			RETURN
		ENDIF
	ENDIF
ENDWITH

ENDPROC
PROCEDURE setposition
IF THIS.PARENT.lCalendarInstantiated
	WITH THIS.oCalendar
*!*	RR, 15/01/2004 - Quito el control de Modal / Modeless ya que en forms Modales, el control
*!*	no se cerraba si se hacía click fuera del mismo y el usuario estaba obligado a seleccionar
*!*	una fecha - Ver también This.InstantiateCalendar
*!*			IF THISFORM.WindowType = 0		&& Host form is Modeless
			.Top = OBJTOCLIENT( THIS, 1 ) + SYSMETRIC(9) + THIS.HEIGHT + ;
						IIF( THISFORM.BORDERSTYLE = 3, SYSMETRIC(4), SYSMETRIC(13) ) + ;
						IIF( THISFORM.SHOWWINDOW = 2, THISFORM.TOP, OBJTOCLIENT( THISFORM, 1 ) ) + ;
						IIF( THIS.PARENT.lTopLevelMenu, SYSMETRIC(20), 0 )
			.Left = OBJTOCLIENT( THIS, 2 ) + IIF( THISFORM.BORDERSTYLE = 3, SYSMETRIC(3), SYSMETRIC(12) ) + ;
						IIF( THISFORM.SHOWWINDOW = 2, THISFORM.LEFT, OBJTOCLIENT( THISFORM, 2 ) )

			IF ( ( .Top + .Height ) > SYSMETRIC(2) )						&& Adjust to "drop up" if
				.Top = .Top - .Height - THIS.Height - ( 2 * SYSMETRIC(13) )	&& near bottom of screen
			ENDIF
*!*			ELSE							&& Host form is Modal
*!*				.Top = OBJTOCLIENT( THIS, 1 ) + THIS.HEIGHT + SYSMETRIC(9) + ;
*!*							IIF( THISFORM.BORDERSTYLE = 3, SYSMETRIC(4), SYSMETRIC(13) ) + ;
*!*							THISFORM.Top + IIF( THIS.PARENT.lTopLevelMenu, SYSMETRIC(20), 0 )
*!*				.Left = OBJTOCLIENT( THIS, 2 ) + IIF( THISFORM.BORDERSTYLE = 3, SYSMETRIC(3), SYSMETRIC(12) ) + ;
*!*							THISFORM.LEFT

*!*				IF ( ( .Top + .Height ) > _VFP.Height )						&& Adjust to "drop up" if
*!*					.Top = .Top - .Height - THIS.Height - ( 2 * SYSMETRIC(13) )	&& near bottom of screen
*!*				ENDIF
*!*			ENDIF

		DO CASE		&& Shift horizontal position if close to right edge
			CASE .ShowWindow = 0	&& In Screen
				IF .Left + .Width > _VFP.Width
					.Left = .Left - .Width + THIS.Width - 2 * SYSMETRIC(3)
				ENDIF
			
			CASE .ShowWindow = 1	&& In Top-Level Form
				IF .Left + .Width > THISFORM.Width
					.Left = .Left - .Width + THIS.Width - 2 * SYSMETRIC(3)
				ENDIF

			CASE .ShowWindow = 2	&& Top-Level Form
				IF .Left + .Width > SYSMETRIC(1)
					.Left = .Left - .Width + THIS.Width - 2 * SYSMETRIC(3)
				ENDIF
		ENDCASE
	ENDWITH
ENDIF

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
3[END RESERVED2]
[START RESERVED3]
nhostformwindowtype Host form Modeless/Modal indicator
ocalendar Object reference to the ActiveX calendar form
*instantiatecalendar Instantiates the ActiveX MonthView
*setposition Sets the ActiveX calendar form position
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _0E412HIZL
[CLASS] keydatetime
[CLASSLOC] tadatetimepicker.vcx
[BASECLASS] textbox
[OBJNAME] Keydatetime
[PARENT] keycalmonthform
[START PROPERTIES]
Left = 0
Top = 0
Width = 150
Name = "Keydatetime"
[END PROPERTIES]
[START METHODS]
PROCEDURE KeyPress
Lparameters nKeyCode, nShiftAltCtrl

IF ( nKeyCode = -3 OR ( nKeyCode = 160 AND nShiftAltCtrl = 4 ) )	&& F4, Alt+DownArrow
	NoDefault
	IF THIS.PARENT.PARENT.lCalendarInstantiated
		With THIS.PARENT.cmdKeyDateTime
			.SETFOCUS()
			.CLICK()
		EndWith
	EndIf
Else
	DoDefault( nKeyCode, nShiftAltCtrl )
EndIf

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _0E412HIZP
[CLASS] commandbutton
[BASECLASS] commandbutton
[OBJNAME] cmdKeyDateTime
[PARENT] keycalmonthform
[START PROPERTIES]
Top = 0
Left = 152
Height = 20
Width = 16
Picture = ..\image\bmp\dropdown.bmp
Caption = ""
Enabled = .F.
TabStop = .F.
Name = "cmdKeyDateTime"
[END PROPERTIES]
[START METHODS]
PROCEDURE Click
Local ldDate

With THIS.PARENT
	If ( .PARENT.lCalendarInstantiated AND NOT .KeyDateTime.ReadOnly )
		.SetPosition()

		ldDate = IIF( EMPTY( .KeyDateTime.VALUE ), DATE(), TTOD( .KeyDateTime.Value ) )

		With .oCalendar
			.oParent = THIS.PARENT.PARENT	&& Topmost container ( Control )
			.taCalendar.Date = ldDate		&& Load the current date
			.SHOW()
		EndWith
	EndIf
EndWith

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] keycalmonthform
[START PROPERTIES]
MS Sans Serif, 1, 8, 6, 13, 11, 12, 2, 0
Arial, 0, 9, 5, 15, 12, 32, 3, 0
[END PROPERTIES]
[START RESERVED1]
  ..\include\praxis.hÎWùi²: ..\include\foxpro.hÖX|: ..\include\strings.hÞY|:[END RESERVED1]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _0E51203AO
[CLASS] control
[BASECLASS] control
[OBJNAME] tadatetimepicker
[START PROPERTIES]
Width = 170
Height = 20
BackStyle = 0
BorderWidth = 0
ToolTipText = ""
StatusBarText = ""
cbackcolor = 
century = 1
cfontbold = 
cfontitalic = 
cfontname = 
cfontsize = 
cforecolor = 
controlsource = 
dateformat = 11
datepartinitfocus = 2
ddatetime = {}
hours = 0
lexitontabonly = .T.
calbackcolor = -1
calcurrentdaybackcolor = -1
caldayandheaderforecolor = -1
caldefaultwindowcolor = .T.
caltodaybackcolor = -1
caltodayforecolor = -1
calweekdayheaderforecolor = -1
Name = "tadatetimepicker"
[END PROPERTIES]
[START METHODS]
PROCEDURE Init
LPARAMETERS lnWidth, lnHeight	&& Optional Width and Height
LOCAL cValue

IF ( VARTYPE( lnWidth ) = 'N' AND NOT EMPTY( lnWidth ) )
	THIS.Width = INT( lnWidth )
ENDIF

IF ( VARTYPE( lnHeight ) = 'N' AND NOT EMPTY( lnHeight ) )
	THIS.Height = INT( lnHeight )
ENDIF

WITH THIS
	.lCalendarInstantiated = IIF( VARTYPE( .KeyCalMonthForm.oCalendar ) = 'O', .T., .F. )
	.dDateTime = .KeyCalMonthForm.KeyDateTime.Value

	.KeyCalMonthForm.KeyDateTime.lAllowBlankDate = .lAllowBlankDate
	.KeyCalMonthForm.KeyDateTime.ControlSource = .ControlSource

	IF NOT EMPTY( .cBackColor )
		cValue = .cBackColor
		.KeyCalMonthForm.KeyDateTime.BackColor = RGB(&cValue)
	ENDIF
	.cBackColor = .KeyCalMonthForm.KeyDateTime.BackColor

	IF NOT EMPTY( .cForeColor )
		cValue = .cForeColor
		.KeyCalMonthForm.KeyDateTime.ForeColor = RGB(&cValue)
	ENDIF
	.cForeColor = .KeyCalMonthForm.KeyDateTime.ForeColor

	IF ( NOT EMPTY( .cFontBold ) AND VARTYPE( .cFontBold ) = 'L' )
		.KeyCalMonthForm.KeyDateTime.FontBold = .cFontBold
	ENDIF
	.cFontBold = .KeyCalMonthForm.KeyDateTime.FontBold

	IF ( NOT EMPTY( .cFontItalic ) AND VARTYPE( .cFontItalic ) = 'L' )
		.KeyCalMonthForm.KeyDateTime.FontItalic = .cFontItalic
	ENDIF
	.cFontItalic = .KeyCalMonthForm.KeyDateTime.FontItalic

	IF ( NOT EMPTY( .cFontName ) AND VARTYPE( .cFontName ) = 'C' )
		.KeyCalMonthForm.KeyDateTime.FontName = .cFontName
	ENDIF
	.cFontName = .KeyCalMonthForm.KeyDateTime.FontName

	IF ( NOT EMPTY( .cFontSize ) AND VARTYPE( .cFontSize ) = 'N' )
		.KeyCalMonthForm.KeyDateTime.FontSize = .cFontSize
	ENDIF
	.cFontSize = .KeyCalMonthForm.KeyDateTime.FontSize

	IF VARTYPE( .ReadOnly ) = 'L'
		.KeyCalMonthForm.KeyDateTime.ReadOnly = .ReadOnly
	ELSE
		.ReadOnly = .F.
	ENDIF

	IF NOT EMPTY( .ToolTipText )
		.KeyCalMonthForm.KeyDateTime.ToolTipText = .ToolTipText
		.KeyCalMonthForm.cmdKeyDateTime.ToolTipText = .ToolTipText
	ENDIF

	IF NOT EMPTY( .StatusBarText )
		.KeyCalMonthForm.KeyDateTime.StatusBarText = .StatusBarText
		.KeyCalMonthForm.cmdKeyDateTime.StatusBarText = .StatusBarText
	ENDIF

	IF ( NOT EMPTY( .DatePartInitFocus ) AND VARTYPE( .DatePartInitFocus ) = 'N' )
		.DatePartInitFocus = INT( .DatePartInitFocus )
		IF INLIST( .DatePartInitFocus, 1, 2, 3 )	&& Month, Day, Year
			.KeyCalMonthForm.KeyDateTime.DatePartInitFocus = .DatePartInitFocus
		ELSE
			.DatePartInitFocus = 1	&& Default
		ENDIF
	ENDIF
	.DatePartInitFocus = .KeyCalMonthForm.KeyDateTime.DatePartInitFocus

	IF VARTYPE( .DateFormat ) = 'N'
		WITH .KeyCalMonthForm.KeyDateTime
			DO CASE		&& Date Format
				CASE INLIST( THIS.DateFormat, 1, 9, 10 )		&& AMERICAN, USA, MDY
					.DateFormat = THIS.DateFormat
					.DateType = 1

				CASE INLIST( THIS.DateFormat, 3, 4, 5, 6, 11 )	&& BRITISH, FRENCH, GERMAN, ITALIAN, DMY
					.DateFormat = THIS.DateFormat
					.DateType = 2

				CASE INLIST( THIS.DateFormat, 2, 7, 8, 12 )		&& ANSI, JAPAN, TAIWAN, YMD
					.DateFormat = THIS.DateFormat
					.DateType = 3

				OTHERWISE	&& Invalid format, default to 10-MDY
					.DateFormat = 10
					.DateType = 1
					THIS.DateFormat = 10
			ENDCASE
		ENDWITH
	ELSE
		.DateFormat = 10		&& Default to MDY
		.KeyCalMonthForm.KeyDateTime.DateFormat = 10
	ENDIF

	IF ( VARTYPE( .Century ) = 'N' AND INLIST( .Century, 0, 1, 2 ) )
		.KeyCalMonthForm.KeyDateTime.Century = .Century
	ELSE
		.Century = 1	&& Default
	ENDIF

	IF ( VARTYPE( .Hours ) = 'N' AND INLIST( .Hours, 0, 12, 24 ) )
		.KeyCalMonthForm.KeyDateTime.Hours = .Hours
	ELSE
		.Hours = 0	&& Default
	ENDIF

	IF VARTYPE( .lUpDownDisabled ) = 'L'
		.KeyCalMonthForm.KeyDateTime.lUpDownDisabled = .lUpDownDisabled
	ELSE
		.UpDownDisabled = .KeyCalMonthForm.KeyDateTime.lUpDownDisabled	&& Default (.F.)
	ENDIF

	IF VARTYPE( .lExitOnTabOnly ) = 'L'
		.KeyCalMonthForm.KeyDateTime.lExitOnTabOnly = .lExitOnTabOnly
	ELSE
		.lExitOnTabOnly = .KeyCalMonthForm.KeyDateTime.lExitOnTabOnly	&& Default (.T.)
	ENDIF

*	Set up the popup Calendar properties
	WITH .KeyCalMonthForm.oCalendar.taCalendar
		.CurrentDayBackcolor = THIS.CalCurrentDayBackcolor
		.DayAndHeaderForecolor = THIS.CalDayAndHeaderForecolor
		.DefaultWindowColor = THIS.CalDefaultWindowcolor
		.ShortDay = THIS.CalShortDay
		.TodayForecolor = THIS.CalTodayForecolor
		.WeekdayHeaderForecolor = THIS.CalWeekdayHeaderForecolor
	ENDWITH
ENDWITH

ENDPROC
PROCEDURE Resize
WITH THIS.KeyCalMonthForm
	.Width = THIS.Width
	.Height = THIS.Height
ENDWITH

ENDPROC
PROCEDURE calbackcolor_assign
LPARAMETERS vNewVal

WITH THIS.KeyCalMonthForm.oCalendar.taCalendar
	IF ( VARTYPE( m.vNewVal ) = 'N' AND m.vNewVal = -1 )	&& Reset to default
		.ResetToDefault( "Backcolor" )
	ELSE
		.Backcolor = m.vNewVal
		THIS.CalBackcolor = .Backcolor	&& Synchonize properties
	ENDIF
ENDWITH

ENDPROC
PROCEDURE calcurrentdaybackcolor_assign
LPARAMETERS vNewVal

WITH THIS.KeyCalMonthForm.oCalendar.taCalendar
	.CurrentDayBackcolor = m.vNewVal
	THIS.CalCurrentDayBackcolor = .CurrentDayBackcolor	&& Synchonize properties
ENDWITH

ENDPROC
PROCEDURE caldayandheaderforecolor_assign
LPARAMETERS vNewVal

WITH THIS.KeyCalMonthForm.oCalendar.taCalendar
	.DayAndHeaderForecolor = m.vNewVal
	THIS.CalDayAndHeaderForecolor = .DayAndHeaderForecolor	&& Synchronize properties
ENDWITH

ENDPROC
PROCEDURE caldefaultwindowcolor_assign
LPARAMETERS vNewVal

WITH THIS.KeyCalMonthForm.oCalendar.taCalendar
	.DefaultWindowColor = m.vNewVal
	THIS.CalDefaultWindowColor = .DefaultWindowColor	&& Synchronize properties
ENDWITH

ENDPROC
PROCEDURE calshortday_assign
LPARAMETERS vNewVal

WITH THIS.KeyCalMonthForm.oCalendar.taCalendar
	.ShortDay = m.vNewVal
	THIS.CalShortDay = .ShortDay	&& Synchronize properties
ENDWITH

ENDPROC
PROCEDURE caltodaybackcolor_assign
LPARAMETERS vNewVal

WITH THIS.KeyCalMonthForm.oCalendar.taCalendar
	.TodayBackcolor = m.vNewVal
	THIS.CalTodayBackcolor = .TodayBackcolor	&& Synchronize properties
ENDWITH

ENDPROC
PROCEDURE caltodayforecolor_assign
LPARAMETERS vNewVal

WITH THIS.KeyCalMonthForm.oCalendar.taCalendar
	.TodayForecolor = m.vNewVal
	THIS.CalTodayForecolor = .TodayForecolor	&& Synchronize properties
ENDWITH

ENDPROC
PROCEDURE calweekdayheaderforecolor_assign
LPARAMETERS vNewVal

WITH THIS.KeyCalMonthForm.oCalendar.taCalendar
	.WeekdayHeaderForecolor = m.vNewVal
	THIS.CalWeekdayHeaderForecolor = .WeekdayHeaderForecolor	&& Synchronize properties
ENDWITH

ENDPROC
PROCEDURE cbackcolor_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method
DO CASE
	CASE VARTYPE( vNewVal ) = 'N'
		vNewVal = INT( vNewVal )
		THIS.KeyCalMonthForm.KeyDateTime.BackColor = vNewVal
		THIS.cBackColor = ALLTRIM( PADL( MOD( vNewVal, 256 ), 3 ) ) + ',' + ;
							ALLTRIM( PADL( MOD( INT( vNewVal / 256 ), 256 ), 3 ) ) + ',' + ;
							ALLTRIM( PADL( INT( vNewVal / 65536 ), 3 ) )

	CASE VARTYPE( vNewVal ) = 'C'
		THIS.KeyCalMonthForm.KeyDateTime.BackColor = RGB(&vNewVal)
		THIS.cBackColor = vNewVal
ENDCASE

ENDPROC
PROCEDURE century_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method

IF ( VARTYPE( m.vNewVal ) = 'N' AND INLIST( m.vNewVal, 0, 1, 2 ) )
	WITH THIS
		.Century = m.vNewVal
		.KeyCalMonthForm.KeyDateTime.Century = m.vNewVal
	ENDWITH
ENDIF

ENDPROC
PROCEDURE cfontbold_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method

IF VARTYPE( vNewVal ) = 'L'
	THIS.KeyCalMonthForm.KeyDateTime.FontBold = vNewVal
	THIS.cFontBold = vNewVal
ENDIF

ENDPROC
PROCEDURE cfontitalic_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method
IF VARTYPE( vNewVal ) = 'L'
	THIS.KeyCalMonthForm.KeyDateTime.FontItalic = vNewVal
	THIS.cFontItalic = vNewVal
ENDIF

ENDPROC
PROCEDURE cfontname_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method
IF ( VARTYPE( vNewVal ) = 'C' AND NOT EMPTY( vNewVal ) )
	THIS.KeyCalMonthForm.KeyDateTime.FontName = vNewVal
	THIS.cfontName = vNewVal
ENDIF

ENDPROC
PROCEDURE cfontsize_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method
IF ( VARTYPE( vNewVal ) = 'N' AND NOT EMPTY( vNewVal ) )
	THIS.KeyCalMonthForm.KeyDateTime.FontSize = vNewVal
	THIS.cFontSize = vNewVal
ENDIF

ENDPROC
PROCEDURE cforecolor_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method
DO CASE
	CASE VARTYPE( vNewVal ) = 'N'
		vNewVal = INT( vNewVal )
		THIS.KeyCalMonthForm.KeyDateTime.ForeColor = vNewVal
		THIS.cForeColor = ALLTRIM( PADL( MOD( vNewVal, 256 ), 3 ) ) + ',' + ;
							ALLTRIM( PADL( MOD( INT( vNewVal / 256 ), 256 ), 3 ) ) + ',' + ;
							ALLTRIM( PADL( INT( vNewVal / 65536 ), 3 ) )

	CASE VARTYPE( vNewVal ) = 'C'
		THIS.KeyCalMonthForm.KeyDateTime.ForeColor = RGB(&vNewVal)
		THIS.cForeColor = vNewVal
ENDCASE

ENDPROC
PROCEDURE controlsource_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method
IF VARTYPE( vNewVal ) = 'C'
	WITH THIS
		.KeyCalMonthForm.KeyDateTime.ControlSource = vNewVal
		.ControlSource = vNewVal
	ENDWITH
ENDIF

ENDPROC
PROCEDURE dateformat_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method
IF VARTYPE( m.vNewVal ) != 'N'
	RETURN
ENDIF

m.vNewVal = INT( m.vNewVal )

IF NOT BETWEEN( m.vNewVal, 0, 12 )	&& No Short/Long Dates because we can't
	RETURN							&& determine the specific date type
ENDIF

WITH THIS
	IF m.vNewVal = 0						&& Default SET DATE
		DO CASE
			CASE SET( "DATE" ) $ "AMERICANUSAMDY"
				WITH .KeyCalMonthForm.KeyDateTime
					.DateFormat = 10
					.DateType = 1
				ENDWITH
				.DateFormat = 10

			CASE SET( "DATE" ) $ "BRITISHFRENCHGERMANITALIANDMY"
				WITH .KeyCalMonthForm.KeyDateTime
					.DateFormat = 11
					.DateType = 2
				ENDWITH
				.DateFormat = 11

			CASE SET( "DATE" ) $ "ANSIJAPANTAIWANYMD"
				WITH .KeyCalMonthForm.KeyDateTime
					.DateFormat = 12
					.DateType = 3
				ENDWITH
				.DateFormat = 11

			CASE SET( "DATE" ) $ "SHORTLONG"
				RETURN
		ENDCASE
	ELSE
		DO CASE
			CASE INLIST( m.vNewVal, 1, 9, 10 )		&& AMERICAN, USA, MDY
				.KeyCalMonthForm.KeyDateTime.DateType = 1

			CASE INLIST( m.vNewVal, 3, 4, 5, 6, 11 )	&& BRITISH, FRENCH, GERMAN, ITALIAN, DMY
				.KeyCalMonthForm.KeyDateTime.DateType = 2


			CASE INLIST( m.vNewVal, 2, 7, 8, 12 )	&& ANSI, JAPAN, TAIWAN, YMD
				.KeyCalMonthForm.KeyDateTime.DateType = 3
		ENDCASE

		.KeyCalMonthForm.KeyDateTime.DateFormat = m.vNewVal
		.DateFormat = m.vNewVal
	ENDIF
ENDWITH

ENDPROC
PROCEDURE datepartinitfocus_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method

IF INLIST( m.vNewVal, 1, 2, 3 )	&& Month, Day, Year
	THIS.KeyCalMonthForm.KeyDateTime.DatePartInitFocus = m.vNewVal
	THIS.DatePartInitFocus = m.vNewVal
ENDIF

ENDPROC
PROCEDURE ddatetime_access
*To do: Modify this routine for the Access method
THIS.dDateTime = THIS.KeyCalMonthForm.KeyDateTime.Value
RETURN THIS.dDateTime

ENDPROC
PROCEDURE ddatetime_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method
IF VARTYPE( m.vNewVal ) = 'T'
	WITH THIS
		IF NOT EMPTY( m.vNewVal ) OR .lAllowBlankDate
			.KeyCalMonthForm.KeyDateTime.Value = m.vNewVal
			IF .lCalendarInstantiated AND NOT EMPTY( m.vNewVal )
				.KeyCalMonthForm.oCalendar.taCalendar.Date = TTOD( m.vNewVal )
			ENDIF
			THIS.dDateTime = m.vNewVal
		ENDIF
	ENDWITH
ENDIF

ENDPROC
PROCEDURE enabled_assign
LPARAMETERS vNewVal

IF VARTYPE( vNewVal ) != 'L'
	RETURN
ENDIF

WITH THIS
	.Enabled = m.vNewVal
	.KeyCalMonthForm.KeyDateTime.Enabled = m.vNewVal
	.KeyCalMonthForm.cmdKeyDateTime.Enabled = m.vNewVal
ENDWITH

ENDPROC
PROCEDURE hours_assign
Lparameters vNewVal

If ( Vartype( m.vNewVal ) = 'N' AND InList( m.vNewVal, 0, 12, 24 ) )
	With This
		.Hours = m.vNewVal
		.KeyCalMonthForm.KeyDateTime.Hours = m.vNewVal
	EndWith
EndIf

ENDPROC
PROCEDURE interactivechange
*	InteractiveChange Event Hook
LPARAMETERS kdValue

ENDPROC
PROCEDURE keypress
*	KeyPress Event Hook
LPARAMETERS nKeyCode, nShiftAltCtrl

ENDPROC
PROCEDURE lallowblankdate_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method
IF VARTYPE( m.vNewVal ) = 'L'
	THIS.lAllowBlankdate = vNewVal
	THIS.KeyCalMonthForm.KeyDateTime.lAllowBlankDate = vNewVal
ENDIF

ENDPROC
PROCEDURE lcalendarinstantiated_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method
THIS.lCalendarInstantiated = VARTYPE( THIS.KeyCalMonthForm.oCalendar ) = 'O'	&& Makes it read only

ENDPROC
PROCEDURE lexitontabonly_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method
WITH THIS
	IF VARTYPE( m.vNewVal ) = 'L'
		.lExitOnTabOnly = m.vNewVal
		.KeyCalMonthForm.KeyDateTime.lExitOnTabOnly = m.vNewVal
	ELSE
		.lExitOnTabOnly = .KeyCalMonthForm.KeyDateTime.lExitOnTabOnly
	ENDIF
ENDWITH

ENDPROC
PROCEDURE lupdowndisabled_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method
IF VARTYPE( m.vNewVal ) = 'L'
	THIS.lUpDownDisabled = m.vNewVal
	THIS.KeyCalMonthForm.KeyDateTime.lUpDownDisabled = m.vNewVal
ENDIF

ENDPROC
PROCEDURE programmaticchange
*	ProgrammaticChange Event Hook
LPARAMETERS kdValue
ENDPROC
PROCEDURE readonly_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method
IF VARTYPE( vNewVal ) != 'L'
	RETURN
ENDIF

WITH THIS
	.ReadOnly = m.vNewVal
	.KeyCalMonthForm.KeyDateTime.ReadOnly = m.vNewVal
ENDWITH

ENDPROC
PROCEDURE refreshfocus
THIS.KeyCalMonthForm.KeyDateTime.GotFocus()
ENDPROC
PROCEDURE statusbartext_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method

IF VARTYPE( m.vNewVal ) = 'C'
	WITH THIS
		.StatusBarText = m.vNewVal
		.KeyCalMonthForm.KeyDateTime.StatusBarText = m.vNewVal
		.KeyCalMonthForm.cmdKeyDateTime.StatusBarText = m.vNewVal
	ENDWITH
ENDIF

ENDPROC
PROCEDURE tooltiptext_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method

IF VARTYPE( m.vNewVal ) = 'C'
	WITH THIS
		.ToolTipText = m.vNewVal
		.KeyCalMonthForm.KeyDateTime.ToolTipText = m.vNewVal
		.KeyCalMonthForm.cmdKeyDateTime.ToolTipText = m.vNewVal
	ENDWITH
ENDIF

ENDPROC
PROCEDURE value_access
Return This.KeyCalMonthForm.KeyDateTime.Value

ENDPROC
PROCEDURE value_assign
Lparameters vNewVal

This.value = m.vNewVal
This.KeyCalMonthForm.KeyDateTime.Value = m.vNewVal
ENDPROC
PROCEDURE when
*	When Event Hook

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
2[END RESERVED2]
[START RESERVED3]
cbackcolor KeyDateTime back color
century Sets the Century property of the underlying KeyDateTime control
cfontbold KeyDateTime Font bold
cfontitalic KeyDateTime Font Italic
cfontname KeyDateTime Font name
cfontsize KeyDateTime Font size
cforecolor KeyDateTime ForeColor
controlsource Control Source for the datetime text box control
dateformat DateFormat of the underlying KeyDateTime contrrol
datepartinitfocus Date part highlighted when control receives focus: 1- Month (default), 2-Day, 3-Year
ddatetime Control's current datetime
lallowblankdate Allow blank ( empty ) dates
lcalendarinstantiated Status of the drop-down calendar instantiation ( Boolean )
ltoplevelmenu Indicates whether the control's parent form is Top-Level with a menu
readonly Read only for underlying controls
hours Sets the Hours property for the underlying KeyDateTime control
lupdowndisabled Disable Up/Down arrow functionality ( +/- functionality only )
lexitontabonly Exit the control on (Shift+)Tab only
calbackcolor Dropdown Calendar backcolor
calcurrentdaybackcolor Current day background ellipse color
caldayandheaderforecolor Dropdown Calendar Date and Header Month and Year forecolor
caldefaultwindowcolor Dropdown Calendar default window color flag
calshortday Dropdown Calendar short day descriptor flag
caltodaybackcolor Dropdown Calendar background ellipse color for Today
caltodayforecolor Dropdown Calendar Today forecolor
calweekdayheaderforecolor Dropdown Calendar Weekday descriptors forecolor
value Specifies the current state of a control.
*cbackcolor_assign 
*century_assign 
*cfontbold_assign 
*cfontitalic_assign 
*cfontname_assign 
*cfontsize_assign 
*cforecolor_assign 
*controlsource_assign 
*dateformat_assign 
*datepartinitfocus_assign 
*ddatetime_access 
*ddatetime_assign 
*lallowblankdate_assign 
*lcalendarinstantiated_assign 
*readonly_assign 
*statusbartext_assign 
*tooltiptext_assign 
*interactivechange Hook for InteractiveChange of underlying KeyDateTime control
*keypress Hook event for the underlying KeyDateTime KeyPress event
*programmaticchange Hook for ProgrammaticChange of underlying KeyDateTime control
*refreshfocus Fires the underlying KeyDateTime control GotFocus() for refreshing the selected date part
*when Hook event for the underlying KeyDateTime When event
*hours_assign 
*lupdowndisabled_assign 
*lexitontabonly_assign 
*calbackcolor_assign 
*calcurrentdaybackcolor_assign 
*caldayandheaderforecolor_assign 
*caldefaultwindowcolor_assign 
*calshortday_assign 
*caltodaybackcolor_assign 
*caltodayforecolor_assign 
*calweekdayheaderforecolor_assign 
*enabled_assign 
*value_access 
*value_assign 
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _0E610ZI24
[CLASS] keycalmonthform
[CLASSLOC] tadatetimepicker.vcx
[BASECLASS] container
[OBJNAME] KeyCalMonthForm
[PARENT] tadatetimepicker
[START PROPERTIES]
Top = 0
Left = 0
Height = 24
Name = "KeyCalMonthForm"
keydatetime.Height = 20
keydatetime.Left = 0
keydatetime.Top = 0
keydatetime.Name = "keydatetime"
cmdKeyDateTime.Top = 0
cmdKeyDateTime.Name = "cmdKeyDateTime"
[END PROPERTIES]
[START METHODS]
PROCEDURE keydatetime.GotFocus
*	GotFocus Event Hook
DODEFAULT()
THIS.PARENT.PARENT.GotFocus()
ENDPROC
PROCEDURE keydatetime.InteractiveChange
*	InteractiveChange Event Hook
DODEFAULT()
THIS.PARENT.PARENT.InteractiveChange( THIS.Value )

ENDPROC
PROCEDURE keydatetime.KeyPress
*	KeyPress Event Hook
LPARAMETERS nkeycode,nshiftaltctrl

DODEFAULT( nkeycode, nshiftaltctrl )
THIS.PARENT.PARENT.KeyPress( nkeycode, nshiftaltctrl )
ENDPROC
PROCEDURE keydatetime.LostFocus
*	LostFocus Event Hook
DODEFAULT()
THIS.PARENT.PARENT.LostFocus()

ENDPROC
PROCEDURE keydatetime.ProgrammaticChange
*	ProgrammaticChange Event Hook
THIS.PARENT.PARENT.ProgrammaticChange( THIS.Value )

ENDPROC
PROCEDURE keydatetime.When
*	When Event Hook
DODEFAULT()
THIS.PARENT.PARENT.When()

ENDPROC
[END METHODS]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] tadatetimepicker
[START PROPERTIES]
MS Sans Serif, 1, 8, 6, 13, 11, 12, 2, 0
Arial, 0, 9, 5, 15, 12, 32, 3, 0
[END PROPERTIES]

[ RECORD]
[PLATFORM] WINDOWS 
[UNIQUEID] _RH20ODKH7
[CLASS] textbox
[BASECLASS] textbox
[OBJNAME] keydatetime
[START PROPERTIES]
FontSize = 12
DateFormat = 11
Hours = 24
Alignment = 3
Value = (DATETIME())
Height = 27
StatusBarText = "Ingrese la fecha y Hora"
ToolTipText = "Fecha y Hora"
Width = 150
currentdatetime = 
datetype = 1
datepartinitfocus = 1
yearsellength = 4
daystart = 0
dayend = 1
monthstart = 3
monthend = 4
yearstart = 6
yearend = 9
hourstart = 11
hourend = 12
minutestart = 14
minuteend = 15
secondstart = 17
secondend = 18
ampmstart = 20
lexitontabonly = .T.
Name = "keydatetime"
[END PROPERTIES]
[START PROTECTED]
currentdatetime
daystart
dayend
monthstart
monthend
yearstart
yearend
hourstart
hourend
minutestart
minuteend
secondstart
secondend
ampmstart
hours24format
setyearsellength
setstartendpositions
[END PROTECTED]
[START METHODS]
PROCEDURE Click
THIS.SetFocus()
ENDPROC
PROCEDURE Error
LPARAMETERS nError, cMethod, nLine

*	We assume that errors in this control are
*	due to user entering in invalid date then
*	using arrow keys. Since too many tests on
*	date validity might slow the control down
*	so we opt to ignore the error. If desired
*	this can be overidden as necessary
*	The following code can be uncommented for
*	simple debugging
*	MESSAGEBOX ( "Error: " + ALLTRIM( STR( nError ) ) + CHR(13) + CHR(10) + ;
*					"Method: " + cMethod )
RETURN
ENDPROC
PROCEDURE GotFocus
LOCAL lnStart, lnLength

WITH THIS
	.SetYearSelLength()		&& Set these property values each time we enter
	.SetStartEndPositions()	&& the control in case of programmatic changes
	.CurrentDateTime = .Value

	DO CASE
		CASE .DatePartInitFocus = 2	&& Day
			lnLength = 2
			lnStart = .DayStart

		CASE .DatePartInitFocus = 3	&& Year
			lnLength = .YearSelLength
			lnStart = .YearStart

		OTHERWISE					&& Month
			lnLength = 2
			lnStart = .MonthStart
	ENDCASE

	.SelStart = lnStart
	.SelLength = lnLength
ENDWITH

ENDPROC
PROCEDURE Init
WITH THIS
	.SetYearSelLength()
	.SetStartEndPositions()
ENDWITH

ENDPROC
PROCEDURE InteractiveChange
WITH THIS
	IF INLIST( .DateType, 1, 2 )	&& MDY, DMY
		DO CASE
			CASE .SelStart = 3
				.SelLength = 2

			CASE .SelStart = 6
				.SelLength = .YearSelLength

			CASE INLIST( .SelStart, .HourStart, MinuteStart, SecondStart )
				.SelLength = 2
		ENDCASE
	ELSE							&& YMD
		IF INLIST( .SelStart, .MonthStart, .DayStart .HourStart, MinuteStart, SecondStart )	&& 5, 8
			.SelLength = 2
		ENDIF
	ENDIF
ENDWITH

ENDPROC
PROCEDURE KeyPress
LPARAMETERS nKeyCode, nShiftAltCtrl

#DEFINE	SECONDS_PER_MINUTE	60
#DEFINE	SECONDS_PER_HOUR	3600
#DEFINE	SECONDS_PER_DAY		86400

WITH THIS
	DO CASE
		CASE nKeyCode = 32					&& Space Bar ( DATE() )
			NODEFAULT
			IF .ReadOnly
				RETURN
			ENDIF
			.Value = DATE()
			.REFRESH
			.SETFOCUS()
		
		CASE nKeyCode = 1					&& Home ( Last Date entered )
			NODEFAULT
			IF .ReadOnly
				RETURN
			ENDIF
			.Value = .CurrentDateTime
			.REFRESH
			.SETFOCUS()
		
		CASE nKeyCode = 4		&& Right Arrow
			IF .ReadOnly
				NODEFAULT
				RETURN
			ENDIF
			IF .DateType = 3	&& YMD 0123/56/89 12:45:78 01, 01/34/67 12:45:78 01
								&&	   YYYY/MM/DD HH:MM:SS PM, YY/MM/DD HH:MM:SS PM
				DO CASE
					CASE .SelStart < .MonthStart	&& 5
						NODEFAULT
						.SelStart = .MonthStart		&& Moving to second date part ( Month )
						.SelLength = 2

					CASE .SelStart > .YearEnd AND .SelStart < .DayStart	&& 3, 8
						NODEFAULT
						.SelStart = .DayStart		&& Moving to third date part ( Day )
						.SelLength = 2
					
					CASE .SelStart > .MonthEnd AND .SelStart < .HourStart
						NODEFAULT
						.SelStart = .HourStart		&& Moving to Hour time part
						.SelLength = 2

					CASE .SelStart > .DayEnd AND .SelStart < .MinuteStart
						NODEFAULT
						.SelStart = .MinuteStart	&& Moving to Minute time part
						.SelLength = 2

					CASE .SelStart > .HourEnd AND .SelStart < .SecondStart
						NODEFAULT
						.SelStart = .SecondStart	&& Moving to Second time part
						.SelLength = 2

					CASE .SelStart > .MinuteEnd AND .SelStart < .AMPMStart
						NODEFAULT
						.SelStart = .AMPMStart		&& Moving to AMPM time part
						.SelLength = 2

					CASE .SelStart >= .AMPMStart
						NODEFAULT
						IF NOT .lExitOnTabOnly
							KEYBOARD '{TAB}'		&& Exiting the control
						ENDIF
					
					OTHERWISE
						NODEFAULT
				ENDCASE
			ELSE				&& MDY/DMY 01/34/6789 12:45:78 01, 01/34/67 12:45:78 01
								&&	   	   MM/DD/YYYY HH:MM:SS PM, MM/DD/YY HH:MM:SS PM
				DO CASE			&& Month and Day SelLengths are the same so we use
					CASE .SelStart < 3	&& Literals for performance here when we can
						NODEFAULT
						.SelStart = 3	&& Moving to second date part ( Day or Month )
						.SelLength = 2

					CASE .SelStart > 1 AND .SelStart < 6
						NODEFAULT
						.SelStart = 6	&& Moving to third date part ( Year )
						.SelLength = .YearSelLength

					CASE .SelStart >= .YearStart AND .SelStart < .HourStart
						NODEFAULT
						.SelStart = .HourStart		&& Moving to Hour time part
						.SelLength = 2

					CASE .SelStart > .YearEnd AND .SelStart < .MinuteStart
						NODEFAULT
						.SelStart = .MinuteStart	&& Moving to Minute time part
						.SelLength = 2

					CASE .SelStart > .HourEnd AND .SelStart < .SecondStart
						NODEFAULT
						.SelStart = .SecondStart	&& Moving to Second time part
						.SelLength = 2

					CASE .SelStart > .MinuteEnd AND .SelStart < .AMPMStart
						NODEFAULT
						.SelStart = .AMPMStart		&& Moving to AMPM time part
						.SelLength = 2
				
					CASE .SelStart >= .AMPMStart
						NODEFAULT
						IF NOT .lExitOnTabOnly
							KEYBOARD '{TAB}'		&& Exiting the control
						ENDIF
					
					OTHERWISE
						NODEFAULT
				ENDCASE
			ENDIF

		CASE nKeyCode = 19					&& Left Arrow
			IF .ReadOnly
				NODEFAULT
				RETURN
			ENDIF
			IF .DateType = 3	&& YMD 0123/56/89 12:45:78 01, 01/34/67 12:45:78 01
								&&	   YYYY/MM/DD HH:MM:SS PM, YY/MM/DD HH:MM:SS PM
				DO CASE
					CASE .Hours24Format AND .SelStart >= .SecondStart	&& Moving to Minute time part
						NODEFAULT
						.SelStart = .MinuteStart	&& Moving to Minute time part
						.SelLength = 2

					CASE .SelStart > .SecondEnd
						NODEFAULT
						.SelStart = .SecondStart	&& Moving to Seconds time part
						.SelLength = 2

					CASE .SelStart > .MinuteEnd AND .SelStart < .AMPMStart
						NODEFAULT
						.SelStart = .MinuteStart	&& Moving to Minute time part
						.SelLength = 2

					CASE .SelStart > .HourEnd AND .SelStart < .SecondStart
						NODEFAULT
						.SelStart = .HourStart	&& Moving to Hour time part
						.SelLength = 2

					CASE .SelStart > .DayEnd AND .SelStart < .MinuteStart
						NODEFAULT
						.SelStart = .DayStart	&& Moving to third date part ( Day )
						.SelLength = 2

					CASE .SelStart > .MonthEnd AND .SelStart < .HourStart	&& 7
						NODEFAULT
						.SelStart = .MonthStart	&& Moving to second date part ( Month )
						.SelLength = 2

					CASE .SelStart > .YearEnd AND .SelStart < .DayStart	&& 3, 8
						NODEFAULT
						.SelStart = 0	&& Moving to first date part ( Year )
						.SelLength = .YearSelLength
					
					CASE .SelStart < .MonthStart
						NODEFAULT
						IF NOT .lExitOnTabOnly
							KEYBOARD '{BACKTAB}'	&& Exiting the control
						ENDIF
					
					OTHERWISE
						NODEFAULT
				ENDCASE
			ELSE				&& MDY/DMY 01/34/6789 12:45:78 01, 01/34/67 12:45:78 01
								&&	   	   MM/DD/YYYY HH:MM:SS PM, MM/DD/YY HH:MM:SS PM
				DO CASE			&& Month and Day SelLengths are the same so we use literal when we can
					CASE .Hours24Format AND .SelStart >= .SecondStart	&& Moving to Minute time part
						NODEFAULT
						.SelStart = .MinuteStart	&& Moving to Minute time part
						.SelLength = 2

					CASE .SelStart > .SecondEnd
						NODEFAULT
						.SelStart = .SecondStart	&& Moving to Seconds time part
						.SelLength = 2

					CASE .SelStart > .MinuteEnd AND .SelStart < .AMPMStart
						NODEFAULT
						.SelStart = .MinuteStart	&& Moving to Minute time part
						.SelLength = 2

					CASE .SelStart > .HourEnd AND .SelStart < .SecondStart
						NODEFAULT
						.SelStart = .HourStart	&& Moving to Hour time part
						.SelLength = 2

					CASE .SelStart > .YearEnd AND .SelStart < .MinuteStart
						NODEFAULT
						.SelStart = .YearStart	&& Moving to third date part ( Year )
						.SelLength = .YearSelLength

					CASE .SelStart > 4 AND .SelStart < .HourStart
						NODEFAULT
						.SelStart = 3	&& Moving to second date part ( Day or Month )
						.SelLength = 2

					CASE .SelStart > 1 AND .SelStart < 6
						NODEFAULT
						.SelStart = 0	&& Moving to first date part ( Month or Day )
						.SelLength = 2
					
					CASE .SelStart < 3
						NODEFAULT
						IF NOT .lExitOnTabOnly
							KEYBOARD '{BACKTAB}'	&& Exiting the control
						ENDIF
					
					OTHERWISE
						NODEFAULT
				ENDCASE
			ENDIF

		CASE INLIST( nKeyCode, 5, 43, 61 )	&& Up Arrow, '+'('=') ( Increment )
			NODEFAULT
			IF ( ( .lUpDownDisabled AND nKeyCode = 5 ) OR .ReadOnly )	&& Up Arrow disabled
				RETURN
			ENDIF

			DO CASE
				CASE .DateType = 1	&& MDY 01/34/6789 12:45:78 01, 01/34/67 12:45:78 01
									&&	   MM/DD/YYYY HH:MM:SS PM, MM/DD/YY HH:MM:SS PM
					DO CASE			&& Use literals whenever possible for performance
						CASE .SelStart < 3						&& Month
							.Value = ( .Value - DTOT( TTOD( .Value ) ) ) + ;
										DTOT( GOMONTH( .Value, 1 ) )
							.REFRESH
							.SelStart = 0
							.SelLength = 2

						CASE .SelStart > 1 AND .SelStart < 6	&& Day
							.Value = .Value + SECONDS_PER_DAY
							.REFRESH
							.SelStart = 3
							.SelLength = 2

						CASE .SelStart > 4 AND .SelStart < .HourStart	&& Year
							.Value = ( .Value - DTOT( TTOD( .Value ) ) ) + ;
										DTOT( GOMONTH( .Value, 12 ) )
							.REFRESH
							.SelStart = 6
							.SelLength = .YearSelLength	&& 4

						CASE .SelStart > .YearEnd AND .SelStart < .MinuteStart	&& Hour
							.Value = .Value + SECONDS_PER_HOUR
							.REFRESH
							.SelStart = .HourStart
							.SelLength = 2

						CASE .SelStart > .HourEnd AND .SelStart < .SecondStart	&& Minute
							.Value = .Value + SECONDS_PER_MINUTE
							.REFRESH
							.SelStart = .MinuteStart
							.SelLength = 2

						CASE .SelStart > .MinuteEnd AND .SelStart < .AMPMStart	&& Second
							.Value = .Value + 1
							.REFRESH
							.SelStart = .SecondStart
							.SelLength = 2

						CASE .SelStart >= .AMPMStart			&& AM/PM or Seconds
							.Value = .Value + IIF( .Hours24Format, 1, SECONDS_PER_DAY / 2 )
							.REFRESH
							.SelStart = .AMPMStart
							.SelLength = 2

						OTHERWISE
							NODEFAULT
					ENDCASE

				CASE .DateType = 2	&& DMY 01/34/6789 12:45:78 01, 01/34/67 12:45:78 01
									&&	   DD/MM/YYYY HH:MM:SS PM, DD/MM/YY HH:MM:SS PM
					DO CASE
						CASE .SelStart < 3						&& Day
							.Value = .Value + SECONDS_PER_DAY
							.REFRESH
							.SelStart = 0
							.SelLength = 2

						CASE .SelStart > 1 AND .SelStart < 6	&& Month
							.Value = ( .Value - DTOT( TTOD( .Value ) ) ) + ;
										DTOT( GOMONTH( .Value, 1 ) )
							.REFRESH
							.SelStart = 3
							.SelLength = 2

						CASE .SelStart > 4 AND .SelStart < .HourStart	&& Year
							.Value = ( .Value - DTOT( TTOD( .Value ) ) ) + ;
										DTOT( GOMONTH( .Value, 12 ) )
							.REFRESH
							.SelStart = 6
							.SelLength = .YearSelLength	&& 4

						CASE .SelStart > .YearEnd AND .SelStart < .MinuteStart	&& Hour
							.Value = .Value + SECONDS_PER_HOUR
							.REFRESH
							.SelStart = .HourStart
							.SelLength = 2

						CASE .SelStart > .HourEnd AND .SelStart < .SecondStart	&& Minute
							.Value = .Value + SECONDS_PER_MINUTE
							.REFRESH
							.SelStart = .MinuteStart
							.SelLength = 2

						CASE .SelStart > .MinuteEnd AND .SelStart < .AMPMStart	&& Second
							.Value = .Value + 1
							.REFRESH
							.SelStart = .SecondStart
							.SelLength = 2

						CASE .SelStart >= .AMPMStart			&& AM/PM or Seconds
							.Value = .Value + IIF( .Hours24Format, 1, SECONDS_PER_DAY / 2 )
							.REFRESH
							.SelStart = .AMPMStart
							.SelLength = 2

						OTHERWISE
							NODEFAULT
					ENDCASE

				OTHERWISE			&& YMD 0123/56/89 12:45:78 01, 01/34/67 12:45:78 01
									&&	   YYYY/MM/DD HH:MM:SS PM, YY/MM/DD HH:MM:SS PM
					DO CASE
						CASE .SelStart < .MonthStart	&& 5	&& Year
							.Value = ( .Value - DTOT( TTOD( .Value ) ) ) + ;
										DTOT( GOMONTH( .Value, 12 ) )
							.REFRESH
							.SelStart = 0
							.SelLength = .YearSelLength	&& 4

						CASE .SelStart > .YearEnd AND .SelStart < .DayStart	&& Month ( 3, 8 )
							.Value = ( .Value - DTOT( TTOD( .Value ) ) ) + ;
										DTOT( GOMONTH( .Value, 1 ) )
							.REFRESH
							.SelStart = .MonthStart	&& 5
							.SelLength = 2

						CASE .SelStart >= .MonthEnd AND .SelStart < .HourStart	&& Day
							.Value = .Value + SECONDS_PER_DAY
							.REFRESH
							.SelStart = .DayStart	&& 8
							.SelLength = 2

						CASE .SelStart > .DayEnd AND .SelStart < .MinuteStart	&& Hour
							.Value = .Value + SECONDS_PER_HOUR
							.REFRESH
							.SelStart = .HourStart
							.SelLength = 2

						CASE .SelStart > .HourEnd AND .SelStart < .SecondStart	&& Minute
							.Value = .Value + SECONDS_PER_MINUTE
							.REFRESH
							.SelStart = .MinuteStart
							.SelLength = 2

						CASE .SelStart > .MinuteEnd AND .SelStart < .AMPMStart	&& Second
							.Value = .Value + 1
							.REFRESH
							.SelStart = .SecondStart
							.SelLength = 2

						CASE .SelStart >= .AMPMStart			&& AM/PM or Seconds
							.Value = .Value + IIF( .Hours24Format, 1, SECONDS_PER_DAY / 2 )
							.REFRESH
							.SelStart = .AMPMStart
							.SelLength = 2

						OTHERWISE
							NODEFAULT
					ENDCASE
				ENDCASE

		CASE INLIST( nKeyCode, 24, 45 )	&& Down Arrow, '-' ( Decrement )
			NODEFAULT
			IF ( ( .lUpDownDisabled AND nKeyCode = 24 ) OR .ReadOnly )	&& Down Arrow disabled
				RETURN
			ENDIF

			DO CASE
				CASE .DateType = 1	&& MDY 01/34/6789 12:45:78 01, 01/34/67 12:45:78 01
									&&	   MM/DD/YYYY HH:MM:SS PM, MM/DD/YY HH:MM:SS PM
					DO CASE			&& Use literals whenever possible for performance
						CASE .SelStart < 3						&& Month
							.Value = ( .Value - DTOT( TTOD( .Value ) ) ) + ;
										DTOT( GOMONTH( .Value, -1 ) )
							.REFRESH
							.SelStart = 0
							.SelLength = 2

						CASE .SelStart > 1 AND .SelStart < 6	&& Day
							.Value = .Value - SECONDS_PER_DAY
							.REFRESH
							.SelStart = 3
							.SelLength = 2

						CASE .SelStart > .DayEnd AND .SelStart < .HourStart	&& Year
							.Value = ( .Value - DTOT( TTOD( .Value ) ) ) + ;
										DTOT( GOMONTH( .Value, -12 ) )
							.REFRESH
							.SelStart = 6
							.SelLength = .YearSelLength

						CASE .SelStart > .YearEnd AND .SelStart < .MinuteStart	&& Hour
							.Value = .Value - SECONDS_PER_HOUR
							.REFRESH
							.SelStart = .HourStart
							.SelLength = 2

						CASE .SelStart > .HourEnd AND .SelStart < .SecondStart	&& Minute
							.Value = .Value - SECONDS_PER_MINUTE
							.REFRESH
							.SelStart = .MinuteStart
							.SelLength = 2

						CASE .SelStart > .MinuteEnd AND .SelStart < .AMPMStart	&& Second
							.Value = .Value - 1
							.REFRESH
							.SelStart = .SecondStart
							.SelLength = 2

						CASE .SelStart >= .AMPMStart			&& AM/PM or Seconds
							.Value = .Value - IIF( .Hours24Format, 1, SECONDS_PER_DAY / 2 )
							.REFRESH
							.SelStart = .AMPMStart
							.SelLength = 2

						OTHERWISE
							NODEFAULT
					ENDCASE

				CASE .DateType = 2	&& DMY 01/34/6789 12:45:78 01, 01/34/67 12:45:78 01
									&&	   DD/MM/YYYY HH:MM:SS PM, DD/MM/YY HH:MM:SS PM
					DO CASE
						CASE .SelStart < 3						&& Day
							.Value = .Value - SECONDS_PER_DAY
							.REFRESH
							.SelStart = 0
							.SelLength = 2

						CASE .SelStart > 1 AND .SelStart < 6	&& Month
							.Value = ( .Value - DTOT( TTOD( .Value ) ) ) + ;
										DTOT( GOMONTH( .Value, -1 ) )
							.REFRESH
							.SelStart = 3
							.SelLength = 2

						CASE .SelStart > .MonthEnd AND .SelStart < .HourStart	&& Year
							.Value = ( .Value - DTOT( TTOD( .Value ) ) ) + ;
										DTOT( GOMONTH( .Value, -12 ) )
							.REFRESH
							.SelStart = 6
							.SelLength = .YearSelLength

						CASE .SelStart > .YearEnd AND .SelStart < .MinuteStart	&& Hour
							.Value = .Value - SECONDS_PER_HOUR
							.REFRESH
							.SelStart = .HourStart
							.SelLength = 2

						CASE .SelStart > .HourEnd AND .SelStart < .SecondStart	&& Minute
							.Value = .Value - SECONDS_PER_MINUTE
							.REFRESH
							.SelStart = .MinuteStart
							.SelLength = 2

						CASE .SelStart > .MinuteEnd AND .SelStart < .AMPMStart	&& Second
							.Value = .Value - 1
							.REFRESH
							.SelStart = .SecondStart
							.SelLength = 2

						CASE .SelStart >= .AMPMStart			&& AM/PM or Seconds
							.Value = .Value - IIF( .Hours24Format, 1, SECONDS_PER_DAY / 2 )
							.REFRESH
							.SelStart = .AMPMStart
							.SelLength = 2

						OTHERWISE
							NODEFAULT
					ENDCASE

				OTHERWISE			&& YMD 0123/56/89 12:45:78 01, 01/34/67 12:45:78 01
									&&	   YYYY/MM/DD HH:MM:SS PM, YY/MM/DD HH:MM:SS PM
					DO CASE
						CASE .SelStart < .MonthStart	&& 5	&& Year
							.Value = ( .Value - DTOT( TTOD( .Value ) ) ) + ;
										DTOT( GOMONTH( .Value, -12 ) )
							.REFRESH
							.SelStart = 0
							.SelLength = .YearSelLength	&& 4

						CASE .SelStart > .YearEnd AND .SelStart < .DayStart	&& Month ( 3, 8 )
							.Value = ( .Value - DTOT( TTOD( .Value ) ) ) + ;
										DTOT( GOMONTH( .Value, -1 ) )
							.REFRESH
							.SelStart = .MonthStart	&& 5
							.SelLength = 2

						CASE .SelStart > .MonthEnd AND .SelStart < .HourStart	&& Day
							.Value = .Value - SECONDS_PER_DAY
							.REFRESH
							.SelStart = .DayStart	&& 8
							.SelLength = 2

						CASE .SelStart > .DayEnd AND .SelStart < .MinuteStart	&& Hour
							.Value = .Value + SECONDS_PER_HOUR
							.REFRESH
							.SelStart = .HourStart
							.SelLength = 2

						CASE .SelStart > .HourEnd AND .SelStart < .SecondStart	&& Minute
							.Value = .Value + SECONDS_PER_MINUTE
							.REFRESH
							.SelStart = .MinuteStart
							.SelLength = 2

						CASE .SelStart > .MinuteEnd AND .SelStart < .AMPMStart	&& Second
							.Value = .Value + 1
							.REFRESH
							.SelStart = .SecondStart
							.SelLength = 2

						CASE .SelStart >= .AMPMStart			&& AM/PM or Seconds
							.Value = .Value - IIF( .Hours24Format, 1, SECONDS_PER_DAY / 2 )
							.REFRESH
							.SelStart = .AMPMStart
							.SelLength = 2

						OTHERWISE		&& AM/PM
							NODEFAULT
					ENDCASE
			ENDCASE

		CASE nKeyCode = 7								&& Del
			IF ( .ReadOnly OR NOT .lAllowBlankDate )
				NODEFAULT
				RETURN
			ENDIF
			.Value = {  /  /  }

		CASE ( ( nKeyCode > 47 AND nKeyCode < 60 ) OR INLIST( nKeyCode, 65, 97, 80, 112 ) )
			IF .ReadOnly	&& Pass Digits, 'A', 'a', 'P' and 'p' if editable
				NODEFAULT
				RETURN
			ENDIF

		CASE INLIST( nKeyCode, 9, 15 )					&& Pass TAB, Shift+TAB

		CASE ( nKeyCode = 13 )							&& Pass the Enter key

		CASE ( nKeyCode = 127 )							&& Pass the Backspace key

		CASE ( nKeyCode = 27 )							&& Pass the Escape key

		OTHERWISE										&& Inhibit all other key strokes
			NODEFAULT
	ENDCASE
ENDWITH

ENDPROC
PROCEDURE Valid
IF EMPTY( THIS.Value )
	IF NOT THIS.lAllowBlankDate
		RETURN 0
	ENDIF
ELSE
	IF YEAR( THIS.Value ) = 0
		RETURN 0
	ENDIF
ENDIF

ENDPROC
PROCEDURE datepartinitfocus_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method

IF INLIST( m.vNewVal, 1, 2, 3 )	&& Month, Day, Year
	THIS.DatePartInitFocus = m.vNewVal
ENDIF

ENDPROC
PROCEDURE lexitontabonly_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method
IF VARTYPE( m.vNewVal ) = 'L'
	THIS.lExitOnTabOnly = m.vNewVal
ENDIF

ENDPROC
PROCEDURE lupdowndisabled_assign
LPARAMETERS vNewVal
*To do: Modify this routine for the Assign method
IF VARTYPE( vNewVal ) = 'L'
	THIS.lUpDownDisabled = m.vNewVal
ENDIF

ENDPROC
PROCEDURE setstartendpositions
*	We set the positions for testing when moving
*	between date and time parts, etc.
WITH THIS
*	Date data
	DO CASE
		CASE .DateType = 1			&& MDY 01/34/6789
			.DayStart = 3
			.DayEnd = 4
			.MonthStart = 0
			.MonthEnd = 1
			.YearStart = 6
			.YearEnd = 7			&& Century Off	(01/34/67)

			IF .YearSelLength = 4	&& Century On	(01/34/6789)
				.YearEnd = .YearEnd + 2
			ENDIF

		CASE .DateType = 2			&& DMY 01/34/6789
			.DayStart = 0
			.DayEnd = 1
			.MonthStart = 3
			.MonthEnd = 4
			.YearStart = 6
			.YearEnd = 7			&& Century Off	(01/34/67)

			IF .YearSelLength = 4	&& Century On	(01/34/6789)
				.YearEnd = .YearEnd + 2
			ENDIF

		OTHERWISE					&& YMD 0123/56/89
			.YearStart = 0

			.YearEnd = 1			&& Century Off	(01/34/67)
			.MonthStart = 3
			.MonthEnd = 4
			.DayStart = 6
			.DayEnd = 7

			IF .YearSelLength = 4	&& Century On	(0123/56/89)
				.YearEnd = .YearEnd + 2
				.MonthStart = .MonthStart + 2
				.MonthEnd = .MonthEnd + 2
				.DayStart = .DayStart + 2
				.DayEnd = .DayEnd + 2
			ENDIF
	ENDCASE

*	Time data
	.HourStart = 9		&& Century Off
	.MinuteStart = 12
	.SecondStart = 15
	.AMPMStart = 18
	.Hours24Format = .F.

	IF .YearSelLength = 4	&& Century On (01/34/6789)
		.HourStart = .HourStart + 2
		.MinuteStart = .MinuteStart + 2
		.SecondStart = .SecondStart + 2
		.AMPMStart = .AMPMStart + 2
	ENDIF

	.HourEnd = .HourStart + 1
	.MinuteEnd = .MinuteStart + 1
	.SecondEnd = .SecondStart + 1

	IF ( .Hours = 24 OR ( .Hours = 0 AND SET( "HOURS" ) = 24 ) )
		.AMPMStart = .SecondStart	&& 24 hour Military time
		.Hours24Format = .T.
	ENDIF
ENDWITH

ENDPROC
PROCEDURE setyearsellength
WITH THIS
	DO CASE
		CASE .Century = 0	&& Off
			.YearSelLength = 2

		CASE .Century = 1	&& On
			.YearSelLength = 4

		CASE .Century = 2	&& Default
			IF SET( "CENTURY" ) = "ON"
				.YearSelLength = 4
			ELSE
				.YearSelLength = 2
			ENDIF
	ENDCASE
ENDWITH

ENDPROC
[END METHODS]
[START RESERVED1]
Class[END RESERVED1]
[START RESERVED2]
1[END RESERVED2]
[START RESERVED3]
currentdatetime Datetime on field entry
lallowblankdate Allow blank dates
datetype Date Type 1-{mm/dd/yy},{mm-dd-yy},{mm.dd.yy}, 2-{dd/mm/yy},{dd-mm-yy},{dd.mm.yy}, 3-(yy/mm/dd),(yy-mm-dd),(yy.mm.dd)
datepartinitfocus Date part highlighted when control receives focus: 1- Month (default), 2-Day, 3-Year
yearsellength Selected length of the year ( 2 or 4 )
daystart Day Start position
dayend Day end position
monthstart Month start position
monthend Month end position
yearstart Year start position
yearend Year end position
hourstart Hour Start position
hourend Hour End position
minutestart Minute Start position
minuteend Minute End position
secondstart Second Start position
secondend Second End position
ampmstart AM-PM Start position
hours24format 24 Hour Clock format flag
lexitontabonly Exit the control only on (Shift+)Tab
lupdowndisabled Disable Up/Down arrow keys ( +/- functionality only )
*datepartinitfocus_assign 
*setyearsellength Sets the year selected length
*setstartendpositions Sets the Day, Month and Year Start and End positions
*lexitontabonly_assign 
*lupdowndisabled_assign 
[END RESERVED3]
[START RESERVED6]
Pixels[END RESERVED6]

[ RECORD]
[PLATFORM] COMMENT 
[UNIQUEID] RESERVED  
[OBJNAME] keydatetime
[START PROPERTIES]
Arial, 0, 12, 7, 19, 15, 43, 3, 1
[END PROPERTIES]
[EOF]
